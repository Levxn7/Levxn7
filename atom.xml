<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>就花荫</title>
  
  
  <link href="https://levxn7.github.io/atom.xml" rel="self"/>
  
  <link href="https://levxn7.github.io/"/>
  <updated>2024-04-12T12:45:04.000Z</updated>
  <id>https://levxn7.github.io/</id>
  
  <author>
    <name>levxn7</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【置顶】欢迎光临我的学习笔记，随笔记录比较简陋，希望对你有所帮助</title>
    <link href="https://levxn7.github.io/2024/04/20/help/"/>
    <id>https://levxn7.github.io/2024/04/20/help/</id>
    <published>2024-04-20T02:31:18.000Z</published>
    <updated>2024-04-12T12:45:04.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>图像分割的几种模型</title>
    <link href="https://levxn7.github.io/2024/02/02/aid/txfg/"/>
    <id>https://levxn7.github.io/2024/02/02/aid/txfg/</id>
    <published>2024-02-02T02:31:18.000Z</published>
    <updated>2024-04-22T09:25:53.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="图像分割的分类："><a href="#图像分割的分类：" class="headerlink" title="图像分割的分类："></a>图像分割的分类：</h4><p><img src="/2024/02/02/aid/txfg/eb531a75e29bfed9d71079eec9cfb2c2.png" alt="eb531a75e29bfed9d71079eec9cfb2c2.png"></p><h4 id="图像分割的难点"><a href="#图像分割的难点" class="headerlink" title="图像分割的难点"></a>图像分割的难点</h4><p>1）数据问题：分割不像检测等任务，只需要标注边框就可以使用，分割需要精确到<br>像素级标注，包括每一个目标的轮廓等信息；<br>2）计算资源问题：要想得到较高的精度就需要使用更深的网络、进行更精确的计<br>算，对计算资源要求较高。目前业界有一些轻量级网络，但总体精度较低；<br>3）精细分割：目前很多算法对于道路、建筑物等类别分割精度很高，能达到98%，<br>而对于细小的类别，由于其轮廓太小，而无法精确的定位轮廓；<br>4）上下文信息：分割中上下文信息很重要，否则会造成一个目标被分成多个部分，<br>或者不同类别目标分类成相同类别；</p><h4 id="图像分割基本原理"><a href="#图像分割基本原理" class="headerlink" title="图像分割基本原理"></a>图像分割基本原理</h4><ol><li><p>整体实现思路<br>图像分割一般思路如下：<br>1）输入图像，利用深度卷积神经网络提取特征<br>2）对特征图进行上采样，输出每个像素的类别<br>3）利用损失函数，对模型进行优化，将每个像素的分类结果优化到最接近真实值<br><img src="/2024/02/02/aid/txfg/d307294eb80b6711f840583c2b7c73fa.png" alt="d307294eb80b6711f840583c2b7c73fa.png"></p></li><li><p>评价指标<br>1）像素精度（pixel accuracy ）：每一类像素正确分类的个数/ 每一类像素的实际<br>个数；<br>2）平均像素精度（mean pixel accuracy ）：每一类像素的精度的平均值；<br>3）平均交并比（Mean Intersection over Union）：求出每一类的IOU取平均值</p></li></ol><h4 id="常用模型"><a href="#常用模型" class="headerlink" title="常用模型"></a>常用模型</h4><h5 id="1-FCN（2014）Fully-Convolutional-Networks"><a href="#1-FCN（2014）Fully-Convolutional-Networks" class="headerlink" title="1. FCN（2014）Fully Convolutional Networks"></a>1. FCN（2014）Fully Convolutional Networks</h5><p>FCN(Fully Convolutional Networks)的基本概念和核心思想。FCN是首个使用神经网络实现语义分割任务的方法与传统的特征提取算法相比，FCN具有很多优势，如可以适应不同场景变化、无需大量人时间和精力等。视频中还介绍了FCN的全卷积网络结构、使用现有的分类网络进行调整以及跨层结构等关键点。最后，视频提供了官方代码实现的细老<br>图像分割需要对图像进行像素级分类，所以在输出层使用全连接模型并不合适。<br>FCN与CNN的区别在把于CNN最后的全连接层换成卷积层（所以称为“全卷积网<br>络”）。该网络可以分为两部分，第一部分，通过卷积运算提取图像中的特征，形成<br>特征图；第二部分，对特征图进行上采样，将特征图数据恢复为原来的大小，并对<br>每个像素产生一个分类标签，完成像素级分类。</p><p>去掉了全链接层，全部使用卷积网络，可以不再要求输入图片的大小<br>分为32s  16s  8s3中输出<br><img src="/2024/02/02/aid/txfg/88a125da67fcc6b88729e56ad01040cd.png" alt="88a125da67fcc6b88729e56ad01040cd.png"><br><img src="/2024/02/02/aid/txfg/fe6b68d72aedf7d3c1e6d0e3d2dab7d4.png" alt="fe6b68d72aedf7d3c1e6d0e3d2dab7d4.png"><br><img src="/2024/02/02/aid/txfg/cfc88e392fee0a83c0552a29798c16cd.png" alt="cfc88e392fee0a83c0552a29798c16cd.png"><br><img src="/2024/02/02/aid/txfg/a2ac30edca9647a1db5e0ecaa76e3be2.png" alt="a2ac30edca9647a1db5e0ecaa76e3be2.png"></p><p><img src="/2024/02/02/aid/txfg/fee378ad378dc22885dafc223ef2ef77.png" alt="fee378ad378dc22885dafc223ef2ef77.png"></p><h5 id="2-U-Net（2015）"><a href="#2-U-Net（2015）" class="headerlink" title="2. U-Net（2015）"></a>2. U-Net（2015）</h5><p>生物医学分割是图像分割重要的应用领域。U-Net是2015年发表的用于生物医学图<br>像分割的模型，该模型简单、高效、容易理解、容易定制，能在相对较小的数据集<br>上实现学习。该模型在透射光显微镜图像（相衬度和DIC）上获得了2015年ISBI细胞<br>跟踪挑战赛的冠军。该图像分割速度较快，在512x512图像实现分割只需不到一秒<br>钟的时间。<br>U-Net基本实现图像分割基本原理与FCN一致，先对原图进行若干层卷积、池化，得<br>到特征图，再对特征图进行不断上采样，并产生每个像素的类别值。</p><p>1）网络结构<br>U-Net网络体系结构如下图所示，它由收缩路径（左侧）和扩展路径（右侧）组成，<br>共包含23个卷积层。<br>收缩路径遵循卷积网络的典型结构，它包括重复应用两个3x3卷积（未相加的卷<br>积），每个卷积后面都有一个ReLU和一个2x2最大合并操作，步长为2，用于下<br>采样。在每个下采样步骤中，特征通道的数量加倍。<br>扩展路径中的每一步都包括对特征映射进行上采样，然后进行2x2向上卷积<br>（up-convolution ），将特征通道数量减半，与收缩路径中相应裁剪的特征映<br>射进行串联，以及两个3x3卷积，每个卷积后面都有一个ReLU。在最后一层，<br>使用1x1卷积将每个64分量特征向量映射到所需数量的类<br><img src="/2024/02/02/aid/txfg/4b62c535ae33035d523e1361d2ccaef7.png" alt="4b62c535ae33035d523e1361d2ccaef7.png"><br>但是现在很多人使用unet模型会加padding，使得输出图像与输入图像尺寸相等</p><h5 id="3-Mask-R-CNN（2017）"><a href="#3-Mask-R-CNN（2017）" class="headerlink" title="3. Mask R-CNN（2017）"></a>3. Mask R-CNN（2017）</h5><p>Mask R-CNN是一个小巧灵活的通用实例级分割框架，它不仅可对图像中的目标进行<br>检测，还可以对每一个目标给出一个高质量的分割结果。它在Faster R-CNN基础之<br>上进行扩展，并行地在bounding box recognition分支上添加一个用于预测目标掩<br>模（object mask）的新分支。该网络具有良好的扩展性，很容易扩展到其它任务中，比如估计人的姿势。Mask R-CNN结构简单、准确度高、容易理解，是图像实例<br>级分割的优秀模型</p><p>1）主要思想<br>（1）分割原理。Mask R-CNN是在Faster R-CNN基础之上进行了扩展。Faster R<br>CNN是一个优秀的目标检测模型，能较准确地检测图像中的目标物体（检测到实<br>例），其输出数据主要包含两组：一组是图像分类预测，一组是图像边框回归。<br>Mask R-CNN在此基础上增加了FCN来产生对应的像素分类信息（称为Mask），用<br>来描述检测出的目标物体的范围，所以Mask R-CNN可以理解为Faster R-CNN +<br>FCN。整体结构如下图所示<br><img src="/2024/02/02/aid/txfg/3085fc1be2d57247362fb3249f0c909a.png" alt="3085fc1be2d57247362fb3249f0c909a.png"><br><img src="/2024/02/02/aid/txfg/de7af8ee8168caf2deccc5e47d66da5f.png" alt="de7af8ee8168caf2deccc5e47d66da5f.png"></p><h5 id="4-deeplab"><a href="#4-deeplab" class="headerlink" title="4. deeplab"></a>4. deeplab</h5><p><strong>空洞卷积dilated convolution</strong>： 卷积数量不变，参数个数不变，但感受野变大<br><img src="/2024/02/02/aid/txfg/f76094366cdf7fcea2f936f393c3eef0.png" alt="f76094366cdf7fcea2f936f393c3eef0.png"><br>空洞卷积的优势：<br>图像分割任务中(其他场景也适用)需要较大感受野来更好完成任务<br>通过设置dilation rate参数来完成空洞卷积，并没有额外计算<br>可以按照参数扩大任意倍数的感受野，而且没有引入额外的参数<br>应用简单，就是卷积层中多设置一个参数就可以了</p><p>空洞卷积的优势,包括全局感受、可控参数和应用简单等作者解释了为什么在很多网络结构中都使用堆叠3x3的卷积核,而不是直接使用大的卷积核,通过算笔账,说明堆叠小的卷积核可以节省参数,引入更多的非线性函数,从而提高模型效果。视频还介绍了感受野的概念,以及为什么感受野大小在分割任务中很重要。</p><p>v2：<br>spp layer<br><img src="/2024/02/02/aid/txfg/176f7e07358f2d61ef3a2383edb1cde6.png" alt="176f7e07358f2d61ef3a2383edb1cde6.png"><br><img src="/2024/02/02/aid/txfg/31416fc90b45bd6eb6608f9d75809426.png" alt="31416fc90b45bd6eb6608f9d75809426.png"></p><p>aspp 加了空洞卷积的spp 把不同倍率的空洞卷积融合在一起<br><img src="/2024/02/02/aid/txfg/9e5032731b3848d7677bd0087d06407b.png" alt="9e5032731b3848d7677bd0087d06407b.png"></p><p>v3<br>padding=空洞数，就可以保证得到的特征图宽高相等<br>特征融合<br><img src="/2024/02/02/aid/txfg/c4482417331e3eed26d87569cc30d29c.png" alt="c4482417331e3eed26d87569cc30d29c.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;图像分割的分类：&quot;&gt;&lt;a href=&quot;#图像分割的分类：&quot; class=&quot;headerlink&quot; title=&quot;图像分割的分类：&quot;&gt;&lt;/a&gt;图像分割的分类：&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2024/02/02/aid/txfg/eb531a75e29bfed</summary>
      
    
    
    
    <category term="深度学习" scheme="https://levxn7.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图像分割" scheme="https://levxn7.github.io/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>NMS(非极大值抑制)和IOU(交并比)</title>
    <link href="https://levxn7.github.io/2023/11/08/aid/iou/"/>
    <id>https://levxn7.github.io/2023/11/08/aid/iou/</id>
    <published>2023-11-08T02:31:18.000Z</published>
    <updated>2024-04-22T09:25:36.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>目标检测任务中常用的后处理方法NMS(非极大值抑制)和IOU(交井比)的概念。NMS的作用是删除冗余的候选框，保留置信度最高的候选框。通过计算BBOX之间的IOU，可以判断哪些候选框需要保留，哪些需要丢弃。在多类别目标检测任务中，需要分别对每个类别进行NMS计算，保留置信度最高的候选框。最后，只有保留的候选框才会被输出。</p><p>目标检测任务中常用的坐标损失计算方式，包括L1损失、L2损失、smoothL1损失、I0U损失、GIOU损失和DIOU损失。其中，smoothL1损失和IOU损失是基础损失和评估指标的组合，存在目标不一致的问题。GIOU损失解决了IOU损失在训练初期模型无法优化的问题，并能更好地评估模型的预测效果。DIOU损失是GIOU损失的一种变换形式，可用于计算目标检测的坐标损失。</p><h4 id="计算损失"><a href="#计算损失" class="headerlink" title="计算损失"></a>计算损失</h4><p>目标检测任务中常用的坐标损失计算方式,包括<strong>L1、L2损失、smooth L1损失</strong>等,并分析了它们的优缺点。<br>L1损失和L2损失:L1损失和L2损失是最基础的损失函数，但存在一些问题。<br><img src="/2023/11/08/aid/iou/69e37af88c8570b1c4a67f61df98c965.png" alt="69e37af88c8570b1c4a67f61df98c965.png"></p><p>为了避免模型学习优化和模型评估的目标不一致，我们最好也使用IOU来计算坐标损失并且，IOU Loss 是将 x，y, w, h这4个值构成的 bbox 看作是一个整体来进行损失计算的</p><p>SmoothL1损失是针对L1损失和L2损失的问题提出的一种损失函数。<br>在实际应用中，SmoothL1损失和L1损失、L2损失一样，都需要计算坐标损失。<br><img src="/2023/11/08/aid/iou/6a3b435a0f1517f8d0edcc250f5ef964.png" alt="6a3b435a0f1517f8d0edcc250f5ef964.png"></p><p>但是IOU不能处理两个框不相交的情况，为了解决这种情况，所以使用GIOU，做一个外接框<br><img src="/2023/11/08/aid/iou/f1aee2a6b93376778efceb7be9b46a9f.png" alt="f1aee2a6b93376778efceb7be9b46a9f.png"></p><p>当预测框与真实框为包含关系时，GIOU loss函数的分子为0，所以就退化为了IOU，所以，模型没办法针对这种情况进行区分，不能明确的知道两个框的位置关系到底是什样的，从而进行快速收敛。</p><p>DIOU和DIOU loss损失的计算方法，以及如何通过调整参数来平衡长宽比和面积一致性。<br>阿尔法参数的调整:介绍了如何通过调整阿尔法参数来平衡不同损失函数之间的权重<br>在计算DIOU时需要考虑距离的占比,以及引入阿尔法项的作用,最终得到了DLOU loss。<br>考虑距离的占比，即D的平方除以C的平方<br>阿尔法的作用，使损失函数更具区分度</p><p><img src="/2023/11/08/aid/iou/ace3e2368aafd2df1c4ce0b166cf770a.png" alt="ace3e2368aafd2df1c4ce0b166cf770a.png"></p><p>CIOU loss的计算公式，包括减去IOU和加上阿尔法乘以v<br><img src="/2023/11/08/aid/iou/1195e45c140017820ccc4744e00e619f.png" alt="1195e45c140017820ccc4744e00e619f.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;目标检测任务中常用的后处理方法NMS(非极大值抑制)和IOU(交井比)的概念。NMS的作用是删除冗余的候选框，保留置信度最高的候选框。通过计</summary>
      
    
    
    
    <category term="深度学习" scheme="https://levxn7.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="目标检测" scheme="https://levxn7.github.io/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于损失函数的一些曲线图</title>
    <link href="https://levxn7.github.io/2023/10/21/aid/loss/"/>
    <id>https://levxn7.github.io/2023/10/21/aid/loss/</id>
    <published>2023-10-21T02:31:18.000Z</published>
    <updated>2024-04-22T09:25:07.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>损失函数关于w的曲线：<br><img src="/2023/10/21/aid/loss/4bae5b4dc16dfa85a8a1113dd0ba0387.png" alt="4bae5b4dc16dfa85a8a1113dd0ba0387.png"><br>损失函数关于w和b的三维曲线<br><img src="/2023/10/21/aid/loss/340642ea96d3fe0626029f7972a2c3c0.png" alt="340642ea96d3fe0626029f7972a2c3c0.png"><br>变成二维图会变成等高线的形状，中间的圆点是最小值<br><img src="/2023/10/21/aid/loss/3cbaccc46f83158f56417465808b5387.png" alt="3cbaccc46f83158f56417465808b5387.png"></p><p>梯度下降的直观图<br><img src="/2023/10/21/aid/loss/b49693bead4e9cc60ea8533ce5736b2f.png" alt="b49693bead4e9cc60ea8533ce5736b2f.png"></p><p>三维图的梯度下降<br><img src="/2023/10/21/aid/loss/ae9348c7b7bd8dc6c79406fab3920686.png" alt="ae9348c7b7bd8dc6c79406fab3920686.png"></p><p><strong>学习率关于损失函数的曲线：</strong><br>这是一个好的学习率的曲线，当曲线趋于平稳时，说明损失函数已经几乎不再变化，这时的w和b就是一个合理的参数。如果曲线越来越大，可能学习率选择的不够好。<br><img src="/2023/10/21/aid/loss/38193d8049a2a70b9d5f83a6c22a036d.png" alt="38193d8049a2a70b9d5f83a6c22a036d.png"><br>两种错误的学习率<br><img src="/2023/10/21/aid/loss/014d853ebfa48797e0bec47466cb991f.png" alt="014d853ebfa48797e0bec47466cb991f.png"></p><p>线性回归与逻辑回归的平方差损失函数曲线图如下：<br>所以不推荐逻辑回归使用平方差损失函数，会导致查出区域最低点<br><img src="/2023/10/21/aid/loss/162255c4466525269f7c1907d9107cd4.png" alt="162255c4466525269f7c1907d9107cd4.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;损失函数&quot;&gt;&lt;a href=&quot;#损失函数&quot; class=&quot;headerlink&quot; title=&quot;损失函数&quot;&gt;&lt;/a&gt;损失函数&lt;/h4&gt;&lt;p&gt;损失函数关于w的曲线：&lt;br&gt;&lt;img src=&quot;/2023/10/21/aid/loss/4bae5b4dc16dfa85</summary>
      
    
    
    
    <category term="机器学习" scheme="https://levxn7.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>三种插值法</title>
    <link href="https://levxn7.github.io/2023/10/12/aid/chazhifa/"/>
    <id>https://levxn7.github.io/2023/10/12/aid/chazhifa/</id>
    <published>2023-10-12T02:31:18.000Z</published>
    <updated>2024-04-22T09:24:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>插值算法的应用,其中包括<strong>最邻近插值和双线性插值</strong>。插值算法一般被用于图像的上采样或下采样。最邻近插值是最简单的插值算法,通过最近的像素值来确定目标图像中的像素值。插值算法的使用场景包括图像分割和增强等。此外，最邻近插值算法还有其独特的使用场景,例如在处理标注图像时需要保证标注像素值的正确性</p><h4 id="最近临插值法"><a href="#最近临插值法" class="headerlink" title="最近临插值法"></a>最近临插值法</h4><p>方法：将两个特征图换成同等大小，根据距离需计算的像素点最近的原像素点来确定该点的值<br>缺点：采样后的图有毛边<br>计算过程<br><img src="/2023/10/12/aid/chazhifa/0f8d7b018b849df344c03d7b8ae5b885.png" alt="0f8d7b018b849df344c03d7b8ae5b885.png"><br><img src="/2023/10/12/aid/chazhifa/1d222281f67ba8f6869cc0d8ddba5cba.png" alt="1d222281f67ba8f6869cc0d8ddba5cba.png"></p><h4 id="双线性插值法"><a href="#双线性插值法" class="headerlink" title="双线性插值法"></a>双线性插值法</h4><p>双线性差值的计算方式，包括角对齐方式和边对齐方式。通过代码实现，详细讲解了目标图像中每个像素点的计算取值过程。同时，还介绍了两种对齐方式下的差异以及计算过程中的权重考虑。对于需要进行上采样处理的图像，可以通过双线性插值的方式实现。<br>方法有两种：角对齐 或者边对齐<br><img src="/2023/10/12/aid/chazhifa/965ccd22942b67dcd885817c6a80cf84.png" alt="965ccd22942b67dcd885817c6a80cf84.png"><br>计算过程<br><img src="/2023/10/12/aid/chazhifa/83957cc48d6ecfdaf4e409d7d3298f63.png" alt="83957cc48d6ecfdaf4e409d7d3298f63.png"></p><h4 id="双三次插值法"><a href="#双三次插值法" class="headerlink" title="双三次插值法"></a>双三次插值法</h4><p>双三次插值算法，该算法在计算目标像素点周围像素权重时使用了一个三次项的公式，相比于双线性插值算法，它对目标像素点的像素取值做了一个平滑处理。通过示意图和公式解释了权重的计算方法，并展示了在不同距离下权重的取值情况。最后，解释了padding的作用。<br>取周围16个点的值<br><img src="/2023/10/12/aid/chazhifa/e9848703a4a02e0b1f0e39fa59073f17.png" alt="e9848703a4a02e0b1f0e39fa59073f17.png"><br><img src="/2023/10/12/aid/chazhifa/be9b059b09acca463291720c594b85af.png" alt="be9b059b09acca463291720c594b85af.png"></p><p>各种插值法取值图例<br><img src="/2023/10/12/aid/chazhifa/438ddab67c1755d06255978de075ac87.png" alt="438ddab67c1755d06255978de075ac87.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;插值算法的应用,其中包括&lt;strong&gt;最邻近插值和双线性插值&lt;/strong&gt;。插值算法一般被用于图像的上采样或下采样。最邻近插值是最简单的插值算法,通过最近的像素值来确定目标图像中的像素值。插值算法的使用场景包括图像分割和增强等。此外，最邻近插值算法还有其独特的使用场景</summary>
      
    
    
    
    <category term="机器学习" scheme="https://levxn7.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>批量归一化 Batch Normalization</title>
    <link href="https://levxn7.github.io/2023/10/11/aid/bn/"/>
    <id>https://levxn7.github.io/2023/10/11/aid/bn/</id>
    <published>2023-10-11T02:31:18.000Z</published>
    <updated>2024-04-22T09:24:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>神经网络中的批量归一化方法,通过对一批样本进行归一化处理,使得每一层网络的输入分布相似,从而避免了分布差异过大导致网络无法收敛的问题。</p><p>为了让网络可以正常训练，Batch Normalization 批量归一化方法可以加速神经网络的收敛。使训练过程中对学习率和参数初始化更加鲁棒</p><p>但它也有一些缺陷,如对循环神经网络等序列形式数据性能较差,以及在分布式训练中额外的数据同步会影响并行效率等。</p><p>神经网络中的批量归一化方法，通过对样本进行归一化处理，使网络能够正常训练。</p><p>需要注意批量归一化方法中额外引入的两个参数，需要反向传播更新</p><p>仅在Batch中包含样本数量较多时有效。对循环网络(RNN)或序列数据(Sequence)性能较差分布式运算时影响效率。</p><p>BN算法仅在BH中包含样本，对于循环神经网络等数据性能较差</p><p>后续提出了类似于layer normalization等改进方法</p><p><img src="/2023/10/11/aid/bn/93968aee8b1f72101a7f5ff44788f110.png" alt="93968aee8b1f72101a7f5ff44788f110.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;神经网络中的批量归一化方法,通过对一批样本进行归一化处理,使得每一层网络的输入分布相似,从而避免了分布差异过大导致网络无法收敛的问题。&lt;/p&gt;
&lt;p&gt;为了让网络可以正常训练，Batch Normalization 批量归一化方法可以加速神经网络的收敛。使训练过程中对学习率和</summary>
      
    
    
    
    <category term="机器学习" scheme="https://levxn7.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>深度学习基础xmind</title>
    <link href="https://levxn7.github.io/2023/09/02/aid/deepbasic/"/>
    <id>https://levxn7.github.io/2023/09/02/aid/deepbasic/</id>
    <published>2023-09-02T02:31:18.000Z</published>
    <updated>2024-04-22T09:24:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2023/09/02/aid/deepbasic/basic.png" alt="basic.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2023/09/02/aid/deepbasic/basic.png&quot; alt=&quot;basic.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="深度学习" scheme="https://levxn7.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习概述</title>
    <link href="https://levxn7.github.io/2023/08/16/aid/aid1jqxxgs/"/>
    <id>https://levxn7.github.io/2023/08/16/aid/aid1jqxxgs/</id>
    <published>2023-08-16T02:31:18.000Z</published>
    <updated>2024-04-22T09:22:47.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>关于人工智能我想学蛮久了的，各种各样的原因加持下 ，我终于还是来赶了晚班车。我始终相信，人工智能是人类的未来。这里借用吴恩达的一句话：“我认为AGI被过度炒作了，我们离这个目标还有很长的路要走，他可能花费50年、500年，甚至更久”。但我愿意等，并为之付出。</p><h4 id="机器学习概述"><a href="#机器学习概述" class="headerlink" title="机器学习概述"></a>机器学习概述</h4><blockquote><p>监督学习</p></blockquote><p>在已知数据输出（经过标注的）的情况下对模型进行训练，根据输出进行调整、优化的学习方式称为有监督学习.</p><blockquote><p>无监督学习</p></blockquote><p>没有已知输出的情况下，仅仅根据输入信息的相关性，进行类别的划分. </p><blockquote><p>半监督学习</p></blockquote><p>先通过无监督学习划分类别，再人工标记通过有监督学习方式来预测输出.例如先对相似的水果进行聚类，再识别是哪个类别. </p><h4 id="脚手架工具"><a href="#脚手架工具" class="headerlink" title="脚手架工具"></a>脚手架工具</h4><p>脚手架工具是帮我们自动创建基础文件的工具<br>脚手架的本质作用就是创建项目基础结构、提供项目规范和约定, 相同的组织结构, 相同的开发范式, 相同的模块依赖, 相同的工具配置, 相同的基础代码都应该被自动化创建</p><p><strong>内容概要:</strong></p><ul><li>脚手架的作用</li><li>常用的脚手架工具</li><li>通用脚手架工具剖析</li><li>开发一款脚手架</li></ul><p><strong>常用的脚手架工具</strong><br>根据信息创建对应的项目基础结构有create-react-app, vue-cli, angular-cli等<br>例如创建一个组件/模块所需要的文件就可以用到plop</p><h5 id="Yeoman"><a href="#Yeoman" class="headerlink" title="Yeoman"></a>Yeoman</h5><p>The web’s scaffolding tool for modern webapps<br>可以搭配不同的generator去创建任何类型项目, 可以使用其搭建自己的脚手架<br>缺点是过于通用, 不够专注</p><p><strong>基本使用</strong><br>先安装基础模块: node, npm 或 yarn, 以下举例中我们使用yarn</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="built_in">global</span> add yo <span class="comment">//全局安装Yeoman</span></span><br><span class="line">yarn <span class="built_in">global</span> add generator-node <span class="comment">// 一个node模块</span></span><br><span class="line">mkdir my-<span class="built_in">module</span></span><br><span class="line">cd my-<span class="built_in">module</span></span><br><span class="line">yo node <span class="comment">//input something...</span></span><br></pre></td></tr></table></figure><p>执行yo node后的命令行如下(做个例子)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;关于人工智能我想学蛮久了的，各种各样的原因加持下 ，我终于还是来赶了晚班车。我始终相信，人工智能是人类的未来。这里借用吴恩达的一句话：“我认</summary>
      
    
    
    
    <category term="AID学习笔记" scheme="https://levxn7.github.io/categories/AID%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="机器学习" scheme="https://levxn7.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数学-链式求导</title>
    <link href="https://levxn7.github.io/2023/05/17/math/lsqd/"/>
    <id>https://levxn7.github.io/2023/05/17/math/lsqd/</id>
    <published>2023-05-17T02:31:18.000Z</published>
    <updated>2024-03-20T15:18:57.740Z</updated>
    
    <content type="html"><![CDATA[<h4 id="链式求导"><a href="#链式求导" class="headerlink" title="链式求导"></a>链式求导</h4><p><strong>求导链式法则（Chain Rule）是微积分中的一个重要概念，用于计算复合函数(Composite Functions)的导数。<br>拓展知识：</strong></p><p><strong>一、链式法则的基本概念：</strong></p><p><strong>复合函数</strong>: 以另一种方式将两个函数组合起来的函数。正式定义：<br>令f 和g 分别为两个函数，函数(f。g)(x) = f (g(x))称为f 与g 的复合函数。复合函数 f。g 的定义域为所有g 的定义域中使得g(x) 在f 的定义域中的所有x 的集合。即，复合函数的定义域中的自变量，首先必须满足是位于g 的定义域中，同时，这个自变量也必须满足使其函数g 的值位于f 的定义域中，满足这两个限制的所有x 的值，构成复合函数的定义域。</p><p><strong>链式法则适用于复合函数，即一个函数中包含了另一个函数</strong>。假如 y = f (u)是一个u 的可微函数，u = g (x)是一个x 的可微函数，则 y = f (g(x)) 是一个x 的可微函数，则链式法则描述了如何计算y关于x的导数dy/dx。链式法则的一般形式如下：<img src="/2023/05/17/math/lsqd/0f851c998b97de73e58d052d32485d19.png" alt="0f851c998b97de73e58d052d32485d19">(即y 对x 的导数，等于y 对u 的导数，乘以u 对x 的导数。)</p><p>这个公式表明，要计算复合函数y=f(g(x))的导数，首先计算f关于中间变量u=g(x)的导数，然后计算u关于自变量x的导数，并将它们相乘。</p><p>当然，复合函数还可以继续复合，组成更复杂的函数。也就是说，复合函数是两套以上的映射法则。一般来讲，f与g 的复合函数，与g 与f 的复合函数，是不一样的复合函数。</p><h4 id="二、示例："><a href="#二、示例：" class="headerlink" title="二、示例："></a>二、示例：</h4><p><img src="/2023/05/17/math/lsqd/5b0f965dec10074a1f78dd550d0a5416.png" alt="5b0f965dec10074a1f78dd550d0a5416.png"></p><h4 id="三、应用领域："><a href="#三、应用领域：" class="headerlink" title="三、应用领域："></a>三、应用领域：</h4><p>链式法则在物理学、工程学、计算机科学等领域广泛应用。在机器学习和深度学习中，链式法则是计算梯度（导数）的基本工具，用于训练神经网络和优化模型参数。它也在控制理论、信号处理和优化问题中发挥关键作用。</p><h4 id="四、总结："><a href="#四、总结：" class="headerlink" title="四、总结："></a>四、总结：</h4><p>链式法则是微积分中的一项重要技巧，用于计算复合函数的导数。它允许我们在分析和解决问题时处理包含多个函数的复杂情况，是许多科学和工程领域的基础工具之一。深入理解链式法则有助于更好地理解和应用微积分知识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;链式求导&quot;&gt;&lt;a href=&quot;#链式求导&quot; class=&quot;headerlink&quot; title=&quot;链式求导&quot;&gt;&lt;/a&gt;链式求导&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;求导链式法则（Chain Rule）是微积分中的一个重要概念，用于计算复合函数(Composite Func</summary>
      
    
    
    
    <category term="AID学习笔记" scheme="https://levxn7.github.io/categories/AID%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数学" scheme="https://levxn7.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数学-线性代数</title>
    <link href="https://levxn7.github.io/2023/04/02/math/xxds/"/>
    <id>https://levxn7.github.io/2023/04/02/math/xxds/</id>
    <published>2023-04-02T02:31:18.000Z</published>
    <updated>2024-03-20T15:18:57.740Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>线性代数是代数学的一个分支，主要处理线性关系问题。线性关系意即数学对象之间的关系是以一次形式来表达的。线性代数是一个伟大的学科，这里不做细述，推荐细看B站3blue1brown的视频，解释的非常详细。</p><h5 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a>一、基本概念：</h5><p>线性（linear）指量与量之间按比例、成直线的关系，在数学上可以理解为一阶导数为常数的函数<br>非线性（non-linear）则指不按比例、不成直线的关系，一阶导数不为常数。</p><p><strong>一、向量是什么？</strong><br>1、物理学眼中（空间中的箭头）<br>2、计算机学眼中（有序的数字列表）<br>3、数学眼中（只要能玩向量加法和数字乘法就行）<br><strong>二、计算方法</strong><br>1、向量加法（两个向量内部数字对应起来相加即可）<br>2、向量乘法（向量内部数字直接乘外部数字即可）<br><strong>三、线性代数的意义</strong><br>1、为数据分析提供了列表概念化和可视化的方法<br>2、看起来简洁易懂，也会帮助人理解某些特殊运算的意义。<br>3、为物理学家和计算机图形程序员提供了一个更好的描述并操纵空间的形式。</p><p><strong>链式法则适用于复合函数，即一个函数中包含了另一个函数</strong>。假如 y = f (u)是一个u 的可微函数，u = g (x)是一个x 的可微函数，则 y = f (g(x)) 是一个x 的可微函数，则链式法则描述了如何计算y关于x的导数dy/dx。链式法则的一般形式如下：<img src="/2023/04/02/math/xxds/0f851c998b97de73e58d052d32485d19.png" alt="0f851c998b97de73e58d052d32485d19">(即y 对x 的导数，等于y 对u 的导数，乘以u 对x 的导数。)</p><p>这个公式表明，要计算复合函数y=f(g(x))的导数，首先计算f关于中间变量u=g(x)的导数，然后计算u关于自变量x的导数，并将它们相乘。</p><p>当然，复合函数还可以继续复合，组成更复杂的函数。也就是说，复合函数是两套以上的映射法则。一般来讲，f与g 的复合函数，与g 与f 的复合函数，是不一样的复合函数。</p><h4 id="二、示例："><a href="#二、示例：" class="headerlink" title="二、示例："></a>二、示例：</h4><p><img src="/2023/04/02/math/xxds/5b0f965dec10074a1f78dd550d0a5416.png" alt="5b0f965dec10074a1f78dd550d0a5416.png"></p><h4 id="三、应用领域："><a href="#三、应用领域：" class="headerlink" title="三、应用领域："></a>三、应用领域：</h4><p>链式法则在物理学、工程学、计算机科学等领域广泛应用。在机器学习和深度学习中，链式法则是计算梯度（导数）的基本工具，用于训练神经网络和优化模型参数。它也在控制理论、信号处理和优化问题中发挥关键作用。</p><h4 id="四、总结："><a href="#四、总结：" class="headerlink" title="四、总结："></a>四、总结：</h4><p>链式法则是微积分中的一项重要技巧，用于计算复合函数的导数。它允许我们在分析和解决问题时处理包含多个函数的复杂情况，是许多科学和工程领域的基础工具之一。深入理解链式法则有助于更好地理解和应用微积分知识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;线性代数是代数学的一个分支，主要处理线性关系问题。线性关系意即数学对象之间的关系是以一次形式来表达的。线性代数是一个伟大的学科，这里不做细述</summary>
      
    
    
    
    <category term="AID学习笔记" scheme="https://levxn7.github.io/categories/AID%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数学" scheme="https://levxn7.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>python入门语法速查手册</title>
    <link href="https://levxn7.github.io/2023/03/10/python/python/"/>
    <id>https://levxn7.github.io/2023/03/10/python/python/</id>
    <published>2023-03-10T02:31:18.000Z</published>
    <updated>2024-03-20T15:18:57.748Z</updated>
    
    <content type="html"><![CDATA[<hr><h4 id="语法速查手册"><a href="#语法速查手册" class="headerlink" title="语法速查手册"></a>语法速查手册</h4><h5 id="数据基本运算"><a href="#数据基本运算" class="headerlink" title="数据基本运算"></a>数据基本运算</h5><ul><li><p>变量</p><pre><code>  变量名 = 数据</code></pre></li><li><p>人机交互</p><pre><code>  变量名 = input(提示信息)  print(结果)</code></pre></li><li><p>数据类型</p><pre><code>  整数int  小数float  字符串str  转换  变量名 = 目标类型(待转数据)</code></pre></li><li><p>数学运算</p><ol><li><p>算数运算符</p><pre><code> + - * 幂运算** 小数商/ 整数商// 余数%</code></pre></li><li><p>增强运算符</p><pre><code> +=  -=  *= 幂运算**= 小数商/= 整数//= 余数%=</code></pre></li></ol><ul><li><p>布尔运算</p><pre><code>  * bool类型      True条件满足      False条件不满足  * 比较运算符      \&gt; &lt; &gt;= &lt;=      等于==      不等于!=  * 逻辑运算符      并且and      或者or      取反not</code></pre></li></ul></li></ul><h5 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h5><ul><li><p>选择语句</p><pre><code>  if 条件1:      满足条件1执行的代码  elif 条件2:      不满足条件1,但满足条件2执行的代码  else:      不满足条件执行的代码</code></pre></li><li><p>循环语句</p><pre><code>  while 循环  while True:        循环体        if 退出条件:              break  计时器 = 开始  while 计数器 &lt; 结束值:         循环体         计时器 += 间隔</code></pre></li><li><p>for 计数器 in range(开始,结束,间隔):</p></li><li><p>跳转语句</p><pre><code>  break  continue</code></pre></li></ul><h5 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h5><ul><li><p>列表list</p><pre><code>  适用性:存储多个有顺序的数据</code></pre></li><li><p>基础操作</p><pre><code>  创建  列表名 = [数据1,数据2]  添加  列表名.append(数据)  列表名.insert(索引,数据)  定位  列表名[整数]  列表名[开始:结束:间隔]  删除  del 列表名[整数]  del 列表名[开始:结束:间隔]  列表名.remove(元素)  遍历  for item in 列表名:  for i in range(len(列表名)):</code></pre></li><li><p>深浅拷贝</p><pre><code>  深拷贝:复制所有层  import copy  新列表 = copy.deepcopy(旧列表)  浅拷贝:只复制一层,共享深层  新列表 = 旧列表[:]</code></pre></li><li><p>列表推导式</p><pre><code>  新列表 = []  for item in 可迭代对象:        if 条件:              新列表.append(item)  新列表 = [item for item in 可迭代对象 if 条件]</code></pre></li><li><p>元组tuple</p><pre><code>  适用性:存储无需改变的有序数据,比列表节省内存空间  基础操作  创建  元组名 = (数据1,数据2)  元组名 = 数据1,数据2  元组名 = (数据1,)  定位  元组名[整数]  元组名[开始:结束:间隔]  遍历  for item in 元组名:</code></pre></li><li><p>字符串str</p><pre><code>  转义符:换行\n  \&quot;  \&#39;    \\  格式化字符串  语法:&quot;格式&quot;%(变量)  占位符  %s原样输出  %.2f四舍五入  %.2d整数位数</code></pre></li><li><p>字典dict</p><pre><code>  适用性:存储有多个维度的数据  基础操作  创建  字典名 = &#123;键1:值,键2:值&#125;  添加  字典名[键] = 值  定位  字典名[键]  删除  del 字典名[键]  遍历  for key in 字典名:  for value in 字典名.values():  for key,value in 字典名.items():    字典推导式    新字典= &#123;&#125;  for 变量 in 可迭代对象:        if 条件:              新字典[键] = 值  新字典 = &#123;键:值 for 变量 in 可迭代对象 if 条件&#125;</code></pre></li><li><p>容器嵌套</p><pre><code>  列表内嵌字典  列表名 = [        &#123;键1:值,键2:值&#125;,        &#123;键1:值,键2:值&#125;,  ]  列表名[索引][键]  列表内嵌列表  列表名 = [        [元素1,元素2],        [元素1,元素2],  ]  列表名[索引][索引]]</code></pre></li></ul><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><ul><li><p>作用:将功能的做法与用法分离</p></li><li><p>语法</p><pre><code>  def 函数名(参数):        某个功能的做法        return 结果  变量名 = 函数名(数据)</code></pre></li><li><p>函数将结果存储在传入的可变对象中</p><pre><code>  而不使用返回值return  def 函数名(参数):       参数[0] = 结果  可变对象 = []  函数名(可变对象)  print(可变对象[0])</code></pre></li><li><p>作用域</p><pre><code>  局部变量:函数内部创建,只能函数内部使用  def 函数名(参数):        局部变量名 = 数据  全局变量:在文件中创建,整个文件都可使用  全局变量名1 = 数据  def 函数名():        print(全局变量名1)        global 全局变量名2        全局变量名2 = 新数据  全局变量名2 = 数据</code></pre></li><li><p>参数</p><pre><code>  形式参数:限制实参  def 函数名(参数1,参数2)  def 函数名(参数1=数据,参数2=数据)  def 函数名(*args):  def 函数名(**kwargs):  def 函数名(*args,参数):  def 函数名(*,参数):  实际参数:如何与形参进行对应  函数名(数据1,数据2)  函数名(参数2=数据2)  函数名(*序列)  函数名(**字典)</code></pre></li></ul><h5 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h5><ul><li><p>类和对象</p><pre><code>  类:由变量和函数组成的新数据类型  class 类名:       def __init__(self,参数):             self.实例变量 = 参数       def 函数名(self,参数):             语句组  对象名 = 类名(数据)  对象名.实例变量  对象名.函数名(数据)  跨类调用  class A:       def a(self):           变量名 = B()           变量名.b()  class B:       def b(self):            pass  class A:       def __init__(self):            self.变量名 = B()       def a(self):           self.变量名.b()  class B:       def b(self):            pass  class A:       def a(self,参数):           参数.b()  class B:       def b(self):            pass  变量 = A()  变量.a(B())  继承  class 爸爸:       def __init__(self,爸爸参数):              self.爸爸的实例变量 = 爸爸参数       def 爸爸的函数(self):  class 儿子(爸爸):       def __init__(self,爸爸参数,儿子参数):              super().__init__(爸爸参数)              self.儿子的实例变量 =  儿子参数       def 儿子的函数(self):           self.爸爸的函数()  多态  class Model:       # print时自动调用       def __str__():       # remove时自动调用       def __eq__():       # sort时自动调用       def __gt__():</code></pre></li></ul><h5 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h5><ul><li><p>导入模块</p><pre><code>  import 包.模块名  包.模块名.成员  from 包.模块名 import 成员名  直接使用成员名</code></pre></li><li><p>time模块</p><pre><code>  时间  时间戳 = time.time()  时间元组 = time.localtime()  转换  时间元组 = time.localtime(时间戳)  时间戳 = time.mktime(时间元组)  格式化  字符串 = time.strftime(格式, 时间元组)  时间元组 = time.strptime(字符串,格式)</code></pre></li><li><p>异常处理</p><pre><code>  处理  try:      可能出错的语句  except 异常类型:      处理逻辑  except Exception:      处理逻辑  finally:      一定执行的逻辑  发送  raise 异常类型()</code></pre></li><li><p>生成器</p><pre><code>  函数  定义  def 函数名():       函数体       yield 数据  调用  生成器对象 = 函数名()    # 调用函数不执行    for item in 生成器对象:  生成器对象 =函数名()  容器类型(生成器对象)  内置生成器  for i,item in enumerate(容器):  for item in zip(容器1,容器2)  表达式  生成器对象 = (变量 for 变量 in 可迭代对象)</code></pre></li><li><p>函数式编程</p><pre><code>  函数作为参数  高阶函数  def 通用函数(容器,条件):       for item in 容器:           if 条件(item):               return item  lambda 表达式  结果 = 通用函数(容器,lambda 参数:函数体)  函数作为返回值  装饰器  def 装饰器名称(func):      def wrapper(*args,**kwargs):          新功能&quot;          result = func(*args,**kwargs)          return result      return wrapper  @装饰器名称  def 旧功能():</code></pre></li></ul><h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><ul><li><p>文件管理</p><pre><code>  创建路径  对象名 = Path(目录1,目录2)  对象名 = Path.cwd().joinpath(&quot;目录1&quot;,&quot;目录2&quot;)  路径信息  对象名.absolute()  # 绝对路径(路径类型)  对象名.name  # 带后缀的完整文件名(str类型)  对象名.stem  # 文件名不带后缀(str类型)  对象名.suffix # 文件后缀(str类型)  对象名.parent  # 上一级路径(路径类型)  对象名.parts  # 分割路径(tuple类型)  对象名.exists()  # 路径是否存在(bool类型)  对象名.is_file()  # 是否文件(bool类型)  对象名.is_dir()  # 是否目录(bool类型)  对象名.is_absolute() # 是否绝对路径(bool类型)  对象名.stat().st_ctime  # 创建时间(时间戳)  对象名.stat().st_atime  # 访问时间(时间戳)  对象名.stat().st_mtime  # 修改的时间(时间戳)  对象名.stat().st_size  # 文件大小(字节Bete)  搜索目录  # 搜索当前目录所有路径(一层)  生成器 = 对象名.iterdir():  # 根据通配符搜索当前目录所有路径(一层)  生成器 = path.glob(&quot;通配符&quot;):  # 根据通配符递归搜索当前目录所有路径(多层)  生成器 = 对象名.rglob(&quot;通配符&quot;)  新建路径  # 新建文件  对象名.touch()  # 新建目录  对象名.mkdir()  # 忽略目录存在时的报错  对象名.mkdir(exist_ok=True)  重命名  对象名.rename(新路径对象)  删除路径  # 删除文件(永久删除，回收站不存在)  对象名.unlink()  # 删除目录(目录必须为空)  对象名.rmdir()</code></pre></li><li><p>文件读写</p><pre><code>  文本文件  打开  with open(文件路径,&quot;操作模式&quot;,encoding=&quot;编码方式&quot;) as 对象名:      通过对象名操作文件  操作  # 读取指定数量字符  字符串 = 对象名.read(字符数)  列表 = 对象名.readlines()  # 读取文件每行字符  for 行 in 对象名:  # 将字符串写入到文件  字符数 = 对象名.write(字符串)  二进制文件  打开  with open(文件路径,&quot;操作模式&quot;) as 对象名:      通过对象名操作文件  操作  # 读取文件中指定数量字节  字节串 = 对象名.read(字节数)  # 将字节串写入到文件  字节数 = 对象名.write(字节串)</code></pre></li></ul><h5 id="数据库基础操作"><a href="#数据库基础操作" class="headerlink" title="数据库基础操作"></a>数据库基础操作</h5><ul><li><p>DDL</p><pre><code>  create database 数据库名称;  use 数据库名称;  create table 表名 (      列名 数据类型 约束 comment &#39;注释&#39;,      列名 数据类型 约束 comment &#39;注释&#39;  ) comment=&#39;注释&#39;;  数据类型  int  float  char(字符数)  varchar(字符数)  约束  primay key  auto_increment  not null  check(条件)  default(默认值)</code></pre></li><li><p>DML</p><pre><code>  insert into 表名(列名) values(数据);  update 表名 set 列名 = 值,列名 = 值 where 条件;  delete from 表名 where 条件;</code></pre></li><li><p>DQL(单条语句)</p><pre><code>  select 列名1,列名2 from 表名;  select 列名1,列名2 from 表名 where 条件;  select 聚合函数(列名) from 表名 where 条件;  select 聚合函数(列名) from 表名 where 条件 group by 列名;  select  case        when 条件 then 结果        else 结果  end  from 表名;  select  聚合函数(列名),  case        when 条件 then 结果        else 结果  end as 别名  from 表名  group by 别名;  select 聚合函数(列名) from 表名 where 条件 group by 列名  having 对聚合结果处理的条件;  select 列名 from 表名 where 条件 group by 列名  having 对聚合结果处理的条件  order by 列名 desc;  select 列名 from 表名 where 条件  group by 列名 having 对聚合结果处理的条件  order by 列名 desc  limit 查询的行数 offset 跳过的行数;  select 列名 from 表名 ...  union all  select 列名 from 表名 ...</code></pre></li><li><p>多表查询</p><pre><code>  连接查询  select 列名 from 表1 join 表2 on 表1.共同列 = 表2.共同列...;  select 列名 from 表1 left join 表2 on 表1.共同列 = 表2.共同列...;  select 列名 from 表1 right join 表2 on 表1.共同列 = 表2.共同列...;  子查询  # 第一步:  select ....  # 第二步:  select ....  # 第三步:  select .... (      select ....  )</code></pre></li><li><p>数据库优化</p><ol><li><p>数据库设计三大范式</p><pre><code>     第一范式:表中每列数据，不可再被拆分，不允许多个数据存储在一列中     第二范式:每行必须可以被唯一区分，所有列依赖于主键列     第三范式:非主键列不能依赖其他非主键列</code></pre></li><li><p>索引</p><pre><code>     定义:加快数据库查询速度的一种数据结构</code></pre></li><li><p>B+树</p></li><li><p>分类</p><pre><code>     create index 索引名 on 表名(列名);     create unique index 索引名 on 表名(列名);     create index 索引名 on 表名(列名1,列名2);     create unique index 索引名 on 表名(列名1,列名2);</code></pre></li><li><p>SQL语句优化</p><pre><code>     何时用索引     1.为经常用于查询的列创建索引     2.尽量选择区分度高的列作为索引，区分度越高索引效率越高     3. 尽量避免使用select *，用具体列名代替*，可减少回表查询     4. 建立外键会自动建立索引，在关联查询时建议使用外键作为关联条件     会导致索引失效的操作     1.在索引列上使用like模糊匹配，如果以通配符开头，会导致索引失效     2. 在索引列上进行运算操作，会导致索引失效     3.or两边的列有一个没索引，就会导致另一个索引失效     联合索引注意事项     1. 联合索引要遵守最左前缀法则，即查询从索引的最左列开始     2. 联合索引,范围查询时（&gt; &lt; !=），右侧引索列失效     按效率：count(*) ≈ count(1) &gt; count(主键) &gt; count(列名)</code></pre></li><li><p>事务四大特征</p><pre><code>     原子性 + 一致性     原理     - 回滚日志undolog：       - 记录数据被修改前的信息，供回滚到事务开始前     - 每行的2个隐藏列：       - 事务ID：最近操作当前行的事务编号       - 回滚指针：指向undolog中该行修改前的信息     隔离性     持久性     原理     重做日志redolog：     - 记录对数据的修改，供系统故障后能够恢复</code></pre></li><li><p>隔离级别</p><pre><code>     可重复读repeatable read     原理：第一次select时获取一个视图快照，在事务执行期间，其他事务对数据的修改不影响当前事务的视图快照，保持了事务开始时的一致性。     串行化serializable     多个事务排队执行，每个事务在执行完之前，下一个事务无法执行     读已提交read committed     能够读取其他事务已提交的数据，不读取未提交的数据     读未提交read uncommitted     可以读取其他事务未提交的数据</code></pre></li></ol></li></ul><h5 id="pymysql"><a href="#pymysql" class="headerlink" title="pymysql"></a>pymysql</h5><ol><li><p>原生写法</p><pre><code> 导入 from pymysql import Connection 创建连接 conn = Connection(             host=地址, port=端口号,             user=用户名, password=密码,             database=数据库名, autocommit=True         ) 执行增删改 try:         with conn.cursor() as cursor:                 cursor.execute(sql语句, 参数)                 return cursor.lastrowid except Exception as e:     print(f&quot;发生错误: &#123;e&#125;&quot;)     return -1 查询 try:       with conn.cursor() as cursor:                 cursor.execute(sql, params)                 return cursor.fetchall() # 或者 fetchone() except Exception as e:             print(f&quot;发生错误: &#123;e&#125;&quot;) 事务 try:             conn.begin()             with conn.cursor() as cursor:                 count = 0                 for sql, params in sql_params:                     count += cursor.execute(sql, params)                 conn.commit()                 return count except Exception as e:             conn.rollback()             print(f&quot;发生错误: &#123;e&#125;&quot;)             return -1 关闭 conn.close()</code></pre></li></ol><ul><li><p>自定义MySqlHelper</p><pre><code>  导入  from common.sql_tools import MySqlHelper  创建对象  helper = MySqlHelper(数据库名)  执行增删改  结果 = helper.execute(SQL语句,参数)  执行查询  结果 = helper.fetch_one(SQL语句,参数)  结果 = helper.fetch_all(SQL语句,参数)  执行事务  结果 = helper.execute_transaction(        (SQL语句,元组类型的参数),        (SQL语句,元组类型的参数)  )  关闭  helper.close()</code></pre></li><li><p>存储过程</p><pre><code>  创建  delimiter $$  create procedure 存储过程名(参数名 数据类型)  begin      语句组      select 结果;  end$$  调用  call 存储过程名(参数);</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h4 id=&quot;语法速查手册&quot;&gt;&lt;a href=&quot;#语法速查手册&quot; class=&quot;headerlink&quot; title=&quot;语法速查手册&quot;&gt;&lt;/a&gt;语法速查手册&lt;/h4&gt;&lt;h5 id=&quot;数据基本运算&quot;&gt;&lt;a href=&quot;#数据基本运算&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="AID学习笔记" scheme="https://levxn7.github.io/categories/AID%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="python" scheme="https://levxn7.github.io/tags/python/"/>
    
    <category term="语言学习" scheme="https://levxn7.github.io/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue源码复习(虚拟DOM)</title>
    <link href="https://levxn7.github.io/2022/05/02/vueymfx/vueymfx3/"/>
    <id>https://levxn7.github.io/2022/05/02/vueymfx/vueymfx3/</id>
    <published>2022-05-02T04:58:56.000Z</published>
    <updated>2024-03-20T15:18:57.748Z</updated>
    
    <content type="html"><![CDATA[<h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><p>vue中的虚拟dom的实现借鉴了snabdom这个虚拟dom库，如模块机制、钩子函数、diff算法，在此基础上额外添加了指令和组件等。虚拟dom是使用JS对象来描述真实dom，虚拟dom就是js对象。</p><p>为什么要使用虚拟dom：<br>避免直接操作真实dom，提高开发效率。可以作为一个中间层来跨平台。在复杂试图的情况下可以提高渲染性能，简单视图的情况下可能会增加开销。</p><p>在v-for的时候可以给每个节点增加key属性，key只能是原始值，不能是对象。因新老节点对比顺序不同，设置key会比不设置key的dom操作少很多。</p><h5 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h5><p><strong>虚拟dom创建的整体过程</strong><br>这个过程是接着vue的首次渲染过程来讲的，在updateComponent()中我们调用了render()函数和_update()函数。</p><p>在render中我们调用了用户传入的render函数或者是模板编译成的render函数，如果是用户传入的render函数的话，就调用vm.$createElement()方法，如果是模板编译成的render的话，调用的是vm._c()方法。不管vm.$createElement()还是vm._c(),他最后都会执行createElement方法。在createElement中处理了参数的差异，最终调用了_createElement()方法。在这个方法中创建了vnode对象，最终返回vnode。<br><img src="/2022/05/02/vueymfx/vueymfx3/D36D403B-B738-4A3A-A620-8EA128A49D54.png" alt="0295fbf3548dfa0579eecb29a23f05b2"></p><p>在update函数是负责把虚拟dom渲染成真实dom，在update里边会调用__patch__方法。如果是首次执行，patch的第一个参数是$el，也就是一个真实dom。如果是数据更新那就传入两个vnode，第一个prevVnode也就是上次保存下来的vnode。<br>patch函数是在runtime下的index.js中初始化的，他是给vue原型上挂载了__patch__这个方法，所有的vue实例都可以访问到，他其实就是runtime下的patch.js模块中导出的patch函数。在这个函数中设置了moudles和nodeOps两个对象，moudles中存储的是一些模块，nodeOps是用来操作dom的。设置好后会把这两个对象传递给createPatchFunction()函数，这个函数最终返回的是我们需要的patch函数。<br><img src="/2022/05/02/vueymfx/vueymfx3/D3317FFA-E67E-47BD-B87B-FB3A7070CF97.png" alt="6cb8377bdd89d8d0cfa09019b227d13f"></p><p>patch是vdom/patch.js中的createPatchFunction()返回的函数，在createPatchFunction中首先做了初始化的事情，她里面有很多的辅助函数，特别定义了cbs对象。在cbs对象中存储了所有模块中定义的那些钩子函数，这些钩子函数是为了处理节点的属性、事件、样式等。<br>在patch中还会判断第一个参数是不是真实dom，如果是真实dom的话说明是首次加载。这时会把真实dom转化为vnode，然后去调用createElm，把newVnode转换为真实dom，挂载到dom树上来。如果是数据更新的时候，就要通过sameVnode函数判断新旧vnode是否是相同的节点。如果不是相同节点的话，就执行其中的patchVnode，也就是diff算法。patch执行结束之后，删除旧节点。<br><img src="/2022/05/02/vueymfx/vueymfx3/96EE883B-C1B1-431A-8A07-163D7BC713E4.png" alt="c193a5cb93662967e61d92f5bd7f38cb"></p><p>createElm函数是用来把虚拟节点转换为真实dom，并挂载到dom树上。他也会把虚拟节点的子节点children，转换为真实节点，挂载到dom树上。<br>patchVnode是用来对比新旧vnode，以及新旧vnode的子节点，然后更新他们的差异。如果新旧vnode都有子节点，并且子节点不同的话，还会调用updateChildren去对比子节点的差异。<br>updateChildren会去处理新旧子节点，在处理的过程中优化了这个操作。他会先去把新旧节点的头和尾取出来进行比较，总共有4种比较方式。在比较的过程中，如果我们的节点是sameVnode，那就会调用patchVnode打补丁。如果这4种比较的方式都不满足的话，就会在老节点的子节点种查找newStartVnode，也就是新的开始节点在老的节点中是否存在，并进行处理。如果新节点比老节点多，会把新增的节点插入到dom中，如果老节点比较多，就把多余的老节点删除。<br><img src="/2022/05/02/vueymfx/vueymfx3/5DA71656-C1C3-4A04-B539-B1287BE68A6B.png" alt="cfa4cb62a5b1b3adb9e1cffdcccf6a08"></p><h4 id="模板编译和组件化"><a href="#模板编译和组件化" class="headerlink" title="模板编译和组件化"></a>模板编译和组件化</h4><p>模板编译的作用，就是把模板中的内容（html）转换为渲染函数。.vue文件是webpack通过vue-loader在构建的过程中转换成render函数的。</p><p>compileToFunctions()是模板编译的入口函数，他的内部先从缓存加载编译好的render渲染函数，如果缓存中没有，就调用compile开始编译。<br>在compile中先合并选项（options），然后调用baseCompile编译模板。compile的核心是合并选项，真正的处理是在baseCompile中完成的。<br>把模板和合并好的选项传递给baseCompile，他做了三件事情。一、使用parse函数把template模板转换成AST tree（抽象语法树）。二、使用optimze函数对AST tree进行优化：标记所有AST tree中的sub trees（静态根节点），sub trees不需要每次被重绘，patch的过程会跳过sub trees。三、将优化过的AST tree生成字符串形式的js代码。<br>当compile执行完毕以后，会回到入口函数compileToFunctions中，他继续把字符串形式的代码转换为函数的形式，通过执行createFunction，当render和staticRenderFuns创建完毕，最终他们都会被挂载到vue实例中的options选项对应的属性上。<br>注：<br>模板编译的过程中，会标记静态根节点，对静态根节点进行优化处理，重新渲染的时候不需要渲染静态根节点，因为他们不会发生改变。另外在模板中不要多写无意义的空格和换行，生成AST对象时会保留这些空格和换行，他们都会被存储到内存中。<br><img src="/2022/05/02/vueymfx/vueymfx3/967222E7-DF80-458C-AF98-6F5A4CF032BD.png" alt="a28ffcef5fccd93a5778d8f185793c20"></p><h5 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h5><p>一个vue组件就是一个拥有预定义选项的一个vue实例。<br>一个组件可以组成页面上一个功能完备的区域，组件可以包含脚本、样式、模板</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;虚拟DOM&quot;&gt;&lt;a href=&quot;#虚拟DOM&quot; class=&quot;headerlink&quot; title=&quot;虚拟DOM&quot;&gt;&lt;/a&gt;虚拟DOM&lt;/h4&gt;&lt;p&gt;vue中的虚拟dom的实现借鉴了snabdom这个虚拟dom库，如模块机制、钩子函数、diff算法，在此基础上额外添</summary>
      
    
    
    
    <category term="高级前端笔记" scheme="https://levxn7.github.io/categories/%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="vue" scheme="https://levxn7.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue源码复习(数据响应式)</title>
    <link href="https://levxn7.github.io/2022/04/07/vueymfx/vueymfx2/"/>
    <id>https://levxn7.github.io/2022/04/07/vueymfx/vueymfx2/</id>
    <published>2022-04-07T04:58:56.000Z</published>
    <updated>2024-03-20T15:18:57.748Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据响应式原理"><a href="#数据响应式原理" class="headerlink" title="数据响应式原理"></a>数据响应式原理</h4><p>响应式的意思是，当数据发生改变，视图会跟着改变，无需我们操作dom，响应式处理的入口是instance\init.js</p><p>响应式是从vue实例的_init()方法开始的，在_init()方法中先调用initState()方法初始化vue实例的状态，在其中调用了initData()，这个方法是把data属性注入到vue实例上，并且调用observe()把data对象转换成响应式的对象，observe()就是响应式的入口。</p><p>observe(value)接受一个参数，这个参数就是响应式要处理的对象，observe()在src/core/observer/index.js中，先判断value是否是对象，如果不是对象就直接返回。</p><p>然后判断value对象是否有__ob__属性，,如果有就说明这个对象已经做过响应式处理，也直接返回。如果没有，就为这个对象创建observer对象，然后把这个observer对象返回。<br><img src="/2022/04/07/vueymfx/vueymfx2/1646185395364.jpg" alt="3828aebf462cc43da6dc120bc960e503"></p><p>Observe类会给value对象定义一个不可枚举的__ob__属性，并把当前的observer对象记录到枚举__ob__里面来，然后进行数组和对象的响应式处理。<br><img src="/2022/04/07/vueymfx/vueymfx2/56737F2A-8FF5-475B-AC0F-BFA25015690F.png" alt="3828aebf462cc43da6dc120bc960e503"></p><p>数组的处理就是设置数组那几个特殊的方法，这些方法会改变数组，所以当这些方法被调用的时候，我们要发送通知，找到数组对应的__ob__，也就是observer对象，再找到observer对象中的dep方法调用，调用dep当中的notify方法。处理完这些方法后，遍历成员，对每一个成员调用observe，如果这个成员是对象的话，也会被转换为响应式的对象。 </p><p>对象的处理会调用walk方法，遍历对象所有属性，给每个属性调用defineReactive方法。<br>defineReactive会给每个属性创建dep对象，让dep去收集依赖，如果当前属性的值是对象，就调用observe，要把这个对象变成响应式。</p><p>defineReactive的核心就是定义getter和setter。<br>定义getter为每一个属性收集依赖，包括对象的子对象。<br>定义setter保存新值，如果新值是对象，就调用observe也转换成响应式，发送通知，就是调用dep.notify方法。<br><img src="/2022/04/07/vueymfx/vueymfx2/3A65CD6C-0740-42ED-9185-19234C239D9E.png" alt="266f9d19cdafcf66b22a546c361fd9ae"></p><p>依赖收集：首先执行watcher对象中的get方法，在get中调用pushTarget，在pushTarget中会把watcher对象记录到dep.target属性中。<br>在访问data中的成员的时候收集依赖，在访问值时就会触发defineReactive中的getter收集依赖，把属性对应的watcher添加到dep的subs数组中，也就是为属性收集依赖，如果属性的值是个对象，就创建一个childOb为这个子对象收集依赖，目的是子对象添加和删除成员时发送通知<br><img src="/2022/04/07/vueymfx/vueymfx2/E9D9E42D-6D38-4EDF-AE3B-69D7B782008A.png" alt="2d155fa9c0aa9b61d97d6488e0b84e85"></p><p>watcher：当数据发生变化的时候通过dep.notify发送通知，他会调用watcher的update方法，在update方法中会调用queueWatcher函数，来判断watcher是否被处理了，如果没有就添加到queue队列，并调用flushSchedulerQueue刷新队列</p><p>flushSchedulerQueue会触发beforeUpdata钩子函数，然后调用watcher.run()函数，在其中调用get()–&gt;getter()–&gt;updateComponent</p><p>调用run方法之后，就可以在页面上看到最新的数据了</p><p>然后就会清空上一次的依赖，重置watcher的状态，然后触发actived钩子函数，然后触发updated钩子函数<br><img src="/2022/04/07/vueymfx/vueymfx2/6733F301-2725-441A-AD21-4C54011B6FE2.png" alt="2b9b14348506a056db1f6d3d2846069e"></p><h5 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h5><p>nexTick是在dom行程后获取内容，本身是一个微任务，运行环境不支持时降级为宏任务。数据更新到dom上之后，才会去执行nextTick中的回调函数。</p><p>nextTick静态方法是在global-api的index.js中被定义的，实例方法在instance下面的index.js中，在renderMixin()这个函数中，定义了nextTick。nextTick的核心，其实就是timerFunc()的处理。</p><p>在timerFunc()源码中我们可以得知：<br>如果支持 Promise 就用 Promise。如果不支持Promise<br>就用MutationObserver，MutationObserver 它会在指定的DOM发生变化时被调用。<br>如果不支持 MutationObserver 的话就用 setImmediate，但是这个特性只有最新版IE和node支持。<br>如果这些都不支持的话就用setTimeout。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;数据响应式原理&quot;&gt;&lt;a href=&quot;#数据响应式原理&quot; class=&quot;headerlink&quot; title=&quot;数据响应式原理&quot;&gt;&lt;/a&gt;数据响应式原理&lt;/h4&gt;&lt;p&gt;响应式的意思是，当数据发生改变，视图会跟着改变，无需我们操作dom，响应式处理的入口是instanc</summary>
      
    
    
    
    <category term="高级前端笔记" scheme="https://levxn7.github.io/categories/%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="vue" scheme="https://levxn7.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue源码复习(首次渲染)</title>
    <link href="https://levxn7.github.io/2022/03/01/vueymfx/vueymfx/"/>
    <id>https://levxn7.github.io/2022/03/01/vueymfx/vueymfx/</id>
    <published>2022-03-01T04:58:56.000Z</published>
    <updated>2024-03-20T15:18:57.748Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h4><p>第一种： 创建实例时，传入el和data选项，vue内部会把data数据传到el所对应的模板中，并把模板渲染到浏览器<br>第二种： render方法接受一个h函数，h函数的作用是创建一个虚拟dom，render函数把h创建的虚拟dom返回。$mount的作用是把虚拟dom转化为真实dom，渲染到浏览器。<br><img src="/2022/03/01/vueymfx/vueymfx/E8F7BCFC-02FA-4B11-A113-16A25255BC33.png" alt="bd52306c3a68ee0dfc0386b158fc99c3"></p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>vue生命周期分为8个阶段，即分别是创建前<br>beforeCreate、创建后created、载入前beforeMount、载入后mounted、更新前beforeUpdate、更新后updated、销毁前beforeDestroy、销毁后destroyed。<br><img src="/2022/03/01/vueymfx/vueymfx/4AE06B6F-6BA5-4829-9066-00019FEE3763.png" alt="2765e8b954d15199b8ca4966defe94d2"></p><h4 id="语法和概念"><a href="#语法和概念" class="headerlink" title="语法和概念"></a>语法和概念</h4><p>差值表达式<br>指令<br>计算属性和侦听器(computed和watch)<br>    - 要大量逻辑运算的时候，计算属性的结果会被缓存，下次再需要的时候会从缓存拿结果。如果需要监听数据变化并进行复杂操作，使用监听器。<br>class和style绑定<br>条件渲染(v-if)和列表渲染(v-for)<br>表单输入绑定<br>组件（可复用的vue实例）<br>插槽（slot，组件更灵活）<br>插件<br>混入（mixin，让组件重用的一种方式）<br>深入响应式原理<br>不同构件版本的vue</p><h3 id="vue源码剖析"><a href="#vue源码剖析" class="headerlink" title="vue源码剖析"></a>vue源码剖析</h3><p>vue2中引入了flow静态类型检查器，vue3是typescript</p><p>vue的不同构建版本<br><img src="/2022/03/01/vueymfx/vueymfx/74762267-B729-48BF-B7BA-6277CE72462B.png" alt="58196a21b3ba7ace05428db39ae4c4b8"></p><p>vue的静态成员和实例成员初始化过程在目录中源码的部分是src文件夹：<br>compiler（编译器）把模板转化为render函数<br>core（vue的核心）</p><ul><li>components中定义了vue自带的keep-alive组件</li><li>global-api：initGlobalAPI方法初始化vue的静态方法</li><li>instance：.创建了vue构造函数2.初始化vue实例部分</li><li>observer响应式部分</li><li>vdom虚拟dom</li></ul><p>platform 平台相关的代码<br>server服务端渲染相关<br>sfc单文件组件<br>-——————</p><h4 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h4><p>从script文件夹下的config文件中查找builds对象，其对象下写了各个构建版本的部分信息：包括入口，出口，模块化方式等，所以得知入口文件在src/platform/web下<br>打包的过程中，如果没有render，就会把template转化为render函数。如果传递了render，就会调用mount方法渲染dom</p><h4 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h4><p>注册指令：<br>所有的指令都保存在Vue.options.directives里，所有的组件都保存在Vue.options.components里。都是全局内可以访问的。</p><p>给Vue挂载__patch__函数，用来把虚拟dom转化为真实dom。<br>给Vue注册一个$mount方法，用来渲染dom<br>23<br><strong>core/instance</strong><br>初始化构造方法：指向core/instance<br>    + initMixin() 注册_init()方法来初始化vm<br>    + stateMixin() 给原型挂载$data $props属性 $set $delete $watch方法<br>    + eventsMixin() 利用发布订阅模式注册事件相关方法：$on $once $off $emit<br>    + lifecycleMixin() 生命周期相关的混入方法 _update $forceUpdate $destory<br>    + renderMixin() $nextTick() _render(调用的用户传入的render）</p><p><strong>core/global-api</strong><br>初始化静态成员： 指向core/global-api<br>    + 初始化config对象，并挂载方法nextTick set delete<br>    + 设置响应式对象<br>    + 初始化vue.options对象并扩展，用来存储全局的components，directives，filters<br>    + 设置keep-alive全局组件<br>    + 注册Vue.use()来注册插件<br>    + 注册Vue.mixin()来实现混入<br>    + 注册Vue.extend()基于传入的options返回一个组件的构造函数<br>    + 注册Vue.directive() Vue.component() Vue.filter()</p><h4 id="首次渲染过程"><a href="#首次渲染过程" class="headerlink" title="首次渲染过程"></a>首次渲染过程</h4><p>在首次渲染之前，先进行vue的初始化，初始化实例成员，静态成员。当初始化结束后调用vue的构造函数，在构造函数中调用了_init()方法，这个方法相当于整个文件的入口，方法中调用了$mount()</p><p>第一个$mount（entry-runtime-with-compiler.js中的）是入口文件$mount，通过compileToFunctions()帮我们把模板编译成render()渲染函数，存入options.render中</p><p>第二个$mount（runtime\index.js中的）中重新获取$el并调用mountComponent()，先判断是否是render选项，如果没有，但是传入的是模板并且是运行版本时，版本会被警告不支持编译器</p><p>触发beforemount，定义updateComponent</p><p>创建watcher对象，传入了updateComponent函数，创建完watcher会调用一个get方法，在get中调updateComponent，updateComponent中会调用render和update两个方法</p><p>render的作用是创建虚拟dom，最终调用的用户传入的或者模板编译的render返回vnode，调用vm._update，在其中调用__patch__ 这个方法将虚拟dom转换成真实dom并挂载到页面上来，真实dom渲染到$el中</p><p>触发mounted 挂载结束 返回vue实例</p><p><img src="/2022/03/01/vueymfx/vueymfx/34E5255B-F8F3-4424-ABFC-ADCFF160486E.png" alt="62954824e5d7d1645e674798997297e6"><br><img src="/2022/03/01/vueymfx/vueymfx/A90B15BB-0364-4B29-BA2A-2BB6D3D4A595.png" alt="7fee6d20c4962409267eb71a325cfdfa"><br><img src="/2022/03/01/vueymfx/vueymfx/0625729F-EBC8-4926-A8D2-FED25F91B09E.png" alt="fc61d97566402dd356dd3a8d25902f98"></p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;基础结构&quot;&gt;&lt;a href=&quot;#基础结构&quot; class=&quot;headerlink&quot; title=&quot;基础结构&quot;&gt;&lt;/a&gt;基础结构&lt;/h4&gt;&lt;p&gt;第一种： 创建实例时，传入el和data选项，vue内部会把data数据传到el所对应的模板中，并把模板渲染到浏览器&lt;br&gt;</summary>
      
    
    
    
    <category term="高级前端笔记" scheme="https://levxn7.github.io/categories/%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="vue" scheme="https://levxn7.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>浏览器性能优化(渲染优化)</title>
    <link href="https://levxn7.github.io/2022/02/24/xnyh/xnyh4/"/>
    <id>https://levxn7.github.io/2022/02/24/xnyh/xnyh4/</id>
    <published>2022-02-24T02:52:05.000Z</published>
    <updated>2024-03-20T15:18:57.748Z</updated>
    
    <content type="html"><![CDATA[<h4 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h4><p>浏览器从获取HTML到最终在屏幕上显示内容需要完成以下步骤:<br>1.处理HTML标记并构建DOM树。<br>2.处理CSS标记并构建CSSOM树。<br>3.将DOM与CSSOM合并成一个render tree。<br>4.根据渲染树来布局，以计算每个节点的几何信息。<br>5.将各个节点绘制到屏幕上。</p><p>JavaScript处理:前端项目中经常会需要响应用户操作，通过JavaScript对数据集进行计算、操作DOM元素，并展示动画等视觉效果。当然对于动画的实现，除了JavaScript，也可以考虑使用如CSS Animations、Transitions 等技术。<br>计算样式:在解析CSS文件后，浏览器需要根据各种选择器去匹配所要应用CSS规则的元素节点，然后计算出每个元素的最终样式。<br>页面布局:指的是浏览器在计算完成样式后，会对每个元素尺寸大小和屏幕位置进行计算。由于每个元素都可能会受到其他元素的影响，并且位于DOM树形结构中的子节点元素，总会受到父级元素修改的影响，所以页面布局的计算会经常发生。<br>绘制:在页面布局确定后，接下来便可以绘制元素的可视内容，包括颜色、边框、阴影及文本和图像。<br>合成:通常由于页面中的不同部分可能被绘制在多个图层上，所以在绘制完成后需要将多个图层按照正确的顺序在屏幕上合成，以便最终正确地渲染出来。</p><h5 id="优化dom"><a href="#优化dom" class="headerlink" title="优化dom"></a>优化dom</h5><p>html文件的尺寸应该尽可能小：总结起来有三种方式可以优化HTML:缩小文件的尺寸(Minify) 、使用gzip压缩(Compress)、使用缓存(HTTPCache) 。</p><h5 id="优化cssom"><a href="#优化cssom" class="headerlink" title="优化cssom"></a>优化cssom</h5><p>css的加载会阻塞网络渲染，避免在css种使用@import</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞渲染</span></span><br><span class="line">&lt;link href=<span class="string">&quot;style.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line"><span class="comment">//非阻塞(打印的样式）</span></span><br><span class="line">&lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;</span><br><span class="line">//非阻塞（媒体查询）(可变阻塞）</span><br><span class="line">&lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 40em)&quot;&gt;</span><br><span class="line">&lt;link href=&quot; portrait.css&quot; rel=&quot;stylesheet&quot; media=&quot;orientation : portrait&quot;&gt;</span><br></pre></td></tr></table></figure><h5 id="优化js"><a href="#优化js" class="headerlink" title="优化js"></a>优化js</h5><p>异步加载JavaScript<br>避免同步请求<br>延迟解析JavaScript<br>避免运行时间长的JavaScript</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*具有defer特性的脚本不会阻塞页面。</span></span><br><span class="line"><span class="comment">具有defer特性的脚本总是要等到DOM</span></span><br><span class="line"><span class="comment">解析完毕，但在DOMContentLoaded事</span></span><br><span class="line"><span class="comment">件之前执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//如果有多个，会异步并行加载，按顺序执行</span></span><br><span class="line">&lt;script defer src=<span class="string">&quot;index.js&quot;</span>&gt;&lt;/ script&gt;</span><br><span class="line"><span class="comment">//如果有多个，会异步并行加载，按时间长短执行</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span>&lt;/ script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script放在最底部  可以head里这样利用空闲时间预加载</span></span><br><span class="line">&lt;link rel=<span class="string">&quot;preload&quot;</span> href=<span class="string">&quot;index.js&quot;</span>&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;index2.js&quot;&gt;</span><br><span class="line">// script放在最底部  可以预加载可能用到的非当前页面的资源</span><br><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;index.js&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="js执行优化"><a href="#js执行优化" class="headerlink" title="js执行优化"></a>js执行优化</h5><p>实现动画效果：能用css就不用js。使用js时每秒60帧最好<br>实践经验告诉我们，使用定时器实现的动画会在世些低端机器上出现抖动或者卡顿的现象，这主要是因为浏览器无法确定定时器的回调函数的执行时机。以 setInterval为例，其创建后回调任务会被放入异步队列，只有当主线程上的任务执行完成后，浏览器才会去检查队列中是否有等待需要执行的任务，如果有就从任务队列中取出执行，这样会使任务的实际执行时机比所设定的延迟时间要晚一些。</p><p>其次屏幕分辨率和尺寸也会影响刷新频率，不同设备的屏幕绘制频率可能会有所不同，而setInterval只能设置某个固定的时间间隔，这个间隔时间不一定与所有屏幕的刷新时间同步，那么导致动画出现随机丢帧也在所难免。</p><p>为了避免这种动画实现方案中因丢帧而造成的卡顿现象，我们推荐使用<br>window. requestAnimationFrame（兼容到ie10）方法。与setInterval方法相比，其最大的优势是将回调函数的执行时机交由系统来决定，即如果屏幕刷新频率是60Hz，则它的回调函数大约会每16.7ms 执行一次，如果屏幕的刷新频率是75Hz，则它回调函数大约会每13.3ms执行一次，就是说requestAnimationFrame方法的执行时机会与系统的刷新频率同步。<br>这样就能保证回调函数在屏幕的每次刷新间隔中只被执行一次，从而避免因随机丢帧而造成的卡顿现象。</p><h5 id="恰当的使用web-worker"><a href="#恰当的使用web-worker" class="headerlink" title="恰当的使用web worker"></a>恰当的使用web worker</h5><p>众所周知JavaScript是单线程执行的，为此可将一些纯计算的工作迁移到 Web Worker上处理，它为JavaScript的执行提供了多线程环境，主线程通过创建出 Worker子线程，可以分担一部分自己的任务执行压力。在Worker子线程上执行的任务不会干扰主线程，待其上的任务执行完成后，会把结果返回给主线程，,这样的好处是让主线程可以更专注地处理UI交互，保证页面的使用体验流程。需要注意的是，Worker子线程一旦创建成功就会始终执行，不会被主线程上的事件所打断，这就意味着Worker 会比较耗费资源，所以不应当过度使用，一旦任务执行完毕就应及时关闭。除此之外，在使用中还有以下几点应当注意.</p><p>DOM限制:Worker无法读取主线程所处理网页的DOM对象，也就无法使用document、window和parent等对象，只能访问navigator和location对象。<br>文件读取限制: Worker子线程无法访问本地文件系统，这就要求所加载的脚本来自网络。<br>通信限制:主线程和Worker子线程不在同一个上下文内，所以它们无法直接进行通信，只能通过消息来完成。<br>脚本执行限制:虽然 Worker可以通过XMLHTTPRequest对象发起ajax请求，但不能使用alert()方法和confirm()方法在页面弹出提示。<br>同源限制: Worker子线程执行的代码文件需要与主线程的代码文件同源。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker( <span class="string">&#x27;worker.js &#x27;</span>)</span><br></pre></td></tr></table></figure><p>在子线程处理完相关任务后，需要及时关闭Worker子线程以节省系统资源，关闭的方式有两种:<br>·在主线程中通过调用worker.terminate()方法来关闭;<br>·在子线程中通过调用自身全局对象中的self.close()方法来关闭。</p><h5 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1:函数//参数2:时间</span></span><br><span class="line"><span class="comment">//返回值:被防抖的函数</span></span><br><span class="line"><span class="built_in">document</span>.onscroll = _.debounce(<span class="function"><span class="keyword">function</span> (<span class="params"> &#123; <span class="built_in">console</span>.log( <span class="string">&#x27;hello&#x27;</span>)</span></span></span><br><span class="line"><span class="params"><span class="function"> &#125;,<span class="number">500</span></span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">//参数1:函数//参数2:时间</span></span><br><span class="line"><span class="function">//返回值:被节流的函数</span></span><br><span class="line"><span class="function"><span class="title">document</span>.<span class="title">onscroll</span> = <span class="title">_</span>.<span class="title">throttle</span>(<span class="params"><span class="keyword">function</span> ( &#123; <span class="built_in">console</span>.log( <span class="string">&#x27;hello&#x27;</span>)</span></span></span><br><span class="line"><span class="params"><span class="function"> &#125;,<span class="number">500</span>)</span></span></span><br></pre></td></tr></table></figure><h5 id="计算样式优化"><a href="#计算样式优化" class="headerlink" title="计算样式优化"></a>计算样式优化</h5><p>减少要计算样式的元素数量<br>首先我们需要知道与计算样式相关的一条重要机制: csS引擎在查找样式表时，对每条规则的匹配顺序是从右向左的，这与我们通常从左向右的书写习惯相反。<br>(1)使用类选择器替代标签选择器，<br>(2）避免使用通配符做选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种操作在标签规模较小的demo 项目中，几乎看不出有任何性能差异。但对实际的工程项目来说，使用通配符就意味着在计算样式时，浏览器需要去遍历页面中的每一个元素，这样的性能开销很大，应当避免使用。<br>(3)降低选择器的复杂度<br>(4)使用BEM规范: BEM是一种CSS的书写规范，它的名称是由三个单词的首字母组成的，分别是块(Block) 、元素(Element)和修饰符(Modifier)。理论上它希望每行CSS代码只有一个选择器，这就是为了降低选择器的复杂性，对选择器的命名要求通过以下三个符号的组合来实现。<br>中画线(-)︰仅作为连字符使用，表示某个块或子元素的多个单词之间的连接符。<br>单下画线(_)︰作为描述一个块或其子元素的一种状态。<br>双下画线(__)︰作为连接块与块的子元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//常规写法</span><br><span class="line"><span class="selector-class">.mylist</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.mylist</span> <span class="selector-class">.item</span> &#123;&#125;</span><br><span class="line">//BEM写法</span><br><span class="line"><span class="selector-class">.mylist</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.mylist__item</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="页面布局与重绘"><a href="#页面布局与重绘" class="headerlink" title="页面布局与重绘"></a>页面布局与重绘</h5><p>页面布局也叫作重排和回流，指的是浏览器对页面元素的几何属性进行计算并将最终结果绘制出来的过程。凡是元素的宽高尺寸、在页面中的位置及隐藏或显示等信息发生改变时，都会触发页面的重新布局。<br>如果仅仅修改了DOM元素的样式，而未影响其几何属性时，则浏览器会跳过页面布局的计算环节，直接进入重绘阶段。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>尽量避免对样式的频繁改动<br>尽量使用更改类名对元素样式进行修改<br>缓存对敏感属性值的计算<br>使用requestAnimationFrame方法控制渲染帧（这里面的offsetHeight等是上一轮获取的 不用重新计算）</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;渲染优化&quot;&gt;&lt;a href=&quot;#渲染优化&quot; class=&quot;headerlink&quot; title=&quot;渲染优化&quot;&gt;&lt;/a&gt;渲染优化&lt;/h4&gt;&lt;p&gt;浏览器从获取HTML到最终在屏幕上显示内容需要完成以下步骤:&lt;br&gt;1.处理HTML标记并构建DOM树。&lt;br&gt;2.处理CS</summary>
      
    
    
    
    <category term="高级前端笔记" scheme="https://levxn7.github.io/categories/%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="性能优化" scheme="https://levxn7.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>浏览器性能优化(请求和响应优化)</title>
    <link href="https://levxn7.github.io/2022/02/16/xnyh/xnyh3/"/>
    <id>https://levxn7.github.io/2022/02/16/xnyh/xnyh3/</id>
    <published>2022-02-16T02:52:05.000Z</published>
    <updated>2024-03-20T15:18:57.748Z</updated>
    
    <content type="html"><![CDATA[<h4 id="请求和响应优化介绍"><a href="#请求和响应优化介绍" class="headerlink" title="请求和响应优化介绍"></a>请求和响应优化介绍</h4><p>目的:更快的内容到达时间。<br>核心思路:<br>1.更好的连接传输效率<br>2.更少的请求数量<br>3.更小的资源大小<br>4.合适的缓存策略</p><p>最佳实践:<br>1.减少DNS查找:每次主机名的解析都需要一次网络往返，从而增加了请求的延迟时间，同时还会阻塞后续的请求。<br>2．重用TCР 连接:尽可能的使用持久连接，以消除因TCP握手和慢启动导致的延迟。<br>3.减少HTTP重定向:HTTP冲定向需要额外的DNS查询、TCP握手等非常耗时，最佳的重定向次数为0。<br>4．压缩传输的资源:比如Gzip、图片压缩。<br>5．使用缓存:比如HTTP缓存、CDN缓存、Service Worker 缓存。<br>6.使用CDN(内容分发网络)︰把数据放在离用户地理位置更近的地方，可以明显减少每次TCP连接的网络延迟，增大吞吐星,<br>7．删除没有必要请求的资源。<br>8．在客户端缓存资源:缓存必要的应用资源，避免每次都重复请求相同的内容，例如多图片下载可以考虑使用缓存。<br>9.内容在传输前先压缩:传输数据之前应该先压缩应用资源，把要传输的字节减少到最小，在压缩的时候确保对每种不同的资源采用最好的压缩手段。<br>10．消除不必要的请求开销:减少请求的HTTP首部数据(比如HTTP COokie)<br>11.并行处理请求和响应:请求和响应的排队都会导致延迟，可以尝试并行的处理请求和响应(利用多个HTP11连接实现并行下载，在可能的情况下使用HTP管道计数)，<br>12．针对协议版本采取优化措施。升级到HTTP2.0。<br>拉勾教<br>13．根据需要采用服务端渲染方式。这种方式可以解决SPA应用首屏渲染慢的问题。<br>14．采用预渲染的方式快速加载静态页面。页面渲染的极致性能，比较适合静态页面。</p><h5 id="DNS解析优化"><a href="#DNS解析优化" class="headerlink" title="DNS解析优化"></a>DNS解析优化</h5><p>减少DNS的查找和请求次数<br>进行DNS预获取:DNS Prefetch 《link ref=”dns-prefetch” href=””&gt;</p><ul><li>不要预解析当前域</li><li>不要多页面重复预解析</li><li>禁用预解析<meta http-equiv="x-dns-prefetch-control" content="off"><br>延长dns缓存时间<br>使用cdn加速域名<br>搭建自己的dns服务</li></ul><h5 id="http长连接"><a href="#http长连接" class="headerlink" title="http长连接"></a>http长连接</h5><p>tcp连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。<br>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早的结束，这样Web页面的显示速度也就相应提高了。<br>缺点是响应是串行的 很容易队头堵塞<br>为了避免有两种办法，一个是减少请求数，一个是同时多开持久连接</p><h5 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h5><p>http2的前身是谷歌自行研发的SPDY协议<br><strong>二进制协议</strong><br><strong>多工</strong><br>HTTP/2复用TCР连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一—对应，这样就避免了”队头堵塞”。<br>并发请求 并发响应，这样双向的、实时的通信，就叫做多工(Multiplexing) 。<br><strong>数据流</strong><br>HTTP/2将每个请求或回应的所有数据包，称为一个数据流(stream)。每个数据流都有-个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。<br>数据流发送到一半的时候，客户端和服务器都可以发送信号(RST_STREAM帧)，取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP 连接。这就是说，HTTP/2可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。<br>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。<br><strong>头信息压缩</strong><br>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。<br>HTTP/2对这一点做了优化，引入了头信息压缩机制(header compression)。一方面，头信息使用gzip或compress压缩后再发送;另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。<br><strong>服务器推送</strong><br>HTTP/2允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送(serverpush) 。<br>你跟服务器要饭，他知道你缺碗还一块给了你一个碗</p><h5 id="压缩传输的数据资源"><a href="#压缩传输的数据资源" class="headerlink" title="压缩传输的数据资源"></a>压缩传输的数据资源</h5><p><strong>响应数据的压缩</strong><br>Gzip压缩文本 compression</p><p><strong>请求数据的压缩</strong><br>请求头：h1是不能压缩的，HTTP/2对这一点做了优化，引入了头信息压缩机制（header compression)<br>请求体：开发人员通过代码压缩（3种常见的压缩算法），后台也要提供解压<br>实际使用还需要匹配具体的服务器，比如nginx、Apache 等。</p><h5 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h5><p>缓存的原理是在首次请求后保存一份请求资源的响应副本，当用户再次发起相同请求后，如果判断缓存命中则拦截请求，将之前存储的响应副本返回给用户，从而避免重新向服务器发起资源请求。</p><p>缓存的技术种类有很多，比如代理缓存、浏览器缓存、网关缓存、负载均衡器及内容分发网络等，它们大致可以分为两类:共享缓存和私有缓存。共享缓存指的是缓存内容可被多个用户使用，如公司内部架设的Web代理;私有缓存指的是只能单独被用户使用的缓存，如浏览器缓存</p><p>HTTP缓存应该算是前端开发中最常接触的缓存机制之一，它又可细分为强制缓存与协商缓存，二者最大的区别在于判断缓存命中时，浏览器是否需要向服务器端进行询问以协商缓存的相关信息，进而判断是否需要就响应内容进行重新请求。下面就来具体看HTTP缓存的具体机制及缓存的决策策略。</p><p><strong>强制缓存</strong><br>其中与强制缓存相关的两个字段是expires（过期时间）和cache-control,</p><p>从上述强制缓存是否过期（expires）的判断机制中不难看出，这个方式存在一个很大的漏洞，即对本地时间戳过分依赖，如果客户端本地的时间与服务器端的时间不同步，或者对客户端时间进行主动修改，那么对于缓存过期的判断可能就无法和预期相符。</p><p>为了解决expires判断的局限性，从HTT1.1协议开始新增了cache-control字段来对expires的功能进行扩展和完善。</p><p>cache-control的配置</p><ul><li>no-cache（强制协商缓存） 和no-store（不缓存）</li><li>private（只能被浏览器缓存）和public（代理服务器也能缓存（如图像 css js等静态文件））也是cache-control的一组互斥属性值，它们用以明确响应资源是否可被代理服务器进行缓存。</li><li>max-age（缓存时间）属性值会比s-maxage（代理缓存时间（public时才生效））更常用，它表示服务器端告知客户端浏览器响应资源的过期时长。</li></ul><p>由此可见cache-control能作为expires的完全替代方案，并且拥有其所不具备的一些缓存控制特性，在项目实践中使用它就足够了，目前expires还存在的唯一理由是考虑可用性方面的向下兼容。</p><p><strong>协商缓存</strong><br>顾名思义，协商缓存就是在使用本地缓存之前，需要向服务器端发起一次GET请求，与之协商当前浏览器保存的本地缓存是否已经过期。所以需要向服务器发送一次GET请求，进行缓存有效性的协商，此次GET请求的请求头中需要包含一个ifmodified-since字段，其值正是上次响应头中last-modified的字段值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader( <span class="string">&#x27;last-modified &#x27;</span> , mtime.toUTCString())</span><br><span class="line">res.setHeader( <span class="string">&#x27;Cache-Control&#x27;</span> , <span class="string">&#x27;no-cache &quot; )</span></span><br></pre></td></tr></table></figure><p>首先它只是根据资源最后的修改时间戳进行判断的，虽然请求的文件资源进行了编辑，但内容并没有发生任何变化，时间戳也会更新，从而导致协商缓存时关于有效性的判断验证为失效，需要重新进行完整的资源请求。这无疑会造成网络带宽资源的浪费，以及延长用户获取到目标资源的时间。</p><p>其次标识文件资源修改的时间戳单位是秒，如果文件修改的速度非常快，假设在几百毫秒内完成，那么上述通过时间戳的方式来验证缓存的有效性，是无法识别出该次文件资源的更新的。</p><p>基于ETag(指纹）的协商缓存：<br>其内容主要是服务器为不同资源进行哈希运算所生成的一个字符串，该字符串类似于文件指纹，只要文件内容编码存在差异，对应的ETag标签值就会不同，因此可以使用ETag 对文件资源进行更精准的变化感知。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装etag包并加载</span></span><br><span class="line"><span class="keyword">const</span> data = fs.readFilesync( <span class="string">&#x27;./img/04.jpg )</span></span><br><span class="line"><span class="string">const etagcontent = etag(data)</span></span><br><span class="line"><span class="string">res.setHeader( &#x27;</span>etag <span class="string">&#x27;, etagContent)</span></span><br><span class="line"><span class="string">res.setHeader( &#x27;</span>Cache-Control<span class="string">&#x27; , &#x27;</span>no-cache <span class="string">&quot; )</span></span><br></pre></td></tr></table></figure><p>一方面服务器对于生成文件资源的ETag需要付出额外的计算开销，如果资源的尺寸较大，数量较多且修改比较频繁，那么生成ETag的过程就会影响服务器的性能。</p><p>另一方面ETag字段值的生成分为强验证和弱验证，强验证根据资源内容进行生成，能够保证每个字节都相向;弱验证则根据资源的部分属性值来生成，生成速度快但无法确保每个字节都相同，并且在服务器集群场景下，也会因为不够准确而降低协商缓存有效性验证的成功率，所以恰当的方式是根据具体的资源使用场景选择恰当的缓存校验方式。</p><p><strong>缓存的注意事项</strong><br>这里建议你能够根据该决策树的流程去设置缓存策略，这样不但会让指定的策略有很高的可行性，而且对于理解缓存过程中的各个知识点也非常有帮助。<br>我们可以将一个网站所需要的资源按照不同类型去拆解，为不同类型的资源制定相应的缓存策略，以下面的HTML文件资源为例:</p><p>首先HTML在这里属于包含其他文件的主文件，为保证当其内容发生修改时能及时更新，应当将其设置为协商缓存，即为cache-control 字段添加no-cache属性值;其次是图片文件，因为网站对图片的修改基本都是更换修改，同时考虑到图片文件的数量及大小可能对客户端缓存空间造成不小的开销，所以可采用强制缓存且过期时间不宜过长，故可设置cache-control字段值为max-age=86400。</p><p>接下来需要考虑的是样式表文件style.css，由于其属于文本文件，可能存在内容的不定期修改，又想使用强制缓存来提高重用效率，故可以考虑在样式表文件的命名中增加文件指纹或版本号（(比如添加文件指纹后的样式表文件名变为了style.51ad84f7.css)，这样当发生文件修改后，不同的文件便会有不同的文件指纹，即需要请求的文件 URL不同了，因此必然会发生对资源的重新请求。同时考虑到网络中浏览器与CDN等中间代理的缓存，其过期时间可适当延长到一年，即cache-control: max-age=31536000。</p><p>最后是JavaScript脚本文件，其可类似于样式表文件的设置;采取文件指纹和较长的过期时间，如果JavaScript中包含了用户的私人信息而不想让中间代理缓存，则可为cache-control添加private属性值。</p><p>从这个缓存策略的示例中我们可以看出，对不同资源进行组合使用强制缓存、协商缓存及文件指纹或版本号，可以做到一举多得:及时修改更新、较长缓存过期时间及控制所能进行缓存的位置。</p><p>拆分源码，分包加载<br>预估资源的缓存时效<br>控制中间代理的缓存<br>避免网址的冗余<br>规划缓存的层次结构</p><p><strong>cdn缓存</strong><br>CDN网络能够缓存网站资源来提升首次请求的响应速度，但并非能适用于网站所有资源类型，它往往仅被用来存放网站的静态资源文件。所谓静态资源，就是指不需要网站业务服务器参与计算即可得到的资源，包括第三方库的JavaScript脚本文件、样式表文件及图片等，这些文件的特点是访问频率高、承载流量大，但更新修改频次低，且不与业务有太多耦合。</p><p>如果是动态资源文件，比如依赖服务器端渲染得到的 HTML页面，它需要借助服务器端的数据进行计算才能得到，所以它就不适合放在CDN缓存服务器上。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;请求和响应优化介绍&quot;&gt;&lt;a href=&quot;#请求和响应优化介绍&quot; class=&quot;headerlink&quot; title=&quot;请求和响应优化介绍&quot;&gt;&lt;/a&gt;请求和响应优化介绍&lt;/h4&gt;&lt;p&gt;目的:更快的内容到达时间。&lt;br&gt;核心思路:&lt;br&gt;1.更好的连接传输效率&lt;br&gt;2</summary>
      
    
    
    
    <category term="高级前端笔记" scheme="https://levxn7.github.io/categories/%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="性能优化" scheme="https://levxn7.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>浏览器性能优化(概览)</title>
    <link href="https://levxn7.github.io/2022/02/13/xnyh/xnyh2/"/>
    <id>https://levxn7.github.io/2022/02/13/xnyh/xnyh2/</id>
    <published>2022-02-13T02:52:05.000Z</published>
    <updated>2024-03-20T15:18:57.748Z</updated>
    
    <content type="html"><![CDATA[<h5 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h5><p>性能优化不是一下子就能做好的，他是一个迭代优化的过程<br>根据性能指标测量</p><ul><li>浏览器自有的调试工具 DevTools</li><li>灯塔：网站整体质量评估，并给出优化建议</li></ul><p>性能优化</p><ul><li>从发出请求到收到响应的优化，比如DNS查询、HTTP长连接、HTTP 2、HTTP压缩、HTTP缓存等。</li><li>关键渲染路径优化，比如是否存在不必要的重绘和回流。</li><li>加载过程的优化，比如延迟加载，是否有不需要在首屏展示的非关键信息，占用了页面加载的时间。</li><li>资源优化，比如图片、视频等不同的格式类型会有不同的使用场景，在使用的过程中是召恰当。</li><li>构建优化，比如压缩合并、基于webpack 构建优化方案等。</li><li>等。。</li></ul><h5 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h5><p><a href="https://web.dev/">https://web.dev</a><br>在讨论性能的时候，精确的、可量化的指标很重要<br><strong>google提出的Rail：</strong><br>Response：&lt;100ms，如果没有结果也要给loding<br>Animation： 一帧大概10ms左右<br>ldle：执行时间尽量小于50ms，超过50ms的成为长任务<br>Load：首次加载应&lt;5s，后续加载建议在2s内完成</p><p>6种优化指标</p><ul><li>First Contentful Paint (FCP)首次绘制，应小于2s</li><li>Largest Contentful Paint (LCP)最大内容绘制，要考虑img video元素的封面图 等各大图片元素  应在2.5s以内</li><li>First Input Delay (FID)首次输入延迟，常见原因是浏览器正忙于解析和执行应用程序加载的大量计算的JavaScript。很多html元素需要等待主线程结束才能开始，应在100ms内</li><li>Time to lnteractive (TTI)网页到达完全可交互状态的时间点（是在最后一个长任务完成的时间，并在随后的5s内网络和主线是空闲的。3.8s内较好</li><li>Total Block Time (TBT) FCP和TTI的总时间 阻塞时间 300ms内</li><li>Cumulative Layout Shift (CLS)累计布局偏移0.1ms之内表现较好</li></ul><h5 id="web-vitals"><a href="#web-vitals" class="headerlink" title="web vitals"></a>web vitals</h5><p>goole制定的性能标准 LCP FID CLS<br>测量 Web Vitals<br>性能测试工具，比如Lighthouse<br>·使用web-vitals 库<br>使用浏览器插件Web Vitals(应用商店）</p><p>性能测试概述<br>性能检测作为性能优化过程中的一环，它的目的通常是给后续优化工作提供指导方向、参考基线及前后对比的依据。性能检测并不是一次性执行结束后就完成的工作，它会在检测、记录和改进的迭代过程中不断重复，来协助网站的性能优化不断接近期望的效果。</p><p>Lighthouse：是一个由Google开发并开源的 Web性能测试工具，用于改进网络应用的质量。您可以将其作为一个Chrome扩展程序运行，或从命令行运行。您为Lighthouse提供一个您要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。<br>webPageTest：是个网站<br>DevTools：shift+esc任务管理器  network</p><h5 id="前端页面的生命周期"><a href="#前端页面的生命周期" class="headerlink" title="前端页面的生命周期"></a>前端页面的生命周期</h5><p>建立http请求：DNS通道和通信链路的建立<br>DNS：先找缓存 拿到ip<br>网络模型：应用 传输 网络 数据链路层<br>tcp链接：三次握手 四次挥手<br>反向代理服务器</p><h4 id="请求和响应优化介绍"><a href="#请求和响应优化介绍" class="headerlink" title="请求和响应优化介绍"></a>请求和响应优化介绍</h4><p>目的:更快的内容到达时间。<br>核心思路:<br>1.更好的连接传输效率<br>2.更少的请求数量<br>3.更小的资源大小<br>4.合适的缓存策略</p><p>最佳实践:<br>1.减少DNS查找:每次主机名的解析都需要一次网络往返，从而增加了请求的延迟时间，同时还会阻塞后续的请求。<br>2．重用TCР 连接:尽可能的使用持久连接，以消除因TCP握手和慢启动导致的延迟。<br>3.减少HTTP重定向:HTTP冲定向需要额外的DNS查询、TCP握手等非常耗时，最佳的重定向次数为0。4．压缩传输的资源:比如Gzip、图片压缩。<br>5．使用缓存:比如HTTP缓存、CDN缓存、Service Worker 缓存。<br>6.使用CDN(内容分发网络)︰把数据放在离用户地理位置更近的地方，可以明显减少每次TCP连接的网络延迟，增大吞吐星,7．删除没有必要请求的资源。<br>8．在客户端缓存资源:缓存必要的应用资源，避免每次都重复请求相同的内容，例如多图片下载可以考虑使用缓存。<br>9.内容在传输前先压缩:传输数据之前应该先压缩应用资源，把要传输的字节减少到最小，在压缩的时候确保对每种不同的资源采用最好的压缩手段。10．消除不必要的请求开销:减少请求的HTTP首部数据(比如HTTP COokie)<br>11.并行处理请求和响应:请求和响应的排队都会导致延迟，可以尝试并行的处理请求和响应(利用多个HTP11连接实现并行下载，在可能的情况下使用HTP管道计数)，12．针对协议版本采取优化措施。升级到HTTP2.0。<br>拉勾教<br>13．根据需要采用服务端渲染方式。这种方式可以解决SPA应用首屏渲染慢的问题。<br>14．采用预渲染的方式快速加载静态页面。页面渲染的极致性能，比较适合静态页面。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;性能优化&quot;&gt;&lt;a href=&quot;#性能优化&quot; class=&quot;headerlink&quot; title=&quot;性能优化&quot;&gt;&lt;/a&gt;性能优化&lt;/h5&gt;&lt;p&gt;性能优化不是一下子就能做好的，他是一个迭代优化的过程&lt;br&gt;根据性能指标测量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器自有的调试工具</summary>
      
    
    
    
    <category term="高级前端笔记" scheme="https://levxn7.github.io/categories/%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="性能优化" scheme="https://levxn7.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>eslint</title>
    <link href="https://levxn7.github.io/2022/01/26/eslint/eslint/"/>
    <id>https://levxn7.github.io/2022/01/26/eslint/eslint/</id>
    <published>2022-01-26T04:14:11.000Z</published>
    <updated>2024-03-20T15:18:57.740Z</updated>
    
    <content type="html"><![CDATA[<h4 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h4><p>为什么要有规范化标准<br>·软件开发需要多人协同<br>·不同开发者具有不同的编码习惯和喜好。<br>·不同的喜好增加项目维护成本<br>·每个项目或者团队需要明确统一的标准</p><h4 id="eslint介绍"><a href="#eslint介绍" class="headerlink" title="eslint介绍"></a>eslint介绍</h4><p>Lint 是检验代码格式工具的一个统称，具体的工具有 Jslint 、 Eslint 等, 最为主流的 Jslint 工具监测JS代码质量<br>ESLint很容易统一开发者的编码风格, 可以帮助开发者提升编码能力, 是基于node开发的npm模块, 现代化项目集成eslint, 会让人不拘泥于格式错误, 更专注于开发<br>首先我们初始化一个package</p><blockquote><p>npm install eslint –save-dev //带有cli命令<br>npx eslint –version //运行</p></blockquote><p>–save-dev 会把 eslint 安装到 package.json 文件中的 devDependencies 属性中，意思是只是开发阶段用到这个包，上线时就不需要这个包了。</p><p><strong>快速上手</strong></p><blockquote><p>npx eslint –init //初始化一个配置文件, 如果要检查ts文件, 需要再问答时选择yes<br>npx eslint 路径 –fix //–fix会自动修复错误</p></blockquote><p>一个简单的配置文件.eslintrc.js, 该文件导出一个对象，对象包含属性 env、extends、parserOptions、globals、rules 五个属性, 在根目录下创建 src/index.js 文件, 引入 const lint = ‘eslint’ 来检验代码是否符合规范</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">env</span>: &#123;</span><br><span class="line">        <span class="attr">browser</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">es6</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">extends</span>: [</span><br><span class="line">        <span class="string">&#x27;standard&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">        <span class="attr">ecmaVersion</span>: <span class="number">2015</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">rules</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;no-alert&#x27;</span>: <span class="string">&quot;error&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">globals</span>: &#123;</span><br><span class="line">        <span class="string">&quot;jQuery&quot;</span>: <span class="string">&quot;readonly&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>env、parserOptions、plugins<br>我的程序里要用到 ES6 、React 、JSX 语法，这几个属性就是让 Eslint 能够检验到这些语法的</p><p>extends<br>值为 “eslint:recommended” 的 extends 属性启用一系列核心规则，这些规则是经过前人验证的最佳实践（所谓最佳实践，就是大家伙都觉得应该遵循的编码规范），想知道最佳实践具体有哪些编码规范，可以在 eslint规则表 中查看被标记为 √ 的规则项。<br>关于 “airbnb” 编码规范说两句，在接触到大多数开源项目中，大多数的作者都会使用 “airbnb” 编码规范而不是 官方的 “extends”: “eslint:recommended” 编码规范。<br>如果我们觉得 eslint-config-airbnb 规则配置中个别规则并不符合当前项目的要求，可以直接在 .eslintrc.js 配置 rules 属性，优先级高于共享规则 airbnb</p><p>ESLint 附带有大量的规则，修改规则应遵循如下要求：<br>“off” 或 0 - 关闭规则<br>“warn” 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)<br>“error” 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)<br>有的规则没有属性，只需控制是开启还是关闭，像这样：”eqeqeq”: “off”，有的规则有自己的属性，使用起来像这样：”quotes”: [“error”, “double”]，具体有没有自带属性，可查看 eslint规则表。</p><p>几个常用的规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;quotes&quot;</span>: [<span class="number">1</span>, <span class="string">&quot;single&quot;</span>],            # 单引号</span><br><span class="line"><span class="string">&quot;quote-props&quot;</span>:[<span class="number">2</span>, <span class="string">&quot;as-needed&quot;</span>],     # 双引号自动变单引号</span><br><span class="line"><span class="string">&quot;semi&quot;</span>: [<span class="number">2</span>, <span class="string">&quot;never&quot;</span>],               # 一行结尾不要写分号</span><br><span class="line"><span class="string">&quot;comma-dangle&quot;</span>: [<span class="number">1</span>,<span class="string">&quot;always-multiline&quot;</span>]  # 对象或数组多行写法时，最后一个值加逗号</span><br></pre></td></tr></table></figure><p><strong>配置注释</strong><br>注释规则参考: <a href="http://eslint.cn/docs/user-guide/configuring#configuring-rules">http://eslint.cn/docs/user-guide/configuring#configuring-rules</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">&quot;$&#123;name&#125; is a coder&quot;</span> <span class="comment">// eslint-disable-line no-template-curly-in-string</span></span><br></pre></td></tr></table></figure><p><strong>结合自动化gulp</strong><br>集成之后，ESLint 一定会工作,  这样做会与项目统一，管理更加方便</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.pipe(plugins.eslint())</span><br><span class="line">.pipe(plugins.eslint.format())</span><br><span class="line">.pipe(plugins.eslint.failAfterErrorO)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结合webpack</strong><br>前置工作<br>·安装对应模块<br>·安装eslint模块<br>·安装eslint-loader模块<br>·初始化.eslintrc.js配置文件</p><p>关于react引入却没使用的问题 npm install eslint-plugin-react</p><p><strong>stylelint的认识</strong><br>使用方法基本可以参考eslint, 二者几乎是一样的</p><blockquote><p>npm install stylelint -D //安装<br>npx stylelint ./index.css //运行</p></blockquote><p>配置文件为.stylelintsrc.js, 需在文件中继承 standard (安装 npm install stylelint-config-standard)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    <span class="attr">extends</span>: <span class="string">&quot;stylelint-config-standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查sass需要安装 npm install stylelint-config-sass-guidelines -D, 然后继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    <span class="attr">extends</span>: [</span><br><span class="line">        <span class="string">&quot;stylelint-config-standard&quot;</span></span><br><span class="line">        <span class="string">&quot;stylelint-config-sass-guidelines&quot;</span></span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>prettier的使用</strong></p><blockquote><p>npm install prettier -D //安装<br>npx prettier . –write</p></blockquote><p>不要完全依赖工具来格式化, 自己要写出良好的代码</p><p><strong>git hooks</strong><br>它的工作机制就是个钩子</p><p>eslint 结合git hooks, 使用hushy模块来实现</p><blockquote><p>npm intsall hushy -D //安装</p></blockquote><p>在package中添加一个husky对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;husky&quot;</span> : &#123;<span class="string">&quot; hooks&quot;</span> :&#123;</span><br><span class="line">    pre-commit<span class="string">&quot; : &quot;</span>npm run test<span class="string">&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>安装 npm intsall lint-staged -D</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span> :&#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span> : <span class="string">&quot;eslint ./index.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;precommit&quot;</span> :<span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&quot;lint-staged&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;*.js&quot;</span>:[</span><br><span class="line">        <span class="string">&quot;eslint&quot;</span>,</span><br><span class="line">        <span class="string">&quot;git add&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>其中部分内容参考简书: <a href="https://www.jianshu.com/p/ad1e46faaea2">https://www.jianshu.com/p/ad1e46faaea2</a></p><p>原创博文, 如有错误, 敬请指导!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;规范化&quot;&gt;&lt;a href=&quot;#规范化&quot; class=&quot;headerlink&quot; title=&quot;规范化&quot;&gt;&lt;/a&gt;规范化&lt;/h4&gt;&lt;p&gt;为什么要有规范化标准&lt;br&gt;·软件开发需要多人协同&lt;br&gt;·不同开发者具有不同的编码习惯和喜好。&lt;br&gt;·不同的喜好增加项目维护成本</summary>
      
    
    
    
    <category term="高级前端笔记" scheme="https://levxn7.github.io/categories/%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="规范化" scheme="https://levxn7.github.io/tags/%E8%A7%84%E8%8C%83%E5%8C%96/"/>
    
    <category term="eslint" scheme="https://levxn7.github.io/tags/eslint/"/>
    
  </entry>
  
  <entry>
    <title>模块化工具</title>
    <link href="https://levxn7.github.io/2022/01/15/mkh/mkh/"/>
    <id>https://levxn7.github.io/2022/01/15/mkh/mkh/</id>
    <published>2022-01-15T03:23:22.000Z</published>
    <updated>2024-03-20T15:18:57.748Z</updated>
    
    <content type="html"><![CDATA[<h4 id="模块打包工具由来"><a href="#模块打包工具由来" class="headerlink" title="模块打包工具由来"></a>模块打包工具由来</h4><p>由于 ES Modules 存在环境兼容问题, 又模块文件较多, 网络请求比较频繁, 前端资源都需要模块化<br>新特性代码编译, 编译就是把es6编译成es5, 然后打包, 模块化JavaScript打包, 支持不同类型的资源模块</p><p>打包工具：解决的不只是js的模块化，而是前端整体的模块化</p><ul><li>webpack 模块加载器  代码拆分 资源模块</li><li>rollup</li><li>parcel</li></ul><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><p><strong>webpack的基本使用</strong><br>webpack比较先进, 非常受欢迎</p><blockquote><p>yarn init --yes<br>yarn add webpack webpack-cli --dev<br>yarn webpack --version<br>yarn webpack (会从index.js开始打包</p></blockquote><p><strong>配置文件</strong><br>支持0配置<br>一般来说会将 src/index.js 作为打包入口, 将结果存入 dist/main.js 中, 但是也可以自己在 webpack.config.js 中设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>, <span class="comment">//设置输入</span></span><br><span class="line">    <span class="attr">output</span>: &#123; <span class="comment">//设置输出</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;output&#x27;</span>) <span class="comment">//必须是绝对路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打包模式</strong><br>使用cli设置打包模式 </p><blockquote><p>yarn webpack --mode development //优化速度模式<br>yarn webpack --mode none //普通模式</p></blockquote><p><strong>资源模块加载</strong><br>webpack内部默认只会打包js文件, 如果打包css需要安装loader来操作, webpack可将任何资源模块导入js一起打包</p><blockquote><p>yarn add css-loader --dev //来打包<br>yarn add style-loader --dev //来调用</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line"><span class="attr">rules</span>: [ <span class="comment">//加载规则</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            <span class="string">&#x27;style-loader&#x27;</span>, <span class="comment">//会从后往前执行</span></span><br><span class="line">            <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>文件资源加载器</strong></p><blockquote><p>yarn add file-loader --dev //文件操作</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">publicPath: <span class="string">&#x27;dist/&#x27;</span> <span class="comment">//output</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">//rules</span></span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/.png$/</span>,</span><br><span class="line">    use: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>data url</strong></p><blockquote><p>yarn add url-loader --dev //路径操作</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="comment">//rules</span></span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/.png$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">limit</span>: <span class="number">10</span> * <span class="number">1024</span> <span class="comment">// 10 KB</span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小文件可以使用 Data URLs，可以减少请求次数, 大文件尽量单独提取存放, 可以提高加载速度</p><blockquote><p>常用加载器分类<br>编译转换类<br>文件操作类<br>代码检查类</p></blockquote><p><strong>处理es6</strong><br>因为模块打包需要，所以处理 import 和 export</p><blockquote><p>yarn add babel-loader @babel/core @babel/preset-env --dev</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="comment">//rules</span></span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/.js$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>Webpack只是打包工具, 加载器可以用来编译转换代码</p><p>兼容的模块加载方式有 import , require , define , 但是不要一个项目里写这么多种</p><p><strong>html-loader</strong><br>默认只会处理img中的src属性, 所以处理options</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/.html$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;html-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">attrs</span>: [<span class="string">&#x27;img:src&#x27;</span>, <span class="string">&#x27;a:href&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Webpack模块加载方式</strong><br>·遵循ES Modules标准的import声明<br>·遵循CommonJS标准的require函数<br>·遵循AMD标准的define函数和require函数<br>·样式代码中的@import指令和url函数。<br>·HTML代码中图片标签的src属性</p><p><strong>核心工作原理</strong><br>根据打包入口, 分析模块, 递归依赖树, 解析模块, 把结果放入bundle.js<br>Loader的机制是Webpack的核心</p><h5 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h5><p><strong>Loader工作原理</strong><br>例如我们可以自己编写一个markdown文件的Loader<br>创建markdown-loader.js<br>export 一个函数, 返回结果必须是js代码<br>rules引用<br>安装marked模块解析<br>yarn add marked --dev<br>可以自己处理成js返回<br>或html-loader来处理</p><p>Loader负责资源文件从输入到输出的转换, 它其实是一个管道的概念, 可以拼接使用</p><p><strong>插件机制</strong><br>plugin来解决除资源加载外, 其他自动化工作, 如清除, 拷贝, 压缩</p><blockquote><p>yarn add clean-webpack-plugin --dev //清理<br>yarn add html-webpack-plugin --dev //生成html<br>yarn add copy-webpack-plugin --dev //不编译直接复制过去</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意删除publicpath</span></span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>) <span class="comment">//解构</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;copy-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.ProgressPlugin(),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="comment">//用于生成index.html</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        title</span><br><span class="line">        meta</span><br><span class="line">        template</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//用于生成iabout.html</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;about.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">        <span class="comment">// &#x27;public/**&#x27; 路径 通配符</span></span><br><span class="line">        <span class="string">&#x27;public&#x27;</span></span><br><span class="line">    ])</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="开发一个插件"><a href="#开发一个插件" class="headerlink" title="开发一个插件"></a>开发一个插件</h5><p>Plugin通过钩子机制实现<br>插件必须一个函数或者是一个包含apply方法的对象，所以一般是新建一个class，然后在class里构建一个apply方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> </span>&#123;</span><br><span class="line">    apply (compiler) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;MyPlugin 启动&#x27;</span>)</span><br><span class="line">        compiler.hooks.emit.tap(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// compilation =&gt; 可以理解为此次打包的上下文</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> compilation.assets) &#123;</span><br><span class="line">        <span class="comment">// console.log(name)</span></span><br><span class="line">        <span class="comment">// console.log(compilation.assets[name].source())</span></span><br><span class="line">        <span class="keyword">if</span> (name.endsWith(<span class="string">&#x27;.js&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> contents = compilation.assets[name].source()</span><br><span class="line">        <span class="keyword">const</span> withoutComments = contents.replace(<span class="regexp">/\/\*\*+\*\//g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        compilation.assets[name] = &#123;</span><br><span class="line">        <span class="attr">source</span>: <span class="function">() =&gt;</span> withoutComments,</span><br><span class="line">        <span class="attr">size</span>: <span class="function">() =&gt;</span> withoutComments.length</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>plugins中调用 new MyPlugin()<br>插件是通过在生命周期的钩子中挂载函数实现扩展</p><p><strong>如何增强webpack开发体验</strong></p><blockquote><p>yarn webpack --watch //实现自动编译 -- watch监听<br>自动刷新浏览器, 如果用browersync启动再监听, 会比较麻烦, 所以用 webpack-dev-server, 需注意该命令没有自动打包<br>yarn add webpack-dev-server --dev //是个cli<br>yarn webpack-dev-server --open //自动打开浏览器<br>注意: webpack-dev-server 访问静态资源需另外配置devServer</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: <span class="string">&#x27;./public&#x27;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>webpack-dev-server 支持代理配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">    <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">    <span class="comment">// http://localhost:8080/api/users -&gt; https://api.github.com/api/users</span></span><br><span class="line">    <span class="attr">target</span>: <span class="string">&#x27;https://api.github.com&#x27;</span>,</span><br><span class="line">    <span class="comment">// http://localhost:8080/api/users -&gt; https://api.github.com/users</span></span><br><span class="line">    <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 不能使用 localhost:8080 作为请求 GitHub 的主机名</span></span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Source Map (.map后缀名）</strong><br>靠在结尾添加注释来引入Source Map, Source Map解决了源代码与运行代码不一致所产生的问题, webpack也可以通过配置属性devtool生成.map文件 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool: <span class="string">&#x27;source-map&#x27;</span>,</span><br></pre></td></tr></table></figure><p><img src="/2022/01/15/mkh/mkh/1623729629215.jpg" alt="1623729629215.jpg"><br>选择合适的source-map<br>开发环境选择c-m-e-s-m<br>我的代码每行不会超过80个字符<br>我的代码经过 Loader转换过后的差异较大<br>首次打包速度慢无所谓，重写打包相对较快</p><p>生产模式选择none, 因为source map会暴露源代码, 毕竟调试是开发阶段的事, 如果没有信心就nosources-s-m</p><p><strong>开启hmr热更新</strong><br>自动刷新导致的页面状态丢失<br>HMR 热更新体验非常友好<br>HMR是Webpack中最强大的功能之一<br>极大程度的提高了开发者的工作效率</p><p>hmr已经集成在 webpack-dev-server中 不需要安装</p><blockquote><p>yarn webpack-dev-server --hot //使用命令行或通过配置开启</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// hotOnly: true // 只使用 HMR，不会 fallback 到 live reloading</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样只能自动更新样式, 而样式是因为style-loader来操作的, hmr没有通用的js替换方案<br>hmr注意事项</p><p>生产环境优化 不同环境下的配置<br>1.配置文件根据环境不同导出不同配置 （适用于中小型项目）<br>2.一个环境对应一个配置文件 yarn add webpack-merge</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --config webpack.prod.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>内置插件 definePlugin 可以为代码注入一些可能会变化的值 如api</p><p><strong>tree-shaking</strong><br>摇掉未引用代码, 会在生产模式下自动开启, 使用如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    <span class="comment">// 模块只导出被使用的成员 导出 但不引用（标记枯树枝）</span></span><br><span class="line">    <span class="attr">usedExports</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 尽可能合并每一个模块到一个函数中 （作用域提升）</span></span><br><span class="line">    <span class="attr">concatenateModules</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 压缩输出结果 删除未引用成员 （摇掉枯树枝）</span></span><br><span class="line">    <span class="comment">// minimize: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tree-shaking 的前提是必须使用 ES Modules 的代码, 最新版本的babel不会导致树摇失效, 如果不确定就写入这些↓</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">    <span class="attr">presets</span>: [</span><br><span class="line">    <span class="comment">// 如果 Babel 加载模块时已经转换了 ESM，则会导致 Tree Shaking 失效</span></span><br><span class="line">    <span class="comment">// [&#x27;@babel/preset-env&#x27;, &#123; modules: &#x27;commonjs&#x27; &#125;]</span></span><br><span class="line">    <span class="comment">// [&#x27;@babel/preset-env&#x27;, &#123; modules: false &#125;]</span></span><br><span class="line">    <span class="comment">// 也可以使用默认配置，也就是 auto，这样 babel-loader 会自动关闭 ESM 转换</span></span><br><span class="line">    [<span class="string">&#x27;@babel/preset-env&#x27;</span>, &#123; <span class="attr">modules</span>: <span class="string">&#x27;false&#x27;</span> &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sideEffects</strong><br>标记副作用, 生产环境自动开启</p><p><strong>代码分割</strong><br>代码分割就是分包, 如果bundle体积过大会浪费流量和带宽, 但分割时资源不要太大也不要太碎</p><p><strong>多入口打包</strong><br>适用于多页面程序, 把entry改成对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">album</span>: <span class="string">&#x27;./src/album.js&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].bundle.js&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">        <span class="comment">// 自动提取所有公共模块到单独 bundle</span></span><br><span class="line">        <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Multi Entry&#x27;</span>,</span><br><span class="line">        <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">        <span class="attr">chunks</span>: [<span class="string">&#x27;index&#x27;</span>]</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Multi Entry&#x27;</span>,</span><br><span class="line">        <span class="attr">template</span>: <span class="string">&#x27;./src/album.html&#x27;</span>,</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;album.html&#x27;</span>,</span><br><span class="line">        <span class="attr">chunks</span>: [<span class="string">&#x27;album&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>动态导入</strong><br>动态导入的模块会被自动分包, 是按需加载的, 如果是vue或者react单页面开发的话, 就可以在路由映射组件实现这种按需加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import posts from &#x27;./posts/posts&#x27; 不再用这种方式导入</span></span><br><span class="line"><span class="comment">// import album from &#x27;./album/album&#x27;</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> hash = <span class="built_in">window</span>.location.hash || <span class="string">&#x27;#posts&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> mainElement = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.main&#x27;</span>)</span><br><span class="line">    mainElement.innerHTML = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (hash === <span class="string">&#x27;#posts&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// mainElement.appendChild(posts()) </span></span><br><span class="line">        <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;components&#x27; */</span><span class="string">&#x27;./posts/posts&#x27;</span>).then(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: posts &#125;</span>) =&gt;</span> &#123; <span class="comment">//魔法注释</span></span><br><span class="line">        mainElement.appendChild(posts())</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hash === <span class="string">&#x27;#album&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// mainElement.appendChild(album())</span></span><br><span class="line">        <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;components&#x27; */</span><span class="string">&#x27;./album/album&#x27;</span>).then(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: album &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        mainElement.appendChild(album())</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提取css到单个文件</strong><br>超过150kb才会考虑单独提取</p><blockquote><p>yarn add mini-css-extract-plugin --dev<br>yarn add optimize-css-assets-webpack-plugin --dev</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> TerserWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">        <span class="keyword">new</span> TerserWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> OptimizeCssAssetsWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            <span class="comment">// &#x27;style-loader&#x27;, // 将样式通过 style 标签注入</span></span><br><span class="line">            MiniCssExtractPlugin.loader,</span><br><span class="line">            <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>输出文件名hash</strong><br>[hash] //整体hash<br>[chunkhash] //文件hash<br>[contenthash:8] //hash位数</p><h4 id="rollup"><a href="#rollup" class="headerlink" title="rollup"></a>rollup</h4><p>rollup 也是 ES Modules 的打包器, 但仅仅是ES Modules打包器. 与webpack非常类似, 但小巧的多, 它不支持hmr这种高级功能, 会默认开启树摇</p><blockquote><p>yarn add rollup --dev  //可以提供一个cli<br>yarn rollup ./src/index.js --format iife(自调用函数） --file dist/bundle.js</p></blockquote><p><strong>配置文件</strong><br>rollup.config.js , 导出的是一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">input</span>: <span class="string">&#x27;src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">file</span>: <span class="string">&#x27;dist/bundle.js&#x27;</span>,</span><br><span class="line">        <span class="attr">format</span>: <span class="string">&#x27;iife&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yarn rollup --config //启动打包</p><p><strong>扩展途径</strong><br>插件是 Rollup唯一扩展途径</p><blockquote><p>yarn add rollup-plugin-json --dev</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-json&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        json() <span class="comment">//放入的是调用结果</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加载npm模块</strong></p><blockquote><p>yarn add rollup-plugin-node-resolve --dev</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-node-resolve&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        resolve()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加载common.js</strong></p><blockquote><p>yarn add rollup-plugin-commonjs --dev</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> commonjs <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-node-resolve&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [     </span><br><span class="line">        commonjs()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码拆分</strong><br>使用的方式是动态导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./logger&#x27;</span>).then(<span class="function">(<span class="params">&#123; log &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    log(<span class="string">&#x27;code splitting~&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">input</span>: <span class="string">&#x27;src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">// file: &#x27;dist/bundle.js&#x27;,</span></span><br><span class="line">        <span class="comment">// format: &#x27;iife&#x27;</span></span><br><span class="line">        <span class="attr">dir</span>: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">        <span class="attr">format</span>: <span class="string">&#x27;amd&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多入口打包</strong><br>公共部分会自动提取, 将input修改为数组或对象就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// input: [&#x27;src/index.js&#x27;, &#x27;src/album.js&#x27;],</span></span><br><span class="line">    <span class="attr">input</span>: &#123;</span><br><span class="line">        <span class="attr">foo</span>: <span class="string">&#x27;src/index.js&#x27;</span>,</span><br><span class="line">        <span class="attr">bar</span>: <span class="string">&#x27;src/album.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">dir</span>: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">        <span class="attr">format</span>: <span class="string">&#x27;amd&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面不能直接引用amd格式的输出文件，要用require来引用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AMD 标准格式的输出 bundle 不能直接引用 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;script src=&quot;foo.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 需要 Require.js 这样的库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/requirejs@2.3.6/require.js&quot;</span> <span class="attr">data-main</span>=<span class="string">&quot;foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>rollup与webpack</strong><br>优点<br>·输出结果更加扁平<br>·自动移除未引用代码<br>·打包结果依然完全可读</p><p>缺点<br>·加载非 ESM的第三方模块比较复杂<br>·模块最终都被打包到一个函数中，无法实现 HMR<br>·浏览器环境中,代码拆分功能依赖AMD库</p><p>Webpack 大而全，Rollup 小而美<br>应用开发使用建议 Webpack<br>库/框架开发使用建议 Rollup</p><h4 id="parcel"><a href="#parcel" class="headerlink" title="parcel"></a>parcel</h4><p>parcel 是零配置前端应用打包器, 官方建议使用html作为打包的入口文件</p><blockquote><p>yarn add parcel-bundler --dev<br>yarn parcel src/index.html<br>yarn parcel build src/index.html</p></blockquote><p>优点:<br>打包同时会启动服务器<br>支持热特换<br>支持自动安装依赖<br>支持动态导入<br>构建速度非常快（多进程）</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;模块打包工具由来&quot;&gt;&lt;a href=&quot;#模块打包工具由来&quot; class=&quot;headerlink&quot; title=&quot;模块打包工具由来&quot;&gt;&lt;/a&gt;模块打包工具由来&lt;/h4&gt;&lt;p&gt;由于 ES Modules 存在环境兼容问题, 又模块文件较多, 网络请求比较频繁, 前端资</summary>
      
    
    
    
    <category term="高级前端笔记" scheme="https://levxn7.github.io/categories/%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="模块化" scheme="https://levxn7.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    <category term="webpack" scheme="https://levxn7.github.io/tags/webpack/"/>
    
    <category term="rollup" scheme="https://levxn7.github.io/tags/rollup/"/>
    
    <category term="parcel" scheme="https://levxn7.github.io/tags/parcel/"/>
    
  </entry>
  
  <entry>
    <title>模块化</title>
    <link href="https://levxn7.github.io/2022/01/11/modules/modules/"/>
    <id>https://levxn7.github.io/2022/01/11/modules/modules/</id>
    <published>2022-01-11T04:01:47.000Z</published>
    <updated>2024-03-20T15:18:57.748Z</updated>
    
    <content type="html"><![CDATA[<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>内容概要<br>·模块化演变过程<br>·模块化规范<br>·常用的模块化打包工具<br>·基于模块化工具构建现代Web应用</p><h5 id="演变过程"><a href="#演变过程" class="headerlink" title="演变过程"></a>演变过程</h5><p>1: 文件划分方式<br>没有私人空间<br>污染全局作用域<br>命名冲突问题<br>无法管理模块依赖关系</p><p>2: 命名空间方式<br>包裹全局对象中<br>私有变量不安全</p><p>3: lIFE<br>闭包 私有变量安全</p><p>以上是在早期没有工具和规范的情况下, 对模块化的落地方式</p><p><strong>模块化规范的出现</strong><br>模块化标准＋模块加载器</p><p>commonjs规范: CommonJS是以同步模式加载模块<br>·一个文件就是一个模块<br>·每个模块都有单独的作用域<br>·通过module.exports导出成员<br>·通过require函数载入模块</p><p>AMD (Asynchronous Module Definition) 异步模块定义规范<br>.AMD使用起来相对复杂<br>·模块JS文件请求频繁</p><p>require.js: 使用define定义模块, 使用require加载模块, 我理解为它和早期的angularjs很像</p><p>Sea.is + CMD 后被require兼容了</p><h5 id="模块化标准规范"><a href="#模块化标准规范" class="headerlink" title="模块化标准规范"></a>模块化标准规范</h5><p>浏览器使用ES Modules标准规范, nodejs使用commonJs标准来规范<br>ES Modules是当下最主流的规范了</p><p>ES Modules基本特性<br>自动采用严格模式，忽略’use strict’, 每个ES Modules模块都是单独的私有作用域, ES Modules是通过CORS去请求外部JS模块的, ES Modules的 script标签会延迟执行脚本</p><p><strong>导入导出</strong><br>使用export导出, 使用import导入, 使用as输出重命名, 如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    hello <span class="keyword">as</span> fooHello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意<br>虽然长得一样, 但导出的不是字面量, 导入的不是解构<br>导出的是引用关系, 不是值<br>导入的成员是只读, 不能更改</p></blockquote><p><strong>import用法</strong><br>引入不能省略后面的扩展名<br>相对路径以./开头, 绝对路径以/开头, 或者使用完整的url<br>{}为空时就只加载那个模块, 不需要引用进来<br>* as mod引入所有成员<br>不能from变量, 只能写在最上面<br>动态加载模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./module.js&#x27;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">module</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>提取默认成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name, age, <span class="keyword">default</span> <span class="keyword">as</span> title &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> abc, &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br></pre></td></tr></table></figure><p>直接导出导入的成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>polyfill</strong><br>IE不能兼容ES Modules, 就只能引入unpkg的js地址<br>nomodule属性只在不支持ES Modules环境中运行, 所以可以拿nomodule来引入unpkg, 否则就会在能兼容ES Modules的环境里执行两次</p><p><strong>node中使用ES Modules的实验</strong><br>node版本&gt;8.5就可以使用ES Modules, 需要把文件后缀的.js换成.mjs<br>使用命令&gt;node –experimental-modules index.mjs 来执行</p><p><strong>ES Modules与CommonJS</strong><br>ES Modules中可以导入CommonJS模块, 但CommonJS中不能导入ES Modules模块, CommonJS 始终只会导出一个默认成员</p><p>ES Modules与CommonJS差异</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因ES Modules没有直接获取路径的方法, 所以用以下方法获取路径</span></span><br><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&#x27;url&#x27;</span><span class="keyword">import</span> &#123; dirname &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="keyword">const</span> _filename = fileURLToPath( <span class="keyword">import</span>.meta.url)<span class="built_in">console</span>.log(__filename)</span><br><span class="line"><span class="keyword">const</span> _dirname = dirname(__filename)<span class="built_in">console</span>.log(_dirname)</span><br></pre></td></tr></table></figure><p>如果我们在package.json中写入type: ‘modules’ 就可以不用mjs的扩展名了, 修改回.js扩展名<br>不过这样的话, ES Modules中的CommonJS需要后缀名修改为.cjs才能运行</p><p>早期的node可以使用babel支持ES Modules</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;yarn add ababel/node ababel/core ababel/preset-env --dev</span><br><span class="line">&gt;yarn babel-node</span><br><span class="line">&gt;yarn babel-node index.js --presets=ababel/preset-env</span><br></pre></td></tr></table></figure><p>或在.babelrc 中写入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot; presets&quot;</span> : [<span class="string">&quot;@babel/preset-env&quot;</span> ]&#125;</span><br></pre></td></tr></table></figure><p>就可以&gt;yarn babel-node index.js执行了</p><p>还可以单独安装插件, 然后在 .babelrc 中引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;plugins&quot;</span>:[</span><br><span class="line">    <span class="string">&quot;@babel/plugin-transform-modules-commonjs&quot;</span><span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后&gt;yarn babel-node index.js 就可以直接执行上面那一长串命令了</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;模块化&quot;&gt;&lt;a href=&quot;#模块化&quot; class=&quot;headerlink&quot; title=&quot;模块化&quot;&gt;&lt;/a&gt;模块化&lt;/h4&gt;&lt;p&gt;内容概要&lt;br&gt;·模块化演变过程&lt;br&gt;·模块化规范&lt;br&gt;·常用的模块化打包工具&lt;br&gt;·基于模块化工具构建现代Web应用&lt;/p&gt;</summary>
      
    
    
    
    <category term="高级前端笔记" scheme="https://levxn7.github.io/categories/%E9%AB%98%E7%BA%A7%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="模块化" scheme="https://levxn7.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    <category term="CommonJS" scheme="https://levxn7.github.io/tags/CommonJS/"/>
    
    <category term="ES Modules" scheme="https://levxn7.github.io/tags/ES-Modules/"/>
    
  </entry>
  
</feed>
