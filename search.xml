<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TypeScript</title>
    <url>/2021/05/28/TypeScript/</url>
    <content><![CDATA[<h4 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h4><p>TypeScript 是基于 JS 之上的编程语言，解决了 JS 语言自有的类型系统的不足，大大提高代码的可靠程度。<br>TypeScript 是 JavaScript 自有类型系统的问题最终极解决方案。<br>TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。<br>TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。</p>
<p>内容概要</p>
<ul>
<li>强类型与弱类型</li>
<li>静态类型与动态类型</li>
<li>JavaScript自有类型系统的问题</li>
<li>Flow静态类型检查方案</li>
<li>TypeScript语言规范与基本应用</li>
<li>类</li>
</ul>
<h4 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h4><p><strong>强类型与弱类型</strong>（类型安全）<br>强类型在语言层面限制函数的实参类型必须与形参类型相同<br>弱类型语言层面不会限制实参的类型<br>强类型有更强的类型约束,而弱类型中几乎没有什么约束<br>强类型语言不允许任意的数据隐式类型转换<br>弱类型语言则允许任意的数据隐式类型转换<br>逻辑判断时就会抛出错误<br>python是强类型语言，但语法可以进行隐式类型转换</p>
<p><strong>静态类型与动态类型</strong>（类型检查）<br>静态：一个变量声明时它的类型就是明确的，声明过后,它的类型就不允许再修改<br>动态：运行阶段才能够明确变量的类型，变量的类型也可以随时发生变化（变量是没有类型的，变量存的值是有类型的）</p>
<p><img src="/2021/05/28/TypeScript/1622449196478.jpg"></p>
<p>js是弱类型, 动态类型, 确实了类型系统的可靠性<br>最早的js非常简单, 是脚本语言（不需要编译, 所以不会检测类型）可直接运行</p>
<blockquote>
<p>js是弱类型引发的的一些问题</p>
</blockquote>
<p>1.异常需要等到运行时才能发现, 错误代码到运行时才会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">// obj.foo()</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  obj.foo()</span><br><span class="line">&#125;, <span class="number">1000000</span>)</span><br><span class="line"><span class="comment">// 不数到1000000时不会报错</span></span><br></pre></td></tr></table></figure>

<p>2.函数功能可能发生改变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">100</span>, <span class="number">100</span>)) <span class="comment">// 结果为数字</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">100</span>, <span class="string">&#x27;100&#x27;</span>)) <span class="comment">//结果为字符串</span></span><br></pre></td></tr></table></figure>

<p>3.对象索引器的错误用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj[<span class="literal">true</span>] = <span class="number">100</span> <span class="comment">// 属性名会自动转换为字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">&#x27;true&#x27;</span>])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>强类型比较可靠可以规避大部分类型异常的错误</p>
</blockquote>
<p>1.强类型代码错误更早暴露</p>
<p>2.强类型代码更智能，编码更准确 (编辑器无法推断类型，所以不能准确的推送提示）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  element.className = <span class="string">&#x27;container&#x27;</span></span><br><span class="line">  element.innerHtml = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.重构更可靠</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> util = &#123;</span><br><span class="line">  <span class="attr">aaa</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;util func&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.减少了代码层面的不必要的类型判断</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a !== <span class="string">&#x27;number&#x27;</span> || <span class="keyword">typeof</span> b !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;arguments must be a number&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h4><p>Flow 是 JS 的类型检查器（形参类型注解）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a: number, b: number</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">return</span> a + b</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>flow安装流程</p>
</blockquote>
<ul>
<li>yarn add flow-bin (node-modules/.bin下的插件可以直接运行)</li>
<li>//@flow (需要在文件的最前面加上注解)</li>
</ul>
<blockquote>
<p>flow一些简单的命令</p>
</blockquote>
<ul>
<li>yarn flow init</li>
<li>yarn flow</li>
<li>yarn flow stop</li>
</ul>
<p><strong>编译</strong><br>编译时去除注解<br>1.<br>yarn add flow-remove-types –dev<br>yarn flow-remove-types src -d dist</p>
<p>2.<br>yarn add ababel/core ababel/cli ababel/preset-flow –dev<br>创建并在.babelIrc中写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;presets&quot;</span> : [<span class="string">&quot;ababel/preset-flow&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yarn babel src -d dist</p>
<p><strong>flow插件</strong><br>Flow Language Support</p>
<p><strong>flow类型推断</strong><br>虽然可以推断 但是还是建议添加注解</p>
<p><strong>类型注解</strong><br>函数 声明都可以注解</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><strong>6种原始类型</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a: string = <span class="string">&#x27;foobar &#x27;</span></span><br><span class="line"><span class="keyword">const</span> b: number = <span class="literal">Infinity</span> /<span class="literal">NaN</span>/<span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> c: boolean = <span class="literal">false</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> d: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> e: <span class="keyword">void</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">const</span> f: symbol = SymbolO</span><br></pre></td></tr></table></figure>
<p><strong>数组类型</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1: <span class="built_in">Array</span>&lt;number&gt; =[<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 : number[] =[<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 如果这个数组里面既存数字又存字符串，如何写</span></span><br><span class="line"><span class="keyword">const</span> arr1: (number | string)[] = [<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span> ,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//元组</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果说后面的这个数组，长度肯定只有三个，</span></span><br><span class="line"><span class="comment">* 第一个肯定是字符串，第二个肯定是字符串，第三个肯定是数字</span></span><br><span class="line"><span class="comment">* 这个时候第一个改成数字不会报错，数组这种类型约束已经约束不到了</span></span><br><span class="line"><span class="comment">* 这个时候元祖的作用就显现了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> foo1: [string, string, number] = [<span class="string">&#x27;zina&#x27;</span>, <span class="string">&#x27;girl&#x27;</span>, <span class="number">18</span>];</span><br><span class="line"><span class="keyword">const</span> foo2: [string,number] = [ <span class="string">&#x27;foo&#x27;</span>,<span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p><strong>对象类型</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1: &#123; <span class="attr">foo</span>: string, <span class="attr">bar</span>: number &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;string&#x27;</span>, <span class="attr">bar</span>: <span class="number">100</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj2: &#123; foo?: string, <span class="attr">bar</span>: number &#125; = &#123; <span class="attr">bar</span>: <span class="number">100</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj3: &#123; [string]: string &#125; = &#123;&#125;</span><br><span class="line">obj3.key1 = <span class="string">&#x27;value1&#x27;</span></span><br><span class="line">obj3.key2 = <span class="string">&#x27;value2&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>函数类型</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">callback: (string, number) =&gt; <span class="keyword">void</span></span>) </span>&#123;</span><br><span class="line">  callback(<span class="string">&#x27;string&#x27;</span>, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="function"><span class="keyword">function</span> (<span class="params"> str,n</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//str =&gt; string</span></span><br><span class="line">    <span class="comment">//n =&gt; number</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//没有返回值 或者返回undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>特殊类型</strong><br>字面量类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="string">&#x27;foo&#x27;</span> = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="keyword">const</span> type: <span class="string">&#x27;success&#x27;</span> | <span class="string">&#x27;warning&#x27;</span> | <span class="string">&#x27;danger&#x27;</span> = <span class="string">&#x27;success&#x27;</span></span><br></pre></td></tr></table></figure>
<p>混合类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type String0rNumber = string | number</span><br><span class="line"><span class="keyword">const</span> b: String0rNumber = <span class="string">&#x27;string&#x27;</span> <span class="comment">// 100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>maybe类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gender: ?number = <span class="literal">undefined</span></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">const</span> gender: number | <span class="literal">null</span> | <span class="keyword">void</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>mixed类型</strong><br>所有类型（强类型）（要先明确类型才能使用不报错）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passMixed</span> (<span class="params">value: mixed</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    value.substr(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    value * value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">passMixed(<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"></span><br><span class="line">passMixed(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p><strong>any类型</strong><br>所有类型（弱类型）（主要是为了兼容老代码）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passAny</span> (<span class="params">value: any</span>) </span>&#123;</span><br><span class="line">  value.substr(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  value * value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">passAny(<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"></span><br><span class="line">passAny(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p><strong>类型小结</strong><br>文档：<a href="https://flow.org/en/docs/types/">https://flow.org/en/docs/types/</a><br>第三方类型手册：<a href="https://www.saltycrane.com/cheat-sheets/flow-type/latest/">https://www.saltycrane.com/cheat-sheets/flow-type/latest/</a></p>
<p><strong>运行环境api</strong><br>内置方法</p>
<h4 id="TypeScript-1"><a href="#TypeScript-1" class="headerlink" title="TypeScript"></a>TypeScript</h4><p>Javascript是基于ES6标准进行实现和扩展的<br>TypeScript可以编译出纯净,简洁的JavaScript代码, 并且可以运行在任何浏览器上<br>所以TypeScript是一种由微软开发的自由和开源的编程语言<br>它是JavaScript的一个超集, 而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程, 是一种给JavaScript添加特性的语言扩展</p>
<p>优点: ts的功能强大,生态健全,语言更完善,任何一种js运行环境都支持.<br>缺点: 语言本身多了很多概念, 不过因为是渐进式很容易上手. 项目初期使用ts还会增加一些成本, 所以更多是用在一些大项目中.</p>
<p>ng, vue3.0已经开始使用</p>
<p><strong>快速上手</strong></p>
<ul>
<li>yarn init –yes</li>
<li>yarn add typescript –dev</li>
<li>新建ts文件 (完全可以使用js的标准语法使用)</li>
<li>编译 yarn tsc filename.ts</li>
<li>类型系统和flow是基本相同的</li>
<li>ts不用编译就可以看到错误提示</li>
<li>编译时检查类型使用异常 移除注解 之类的语法 并转换es6的新特性</li>
</ul>
<p><strong>配置文件</strong></p>
<ul>
<li>yarn tsc –init生成tsconfig.json</li>
<li>里面有些常用的方法</li>
<li>yarn tsc 编译</li>
</ul>
<p><strong>原始类型</strong><br>类型系统和flow是基本相同的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a: string = <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line"><span class="keyword">const</span> b: number = <span class="number">100</span> <span class="comment">// NaN Infinity</span></span><br><span class="line"><span class="keyword">const</span> c: boolean = <span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在非严格模式（strictNullChecks）下，</span></span><br><span class="line"><span class="comment">// string, number, boolean 都可以为空</span></span><br><span class="line"><span class="comment">// const d: string = null</span></span><br><span class="line"><span class="comment">// const d: number = null</span></span><br><span class="line"><span class="comment">// const d: boolean = null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> e: <span class="keyword">void</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">const</span> f: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> g: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol 是 ES2015 标准中定义的成员，</span></span><br><span class="line"><span class="comment">// 使用它的前提是必须确保有对应的 ES2015 标准库引用</span></span><br><span class="line"><span class="comment">// 也就是 tsconfig.json 中的 lib 选项必须包含 ES2015</span></span><br><span class="line"><span class="keyword">const</span> h: symbol = <span class="built_in">Symbol</span>()</span><br></pre></td></tr></table></figure>

<p><strong>标准库声明</strong><br>标准库就是内置对象所对应的声明</p>
<p><strong>中文错误消息</strong><br>yarn tsc –locale zh-CN<br>虽然但是, 不建议使用中文报错, 因为一旦有错误, 很难在引擎中搜索到有用的东西</p>
<p><strong>作用域问题</strong><br>默认文件中的成员会作为全局成员<br>多个文件中有相同成员就会出现冲突</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决办法1: IIFE 提供独立作用域</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">123</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法2: 在当前文件使用 export，也就是把当前文件变成一个模块</span></span><br><span class="line"><span class="comment">// 模块有单独的作用域</span></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>object类型</strong><br>不单只对象, 而是指非原始类型（数组 函数 等）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object 类型是指除了原始类型以外的其它类型</span></span><br><span class="line"><span class="keyword">const</span> foo: object = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// [] // &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要明确限制对象类型，则应该使用这种类型对象字面量的语法，或者是「接口」</span></span><br><span class="line"><span class="keyword">const</span> obj: &#123; <span class="attr">foo</span>: number, <span class="attr">bar</span>: string &#125; = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="string">&#x27;string&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组类型</strong><br>数组类型有两种表现形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> arr2: number[] = [<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是 JS，需要判断是不是每个成员都是数字</span></span><br><span class="line"><span class="comment">// 使用 TS，类型有保障，不用添加类型判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">...args: number[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">prev, current</span>) =&gt;</span> prev + current, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure>

<p><strong>元组类型</strong><br>是一种特殊的数据结构，明确数组的数量和类型<br>上面已经解释过, 这里不做过多说明</p>
<p><strong>枚举类型Enum</strong><br>js没有这种结构, 如果需要用到, 一般是用对象来模拟</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum PostStatus &#123;</span><br><span class="line">    Draft = <span class="number">0</span>,</span><br><span class="line">    Unpublished = <span class="number">1</span>,</span><br><span class="line">    Published = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数字枚举可以不给值, 或只给第一个元素值, 后续的元素会根据这个值自增</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum PostStatus &#123;</span><br><span class="line">    Draft = <span class="number">6</span>,</span><br><span class="line">    Unpublished, <span class="comment">// =&gt; 7</span></span><br><span class="line">    Published <span class="comment">// =&gt; 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串枚举不能自增, 要都给值, 但这种情况不常见</p>
<p><strong>函数类型</strong><br>严格的控制输入输出<br>加个问号或者给默认值可以变成可选参数, 但要放在最后面</p>
<p><strong>任意类型</strong><br>any不会进行类型检查, 不可靠, 尽量不用, 一般是兼容老代码时使用</p>
<p><strong>隐式类型推断</strong><br>如果没有添加类型, ts就会根据代码推断他的类型<br>如果无法推断就会被给any<br>建议为每个变量添加类型注解</p>
<p><strong>类型断言</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假定这个 nums 来自一个明确的接口</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">110</span>, <span class="number">120</span>, <span class="number">119</span>, <span class="number">112</span>]</span><br><span class="line"><span class="keyword">const</span> res = nums.find(<span class="function"><span class="params">i</span> =&gt;</span> i &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// const square = res * res</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> num1 = res <span class="keyword">as</span> number</span><br><span class="line"><span class="keyword">const</span> num2 = &lt;number&gt;res <span class="comment">// JSX 下不能使用</span></span><br></pre></td></tr></table></figure>

<p><strong>接口</strong><br>可以理解为规范或者契约</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Post &#123;</span><br><span class="line">  <span class="attr">title</span>: string</span><br><span class="line">  <span class="attr">content</span>: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPost</span> (<span class="params">post: Post</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(post.title)</span><br><span class="line">  <span class="built_in">console</span>.log(post.content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printPost(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Hello TypeScript&#x27;</span>,</span><br><span class="line">  <span class="attr">content</span>: <span class="string">&#x27;A javascript superset&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可选成员后加？<br>只读成员前加readonly</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Post &#123;</span><br><span class="line">  <span class="attr">title</span>: string</span><br><span class="line">  <span class="attr">content</span>: string</span><br><span class="line">  subtitle?: string</span><br><span class="line">  readonly summary: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> hello: Post = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Hello TypeScript&#x27;</span>,</span><br><span class="line">  <span class="attr">content</span>: <span class="string">&#x27;A javascript superset&#x27;</span>,</span><br><span class="line">  <span class="attr">summary</span>: <span class="string">&#x27;A javascript&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello.summary = &#x27;other&#x27; 不可以</span></span><br></pre></td></tr></table></figure>

<p>动态成员（不知具体的成员名称）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Cache &#123;</span><br><span class="line">  [prop: string]: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache: Cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line">cache.foo = <span class="string">&#x27;value1&#x27;</span></span><br><span class="line">cache.bar = <span class="string">&#x27;value2&#x27;</span></span><br></pre></td></tr></table></figure>


<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p><strong>基本使用</strong></p>
<ul>
<li>描述一类具体事物的抽象特征</li>
<li>有子类, 父类</li>
<li>我们不能使用类, 只能使用类的实例</li>
<li>ts增强了class的特性</li>
<li>类的属性必须要在使用之前声明</li>
</ul>
<p><strong>访问修饰符</strong></p>
<ul>
<li>private是私有属性, 外部不能访问</li>
<li>public是公有属性, 默认就是public属性</li>
<li>protected是保护属性, 只允许在子类中访问<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">public name: string <span class="comment">// = &#x27;init name&#x27;</span></span><br><span class="line">private age: number</span><br><span class="line">protected gender: boolean</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>类的只读属性</strong><br>如果有访问修饰符，readonly只能放在修饰符的后面, 赋值后就不能再修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">protected readonly gender: boolean</span><br></pre></td></tr></table></figure>

<p><strong>类与接口</strong></p>
<ul>
<li>不同类的共同属性可以用接口抽象出来</li>
<li>使用函数签名的方式来约束方法的运行</li>
<li>implements实现接口</li>
<li>合理的是一个接口interface只约束一个能力<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Eat &#123;</span><br><span class="line">  eat (food: string): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Run &#123;</span><br><span class="line">  run (distance: number): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">Eat</span>, <span class="title">Run</span> </span>&#123;</span><br><span class="line">  eat (food: string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`优雅的进餐: <span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run (distance: number) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`直立行走: <span class="subst">$&#123;distance&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="title">implements</span> <span class="title">Eat</span>, <span class="title">Run</span> </span>&#123;</span><br><span class="line">  eat (food: string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`呼噜呼噜的吃: <span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run (distance: number) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`爬行: <span class="subst">$&#123;distance&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>抽象类</strong></p>
<ul>
<li>abstract抽象类可以具体实现, 接口不能实现</li>
<li>要定义抽象方法 不需要方法体</li>
<li>抽象类只能被继承 不能被实例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  eat (food: string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`呼噜呼噜的吃: <span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  abstract run (distance: number): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  run(distance: number): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;四脚爬行&#x27;</span>, distance)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> Dog()</span><br><span class="line">d.eat(<span class="string">&#x27;嗯西马&#x27;</span>)</span><br><span class="line">d.run(<span class="number">100</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>泛型</strong><br>我们在定义接口或类的时候没有指定具体的类型, 调用时才指定类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt; (<span class="params">length: number, value: T</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="built_in">Array</span>&lt;T&gt;(length).fill(value)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const res = createNumberArray(3, 100)</span></span><br><span class="line"><span class="comment">// res =&gt; [100, 100, 100]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = createArray&lt;string&gt;(<span class="number">3</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>类型声明</strong><br>类型声明是为了兼容一些npm模块<br>文件中的.d.ts就是为了做类型声明模块的文件<br>如果又对应的类型声明模块, 就要安装对应的类型声明模块, 如果没有, 就要我们自己使用declare去声明</p>
<blockquote>
<p>一个简单的类的实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  public name: string <span class="comment">// = &#x27;init name&#x27;</span></span><br><span class="line">  private age: number</span><br><span class="line">  protected gender: boolean</span><br><span class="line">  </span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name: string, age: number</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.gender = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHi (msg: string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I am <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>, <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  private <span class="title">constructor</span> (<span class="params">name: string, age: number</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.gender)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> create (name: string, <span class="attr">age</span>: number) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Student(name, age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = <span class="keyword">new</span> Person(<span class="string">&#x27;tom&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(tom.name)</span><br><span class="line"><span class="comment">// console.log(tom.age)</span></span><br><span class="line"><span class="comment">// console.log(tom.gender)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jack = Student.create(<span class="string">&#x27;jack&#x27;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>


<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>类</tag>
        <tag>数据类型</tag>
        <tag>Flow</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程化和实现一个脚手架</title>
    <url>/2021/10/16/csjsj/</url>
    <content><![CDATA[<h4 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h4><p>node是前端的工业革命<br>前端工程化是指遵循一定的标准和规范, 通过工具去提高效率降低成本的一种手段,<br>一切以提高效率、降低成本、质量保证为目的的手段都属于[工程化], 一切重复的工作都应该被自动化<br>工程化不等于某个工具, 工程化的核心应该是对项目整体的一种规划或者架构, 工具只是实现其的一种手段</p>
<blockquote>
<p>使用工程化的原因</p>
</blockquote>
<p>想要使用ES6+新特性, 但是兼容有问题<br>想要使用 Less / Sass/ PostCSS增强 CSS的编程性, 但是运行环境不能直接支持<br>想要使用模块化的方式提高项目的可维护性, 但运行环境不能直接支持<br>部署上线前需要手动压缩代码及资源文件, 部署过程需要手动上传代码到服务器<br>多人协作开发, 无法硬性统一大家的代码风格, 从仓库中pull回来的代码质量无法保证<br>部分功能开发时需要等待后端服务接口提前完成</p>
<blockquote>
<p>工程化可以解决的问题</p>
</blockquote>
<p>传统语言或语法的弊端<br>无法使用模块化/组件化<br>重复的机械式工作<br>代码风格统一、质量保证<br>依赖后端服务接口支持<br>整体依赖后端项目</p>
<blockquote>
<p>一些成熟的工程化集成</p>
</blockquote>
<p>create-react-app<br>vue-cli<br>angular-cli<br>gatsby-cli</p>
<h4 id="脚手架工具"><a href="#脚手架工具" class="headerlink" title="脚手架工具"></a>脚手架工具</h4><p>脚手架工具是帮我们自动创建基础文件的工具<br>脚手架的本质作用就是创建项目基础结构、提供项目规范和约定, 相同的组织结构, 相同的开发范式, 相同的模块依赖, 相同的工具配置, 相同的基础代码都应该被自动化创建</p>
<p><strong>内容概要:</strong></p>
<ul>
<li>脚手架的作用</li>
<li>常用的脚手架工具</li>
<li>通用脚手架工具剖析</li>
<li>开发一款脚手架</li>
</ul>
<p><strong>常用的脚手架工具</strong><br>根据信息创建对应的项目基础结构有create-react-app, vue-cli, angular-cli等<br>例如创建一个组件/模块所需要的文件就可以用到plop</p>
<h5 id="Yeoman"><a href="#Yeoman" class="headerlink" title="Yeoman"></a>Yeoman</h5><p>The web’s scaffolding tool for modern webapps<br>可以搭配不同的generator去创建任何类型项目, 可以使用其搭建自己的脚手架<br>缺点是过于通用, 不够专注</p>
<p><strong>基本使用</strong><br>先安装基础模块: node, npm 或 yarn, 以下举例中我们使用yarn</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn <span class="built_in">global</span> add yo <span class="comment">//全局安装Yeoman</span></span><br><span class="line">yarn <span class="built_in">global</span> add generator-node <span class="comment">// 一个node模块</span></span><br><span class="line">mkdir my-<span class="built_in">module</span></span><br><span class="line">cd my-<span class="built_in">module</span></span><br><span class="line">yo node <span class="comment">//input something...</span></span><br></pre></td></tr></table></figure>
<p>执行yo node后的命令行如下(做个例子)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localhost:my-<span class="built_in">module</span> zxl$ yo node</span><br><span class="line">? ==========================================================================</span><br><span class="line">We<span class="string">&#x27;re constantly looking for ways to make yo better! </span></span><br><span class="line"><span class="string">May we anonymously report usage statistics to improve the tool over time? </span></span><br><span class="line"><span class="string">More info: https://github.com/yeoman/insight &amp; http://yeoman.io</span></span><br><span class="line"><span class="string">? Module Name my-module</span></span><br><span class="line"><span class="string">(node:77281) [DEP0066] DeprecationWarning: OutgoingMessage.prototype._headers is deprecated</span></span><br><span class="line"><span class="string">(Use `node --trace-deprecation ...` to show where the warning was created)</span></span><br><span class="line"><span class="string">? The name above already exists on npm, choose another? No</span></span><br><span class="line"><span class="string">? Description a test project</span></span><br><span class="line"><span class="string">? Project homepage url https://github.com/Levxn7/yoNodeTest</span></span><br><span class="line"><span class="string">? Author&#x27;</span>s Name zxl</span><br><span class="line">? Author<span class="string">&#x27;s Email levxn7@qq.com</span></span><br><span class="line"><span class="string">? Author&#x27;</span>s Homepage https:<span class="comment">//levxn7.github.io/</span></span><br><span class="line">? Package keywords (comma to split) <span class="built_in">module</span>,node</span><br><span class="line">? Send coverage reports to coveralls No</span><br><span class="line">? Enter Node versions (comma separated) </span><br><span class="line">? GitHub username or organization Levxn7</span><br><span class="line">? Which license <span class="keyword">do</span> you want to use? Apache <span class="number">2.0</span></span><br></pre></td></tr></table></figure>


<p><strong>sub generator</strong><br>不是所有generator都有子集生成器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yo node:cli <span class="comment">//cli应用</span></span><br><span class="line">yarn link <span class="comment">//建立通道</span></span><br></pre></td></tr></table></figure>

<p><strong>yeoman常规使用步骤</strong><br>1.明确你的需求;<br>2.找到合适的 Generator;<br>3.全局范围安装找到的 Generator;<br>4.通过Yo运行对应的Generator;<br>5.通过命令行交互填写选项;<br>6.生成你所需要的项目结构;</p>
<h5 id="基于Yeoman搭建自己的脚手架"><a href="#基于Yeoman搭建自己的脚手架" class="headerlink" title="基于Yeoman搭建自己的脚手架"></a>基于Yeoman搭建自己的脚手架</h5><p><strong>1.创建一个Generator模块</strong><br>名称必须是generator-<name>格式</name></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mkdir generator-sample</span><br><span class="line">cd generator-sample</span><br><span class="line">yarn init <span class="comment">//创建package.json</span></span><br><span class="line">yarn add yeoman-generator <span class="comment">// 这个模块提供了生成器的一个基类, 这个基类当中提供了一些工具函数 让我们在使用时更加便捷</span></span><br></pre></td></tr></table></figure>
<p>使用vscode打开项目, 创建generators/app/index.js, 此文件作为Generator的核心入口, 需要导出一个继承自Yeoman Generator的类型<br>Yeoman Generator 在工作时会自动调用我们在此类型中定义的一些生命周期方法, 我们在这些方法中可以通过调用父类提供的一些工具方法实现一些功能, 例如文件写入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Generator = <span class="built_in">require</span>(<span class="string">&#x27;yeoman-generator&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  writing () &#123;</span><br><span class="line">    <span class="comment">// Yeoman 自动在生成文件阶段调用此方法</span></span><br><span class="line">    <span class="comment">// 我们这里尝试往项目目录中写入文件</span></span><br><span class="line">    <span class="built_in">this</span>.fs.write(</span><br><span class="line">      <span class="built_in">this</span>.destinationPath(<span class="string">&#x27;temp.txt&#x27;</span>),</span><br><span class="line">      <span class="built_in">Math</span>.random().toString()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yarn link发布</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localhost:generator-sample zxl$ yarn link</span><br><span class="line">yarn link v1<span class="number">.22</span><span class="number">.10</span></span><br><span class="line">success Registered <span class="string">&quot;generator-sample&quot;</span>.</span><br><span class="line">info You can now run <span class="string">`yarn link &quot;generator-sample&quot;`</span> <span class="keyword">in</span> the projects where you want to use <span class="built_in">this</span> package and it will be used instead.</span><br><span class="line">✨  Done <span class="keyword">in</span> <span class="number">0.</span>03s.</span><br></pre></td></tr></table></figure>


<p><strong>2.新建一个项目</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mkdir my-pro</span><br><span class="line">cd my-pro</span><br><span class="line">yo sample</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localhost:my-pro zxl$ yo sample</span><br><span class="line">   create temp.txt</span><br></pre></td></tr></table></figure>
<p><img src="/2021/10/16/csjsj/QQ20210604-114517@2x.png"><br>这就创建好了, 可以看到我们使用yo sample为新文件夹创建了一个txt文件并写入了一个随机数, 这就是最基本的yeoman的开发过程,<br>下面我们再给他加上一点东西</p>
<p><strong>3.根据模板创建文件</strong><br>相对于手动创建每一个文件, 模板的方式大大提高了效率<br>在app文件夹下新建templates/foo.txt</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Generator = <span class="built_in">require</span>(<span class="string">&#x27;yeoman-generator&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  writing () &#123;</span><br><span class="line">    <span class="comment">// Yeoman 自动在生成文件阶段调用此方法</span></span><br><span class="line">    <span class="comment">// 通过模板方式写入文件到目标目录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板文件路径</span></span><br><span class="line">    <span class="keyword">const</span> tmpl = <span class="built_in">this</span>.templatePath(<span class="string">&#x27;foo.txt&#x27;</span>)</span><br><span class="line">    <span class="comment">// 输出目标路径</span></span><br><span class="line">    <span class="keyword">const</span> output = <span class="built_in">this</span>.destinationPath(<span class="string">&#x27;foo.txt&#x27;</span>)</span><br><span class="line">    <span class="comment">// 模板数据上下文</span></span><br><span class="line">    <span class="keyword">const</span> context = &#123; <span class="attr">title</span>: <span class="string">&#x27;Hello zce~&#x27;</span>, <span class="attr">success</span>: <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.fs.copyTpl(tmpl, output, context)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在foo中使用&lt;%= title %&gt;模式来替换关键字, yo sample结果生成foo.txt 其中内容也被替换了context中的内容<br><img src="/2021/10/16/csjsj/QQ20210604-115410@2x.png"></p>
<p>下面我们使用prompting方法接受用户输入数据, 然后把获取的结果传入context</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Generator = <span class="built_in">require</span>(<span class="string">&#x27;yeoman-generator&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  prompting () &#123;</span><br><span class="line">    <span class="comment">// Yeoman 在询问用户环节会自动调用此方法</span></span><br><span class="line">    <span class="comment">// 在此方法中可以调用父类的 prompt() 方法发出对用户的命令行询问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.prompt([</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>, <span class="comment">//用户输入方式</span></span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,  <span class="comment">//对应返回值的键</span></span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;Your project name&#x27;</span>, <span class="comment">//给用户的提示</span></span><br><span class="line">        <span class="attr">default</span>: <span class="built_in">this</span>.appname <span class="comment">// appname 为项目生成目录名称</span></span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">    .then(<span class="function"><span class="params">answers</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// answers =&gt; &#123; name: &#x27;user input value&#x27; &#125;</span></span><br><span class="line">      <span class="built_in">this</span>.answers = answers</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  writing () &#123;</span><br><span class="line">    <span class="comment">// // 通过模板方式写入文件到目标目录</span></span><br><span class="line">    <span class="comment">// 模板文件路径</span></span><br><span class="line">    <span class="keyword">const</span> tmpl = <span class="built_in">this</span>.templatePath(<span class="string">&#x27;foo.txt&#x27;</span>)</span><br><span class="line">    <span class="comment">// 输出目标路径</span></span><br><span class="line">    <span class="keyword">const</span> output = <span class="built_in">this</span>.destinationPath(<span class="string">&#x27;foo.txt&#x27;</span>)</span><br><span class="line">    <span class="comment">// 模板数据上下文</span></span><br><span class="line">    <span class="keyword">const</span> context = <span class="built_in">this</span>.answers <span class="comment">// 这里为用户输入结果</span></span><br><span class="line">    <span class="built_in">this</span>.fs.copyTpl(tmpl, output, context)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在foo中只写了一句&lt;%= name %&gt;, yo sample 后产生结果如下<br><img src="/2021/10/16/csjsj/QQ20210604-120142@2x.png"></p>
<h5 id="vue-generator案例"><a href="#vue-generator案例" class="headerlink" title="vue generator案例"></a>vue generator案例</h5><p>具体操作步骤其实上面已经说完了, 先创建一个yeoman, 把项目目录粘贴到templates中, 替换标签值（name等）, 把文件名全放到writing中做循环, 然后运行yarn link, 就可以创建了, 参考代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Generator = <span class="built_in">require</span>(<span class="string">&#x27;yeoman-generator&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  prompting () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.prompt([</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;Your project name&#x27;</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="built_in">this</span>.appname</span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">    .then(<span class="function"><span class="params">answers</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.answers = answers</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  writing () &#123;</span><br><span class="line">    <span class="comment">// 把每一个文件都通过模板转换到目标路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> templates = [</span><br><span class="line">      <span class="string">&#x27;.browserslistrc&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;.editorconfig&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;.env.development&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;.env.production&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;.eslintrc.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;.gitignore&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;babel.config.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;package.json&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;postcss.config.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;README.md&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;public/favicon.ico&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;public/index.html&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;src/App.vue&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;src/main.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;src/router.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;src/assets/logo.png&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;src/components/HelloWorld.vue&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;src/store/actions.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;src/store/getters.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;src/store/index.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;src/store/mutations.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;src/store/state.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;src/utils/request.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;src/views/About.vue&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;src/views/Home.vue&#x27;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    templates.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// item =&gt; 每个文件路径</span></span><br><span class="line">      <span class="built_in">this</span>.fs.copyTpl(</span><br><span class="line">        <span class="built_in">this</span>.templatePath(item),</span><br><span class="line">        <span class="built_in">this</span>.destinationPath(item),</span><br><span class="line">        <span class="built_in">this</span>.answers</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="发布generator"><a href="#发布generator" class="headerlink" title="发布generator"></a>发布generator</h5><p>将代码托管到git（.gitignore忽略node_modules） 对git命令行不熟悉的同学可以先学习一下git</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git status</span><br><span class="line">git add</span><br><span class="line">git commit</span><br><span class="line">create一个github地址</span><br><span class="line">git remote add origin https:<span class="comment">//xxxx.git</span></span><br><span class="line">git push -u origin master</span><br><span class="line">yarn publish</span><br><span class="line">如果镜像有问题就yarn publish --registry=https:<span class="comment">//registry.yarnpkg.com</span></span><br></pre></td></tr></table></figure>

<h5 id="plop"><a href="#plop" class="headerlink" title="plop"></a>plop</h5><p>一个小而美的脚手架工具</p>
<p><strong>基本使用</strong></p>
<ul>
<li>将plop模块作为项目开发依赖安装  (yarn add plop –dev)</li>
<li>在项目根目录下创建一个plopfile.js文件</li>
<li>在plopfile.js文件中定义脚手架任务</li>
<li>编写用于生成特定类型文件的模板  (创建hbs模板)</li>
<li>通过Plop提供的CLI运行脚手架任务  (yarn plop component)</li>
</ul>
<h4 id="脚手架的工作原理"><a href="#脚手架的工作原理" class="headerlink" title="脚手架的工作原理"></a>脚手架的工作原理</h4><p>脚手架就是一个node-cli应用<br>通过 yarn init 创建一个package.json文件, 在里面添加一个bin字段,用来指定一下这个cli应用的入口文件cli.js, 这个入口文件必须要写一个特定的文件头 #!/usr/bin/env node , 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755, 具体就是通过 chmod 755 cli.js 实现修改</p>
<p>与用户交互需要安装 inquire 模块,  yarn add inquire//对用户发起命令行交互询问<br>然后引入模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Node CLI 应用入口文件必须要有这样的文件头</span></span><br><span class="line"><span class="comment">// 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755</span></span><br><span class="line"><span class="comment">// 具体就是通过 chmod 755 cli.js 实现修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 脚手架的工作过程：</span></span><br><span class="line"><span class="comment">// 1. 通过命令行交互询问用户问题</span></span><br><span class="line"><span class="comment">// 2. 根据用户回答的结果生成文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">&#x27;inquirer&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">&#x27;ejs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">inquirer.prompt([ <span class="comment">//这个方法可以发起用户询问</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Project name?&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line">.then(<span class="function"><span class="params">anwsers</span> =&gt;</span> &#123;  <span class="comment">//这个方法获取用户回答</span></span><br><span class="line">  <span class="comment">// console.log(anwsers)</span></span><br><span class="line">  <span class="comment">// 根据用户回答的结果生成文件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//新建一个templates模板, 通过 &lt;%= name %&gt; 模式获取用户输入的值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模板目录</span></span><br><span class="line">  <span class="keyword">const</span> tmplDir = path.join(__dirname, <span class="string">&#x27;templates&#x27;</span>)</span><br><span class="line">  <span class="comment">// 目标目录 使用node方法拿到执行命令行的目录</span></span><br><span class="line">  <span class="keyword">const</span> destDir = process.cwd()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将模板下的文件全部转换到目标目录 这个方法自动扫描路径下的所有文件</span></span><br><span class="line">  fs.readdir(tmplDir, <span class="function">(<span class="params">err, files</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//拿到的file是相对路径</span></span><br><span class="line">      <span class="comment">// 通过模板引擎渲染文件 安装一个ejs的模板引擎 通过ejs.renderFile去渲染这个目录对应的文件</span></span><br><span class="line">      ejs.renderFile(path.join(tmplDir, file), anwsers, <span class="function">(<span class="params">err, result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结果写入目标文件路径</span></span><br><span class="line">        fs.writeFileSync(path.join(destDir, file), result)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>脚手架的原理虽然并不复杂, 但是他的意义是很大的, 他在项目创建环节大大提高了效率</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript新特性</title>
    <url>/2021/11/28/es6NewFeatures/</url>
    <content><![CDATA[<h4 id="ECMAScript与JavaScript"><a href="#ECMAScript与JavaScript" class="headerlink" title="ECMAScript与JavaScript"></a>ECMAScript与JavaScript</h4><h5 id="ES概述"><a href="#ES概述" class="headerlink" title="ES概述"></a>ES概述</h5><p>ECMAScript 6（简称ES6）是于2015年6月正式发布的JavaScript语言的标准，正式名为ECMAScript 2015（ES2015）。它的目标是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。<br>另外，一些情况下ES6也泛指ES2015及之后的新增特性，虽然之后的版本应当称为ES7、ES8等。</p>
<p>JavaScript是ECMAScript的扩展语言, JS的语言本身就是ES, ES只提供最基本的语法, ES6更新的内容很多, 需要我们一点点的去了解.</p>
<p>比如新增let块级作用域, const 常量声明, es6以后 尽量不适用var声明变量.</p>
<h4 id="es的一些新特性的简单介绍"><a href="#es的一些新特性的简单介绍" class="headerlink" title="es的一些新特性的简单介绍"></a>es的一些新特性的简单介绍</h4><h5 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h5><p>ES6的解构说白了就是能够让我们一次性取到多个值</p>
<p><strong>数组的解构</strong></p>
<p>普通的一维数组解构如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> object = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> [aa, bb] = object</span><br></pre></td></tr></table></figure>
<p>可以跳着元素解构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [,,three] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// three=3</span></span><br></pre></td></tr></table></figure>
<p>可以使用…来获取后面所有的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [one,...three] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// three=[2,3];</span></span><br></pre></td></tr></table></figure>
<p>当访问空数组或则越界的时候会得到undefined；</p>
<p><strong>对象的解构</strong></p>
<p>对象解构使用{}，首先指定要解构的属性名，然后指定绑定的变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;<span class="attr">name</span>:nameA,<span class="attr">age</span>:ageA&#125;=&#123;<span class="attr">name</span>:<span class="string">&quot;Jhon&quot;</span>,<span class="attr">age</span>:<span class="number">23</span>&#125;;</span><br><span class="line"><span class="comment">// nameA=&quot;Jhon&quot;,ageA=23</span></span><br></pre></td></tr></table></figure>
<p>如果属性名和变量名一致时，可以缩写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;aaa&#x27;</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#x27;bbb&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;a, b&#125; = object</span><br></pre></td></tr></table></figure>
<p>如果在花括号里的变量名与所要对应的对象里的属性名不相同，则该变量的返回值是undefined。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;aaa&#x27;</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#x27;bbb&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;a, c&#125; = object  <span class="comment">//c变量的返回值为undefined</span></span><br></pre></td></tr></table></figure>


<h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><p>模板字符串在使用时应用反引号包裹字符串, 模板字符串简化了字符串的拼接并支持直接/n换行,  支持插值表达式如:${name}, 模板字符串会自动执行js表达式的结果,并拼接到最终生成的普通字符串中.<br>需要定义标签函数: 在字符串前可以加一个标签，标签实际就是一个函数，添加标签即为调用这个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = myTagFunc<span class="string">`hey, <span class="subst">$&#123;name&#125;</span> is a <span class="subst">$&#123;gender&#125;</span>.`</span></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>


<h5 id="字符串的扩展方法"><a href="#字符串的扩展方法" class="headerlink" title="字符串的扩展方法"></a>字符串的扩展方法</h5><p>在ES6中还提供了三个处理字符串的新方法，分别是includes(),startsWith(),endsWith()，见名知意</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">&#x27;Error: foo is not defined.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  message.startsWith(<span class="string">&#x27;Error&#x27;</span>)   <span class="comment">//是否以xx开头</span></span><br><span class="line">  message.endsWith(<span class="string">&#x27;.&#x27;</span>)    <span class="comment">//是否以xx结尾</span></span><br><span class="line">  message.includes(<span class="string">&#x27;foo&#x27;</span>)  <span class="comment">//是否包含xx</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h5><p>短路运算很多情况下是不适合判断默认参数的，例如 0 ‘’ false null</p>
<p>所以如果有多个形参, 参数默认值要放在最后</p>
<h5 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h5><p>…args, 只能放在最后一位, 并且只能使用一次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">//[2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h5 id="展开数组"><a href="#展开数组" class="headerlink" title="展开数组"></a>展开数组</h5><p>往常我们展开数组是使用apply函数, es6新特性出来后, 我们使用…方法展开数组, </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log.apply(console, arr)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.push(...arr))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>…arr会展开数组按照次序传入</p>
<h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><p>箭头函数用 =&gt; 符号来定义。</p>
<p>箭头函数相当于匿名函数，所以采用函数表达式的写法。</p>
<p>左边是传入函数的参数，右边是函数中执行的语句。</p>
<p>如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y</span><br></pre></td></tr></table></figure>

<p>箭头函数的好处是:</p>
<ul>
<li>更简短易读</li>
<li>没有this的机制，不会改变this的指向</li>
<li>可以避免函数内_this的出现</li>
</ul>
<p>此处推荐firecode插件, 可以使 ‘===’ 或 ‘=&gt;’ 等符号显示的更易读</p>
<h5 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h5><p>变量属性名一样的情况下，变量可以省略<br>给对象添加方法，可以省略function，可以直接方法名（）：{ }<br>可以使用[表达式的返回值]作为对象的属性名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="comment">// bar: bar</span></span><br><span class="line">  <span class="comment">// 属性名与变量名相同，可以省略 : bar</span></span><br><span class="line">  bar,</span><br><span class="line">  <span class="comment">// method1: function () &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(&#x27;method111&#x27;)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// 方法可以省略 : function</span></span><br><span class="line">  method1 () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;method111&#x27;</span>)</span><br><span class="line">    <span class="comment">// 这种方法就是普通的函数，同样影响 this 指向。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Math.random(): 123 // 不允许</span></span><br><span class="line">  <span class="comment">// 通过 [] 让表达式的结果作为属性名</span></span><br><span class="line">  [bar]: <span class="number">123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部的this会指向当前对象</p>
<h5 id="对象扩展方法"><a href="#对象扩展方法" class="headerlink" title="对象扩展方法"></a>对象扩展方法</h5><p>assign方法<br>object.assign(target, source)<br>将多个源对象(source)中的属性复制到一个目标对象(target)，（如果有就覆盖，没有就添加）<br>用途：Object.assign({}, obj)  (变成新对象就可以修改了)<br>如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// obj.name = &#x27;func obj&#x27;</span></span><br><span class="line">  <span class="comment">// console.log(obj)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> funcObj = <span class="built_in">Object</span>.assign(&#123;&#125;, obj)</span><br><span class="line">  funcObj.name = <span class="string">&#x27;func obj&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(funcObj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;global obj&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">func(obj)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>

<h5 id="is方法"><a href="#is方法" class="headerlink" title="is方法"></a>is方法</h5><p>三等号不能判断 +0 和 -0<br>NaN不三等NaN<br>但使用object.is判断上面俩个例子可以是true </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="comment">// 0 == false              // =&gt; true</span></span><br><span class="line">  <span class="comment">// 0 === false             // =&gt; false</span></span><br><span class="line">  <span class="comment">// +0 === -0               // =&gt; true</span></span><br><span class="line">  <span class="comment">// NaN === NaN             // =&gt; false</span></span><br><span class="line">  <span class="comment">// Object.is(+0, -0)       // =&gt; false</span></span><br><span class="line">  <span class="comment">// Object.is(NaN, NaN)     // =&gt; true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="proxy代理"><a href="#proxy代理" class="headerlink" title="proxy代理"></a>proxy代理</h5><p>//Object.defineProperty只能监视读写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>( person【代理对象】，&#123;</span><br><span class="line">set<span class="comment">//设置对象</span></span><br><span class="line">get<span class="comment">//监视访问【返回值是外部访问这个属性得到的结果】</span></span><br><span class="line">&#125;<span class="comment">//【代理处理对象】</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/28/es6NewFeatures/1622190711615.jpg"></p>
<p>对数组更好的监视<br>Proxy是以非侵入的方式监管了对象的读写</p>
<h5 id="Reflect-13个方法"><a href="#Reflect-13个方法" class="headerlink" title="Reflect 13个方法"></a>Reflect 13个方法</h5><p>搭配proxy的13个方法使用<br>统一提供一套用于操作对象的API<br>了解13个方法以及取代的用法</p>
<h5 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h5><p>promise是一种更优的异步编程解决方案<br>解决了传统异步编程中回调函数嵌套过深的问题<br>其他博文有写, 这里不过多说明</p>
<h5 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h5><p>一个简单的类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hi, my name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line">p.say()</span><br></pre></td></tr></table></figure>
<p>理解实例方法vs静态方法</p>
<h5 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h5><p>extends<br>super始终指向父类，调用super（）就是调用了父类的构造函数<br>接上面类一部分的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name, number</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(name) <span class="comment">// 父类构造函数</span></span><br><span class="line">    <span class="built_in">this</span>.number = number</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hello () &#123;</span><br><span class="line">    <span class="built_in">super</span>.say() <span class="comment">// 调用父类成员</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my school number is <span class="subst">$&#123;<span class="built_in">this</span>.number&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;100&#x27;</span>)</span><br><span class="line">s.hello()</span><br></pre></td></tr></table></figure>

<h5 id="set数据结构"><a href="#set数据结构" class="headerlink" title="set数据结构"></a>set数据结构</h5><p>set数据结构类似数组, 常用方法有:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部成员不可重复</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>)</span><br><span class="line">s.forEach()</span><br><span class="line">s.size</span><br><span class="line">s.has(<span class="number">100</span>)</span><br><span class="line">s.delete(<span class="number">3</span>)</span><br><span class="line">s.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment">//常见的是数组去重</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Array</span> .from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)）</span><br><span class="line"><span class="keyword">const</span> result = [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弱引用版本是 WeakSet</span></span><br><span class="line"><span class="comment">// 差异就是 Set 中会对所使用到的数据产生引用</span></span><br><span class="line"><span class="comment">// 即便这个数据在外面被消耗，但是由于 Set 引用了这个数据，所以依然不会回收</span></span><br><span class="line"><span class="comment">// 而 WeakSet 的特点就是不会产生引用，</span></span><br><span class="line"><span class="comment">// 一旦数据销毁，就可以被回收，所以不会产生内存泄漏问题。</span></span><br></pre></td></tr></table></figure>

<h5 id="map数据结构"><a href="#map数据结构" class="headerlink" title="map数据结构"></a>map数据结构</h5><p>map数据结构类似对象, 但对象的键只能是字符串, map可以是任意两个数据的映射<br>常用方法有:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">map.has(<span class="number">100</span>)</span><br><span class="line">map.delete(<span class="number">3</span>)</span><br><span class="line">map.clear()</span><br><span class="line">map.forEach()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弱引用版本 WeakMap</span></span><br><span class="line"><span class="comment">// 差异就是 Map 中会对所使用到的数据产生引用</span></span><br><span class="line"><span class="comment">// 即便这个数据在外面被消耗，但是由于 Map 引用了这个数据，所以依然不会回收</span></span><br><span class="line"><span class="comment">// 而 WeakMap 的特点就是不会产生引用，</span></span><br><span class="line"><span class="comment">// 一旦数据销毁，就可以被回收，所以不会产生内存泄漏问题。</span></span><br></pre></td></tr></table></figure>

<h5 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h5><p>symbol是一种全新的原始数据类型, 最主要的作用就是为对象添加独一无二的属性名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="built_in">Symbol</span>() === <span class="built_in">Symbol</span>()是<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>对象的键可以是symbol, 因为symbol的唯一性, for in 和keys拿不到, 特别作为适合私有属性名<br>(object.getOwnPropertySymbols(obj)可以拿到但只能拿到symbol()类型<br>6种基本数据类型+symbol就是7种类型+下一版本的bugInt就是8种数据类型</p>
<h5 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h5><p>for of可以遍历任何一种数据结构<br>普通对象因为没有迭代接口所以不能被直接 for…of 遍历<br>for of可以使用break终止循环, 而foreach不能终止</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="可迭代接口-iterable"><a href="#可迭代接口-iterable" class="headerlink" title="可迭代接口 iterable"></a>可迭代接口 iterable</h5><p>数据实现iterable接口才能使用for of来循环<br>实现一个可迭代接口:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">store</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>],</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> result = &#123;</span><br><span class="line">          <span class="attr">value</span>: self.store[index],</span><br><span class="line">          <span class="attr">done</span>: index &gt;= self.store.length</span><br><span class="line">        &#125;</span><br><span class="line">        index++</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;循环体&#x27;</span>, item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器适用于任何数据类型</p>
<h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p>生成器可以减少异步回调嵌套过深产生的问题<br>定义生成器, 就是在函数名前面加个*:  function * foo(){}<br>会返回一个生成器对象Object[Generator]{}(也有迭代器接口), 调用next才会让函数体开始执行, 执行到yield暂停, yield的值作为生成器的结果(value)返回, 再yield再开始, .next()会返回格式类似{value:100, done: true}的返回值, 特点是惰性执行, 抽一下动一下, 可应用于发号器等功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1111&#x27;</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">100</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;2222&#x27;</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">200</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;3333&#x27;</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">300</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = foo()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// 第一次调用，函数体开始执行，遇到第一个 yield 暂停</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// 第二次调用，从暂停位置继续，直到遇到下一个 yield 再次暂停</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// 。。。</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// 第四次调用，已经没有需要执行的内容了，所以直接得到 undefined</span></span><br></pre></td></tr></table></figure>

<h5 id="ES-Modules"><a href="#ES-Modules" class="headerlink" title="ES Modules"></a>ES Modules</h5><p>ES Module把一个文件当作一个模块，每个模块有自己的独立作用域，那如何把每个模块联系起来呢？核心点就是模块的导入（import）与导出（export）。<br>在模块A中定义了一些变量与方法，然后将其导出。如果导入的多个文件中，变量名字相同，即会产生命名冲突的问题，为了解决该问题，ES6为提供了重命名的方法，当你在导入名称时可以使用as来重命名.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name <span class="keyword">as</span> name1 &#125; <span class="keyword">from</span> <span class="string">&quot;xxx.js&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="es2016新功能概述"><a href="#es2016新功能概述" class="headerlink" title="es2016新功能概述"></a>es2016新功能概述</h5><p>仅包含两个小功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.includes(indexOf不能查找<span class="literal">NaN</span>)</span><br></pre></td></tr></table></figure>
<p>指数运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">10</span> (=<span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<h5 id="es2017新功能概述"><a href="#es2017新功能概述" class="headerlink" title="es2017新功能概述"></a>es2017新功能概述</h5><p>Object对象的三个方法</p>
<ul>
<li>obj.values(返回所有值的数组,相对于obj.keys())</li>
<li>obj.entries(以数组的形式返回所有的键值对) </li>
<li>obj.getOwnPropertyDescriptors<br>字符串对齐方法</li>
<li>String.prototype.padStart (16, ‘-‘)</li>
<li>String.prototype.padEnd(3. ‘0’)<br>在函数参数中添加尾逗号(很小的变化但很方便)<br>async/await语法</li>
</ul>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>eslint</title>
    <url>/2022/01/26/eslint/</url>
    <content><![CDATA[<h4 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h4><p>为什么要有规范化标准<br>·软件开发需要多人协同<br>·不同开发者具有不同的编码习惯和喜好。<br>·不同的喜好增加项目维护成本<br>·每个项目或者团队需要明确统一的标准</p>
<h4 id="eslint介绍"><a href="#eslint介绍" class="headerlink" title="eslint介绍"></a>eslint介绍</h4><p>Lint 是检验代码格式工具的一个统称，具体的工具有 Jslint 、 Eslint 等, 最为主流的 Jslint 工具监测JS代码质量<br>ESLint很容易统一开发者的编码风格, 可以帮助开发者提升编码能力, 是基于node开发的npm模块, 现代化项目集成eslint, 会让人不拘泥于格式错误, 更专注于开发<br>首先我们初始化一个package</p>
<blockquote>
<p>npm install eslint –save-dev //带有cli命令<br>npx eslint –version //运行</p>
</blockquote>
<p>–save-dev 会把 eslint 安装到 package.json 文件中的 devDependencies 属性中，意思是只是开发阶段用到这个包，上线时就不需要这个包了。</p>
<p><strong>快速上手</strong></p>
<blockquote>
<p>npx eslint –init //初始化一个配置文件, 如果要检查ts文件, 需要再问答时选择yes<br>npx eslint 路径 –fix //–fix会自动修复错误</p>
</blockquote>
<p>一个简单的配置文件.eslintrc.js, 该文件导出一个对象，对象包含属性 env、extends、parserOptions、globals、rules 五个属性, 在根目录下创建 src/index.js 文件, 引入 const lint = ‘eslint’ 来检验代码是否符合规范</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">env</span>: &#123;</span><br><span class="line">        <span class="attr">browser</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">es6</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">extends</span>: [</span><br><span class="line">        <span class="string">&#x27;standard&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">        <span class="attr">ecmaVersion</span>: <span class="number">2015</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">rules</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;no-alert&#x27;</span>: <span class="string">&quot;error&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">globals</span>: &#123;</span><br><span class="line">        <span class="string">&quot;jQuery&quot;</span>: <span class="string">&quot;readonly&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>env、parserOptions、plugins<br>我的程序里要用到 ES6 、React 、JSX 语法，这几个属性就是让 Eslint 能够检验到这些语法的</p>
<p>extends<br>值为 “eslint:recommended” 的 extends 属性启用一系列核心规则，这些规则是经过前人验证的最佳实践（所谓最佳实践，就是大家伙都觉得应该遵循的编码规范），想知道最佳实践具体有哪些编码规范，可以在 eslint规则表 中查看被标记为 √ 的规则项。<br>关于 “airbnb” 编码规范说两句，在接触到大多数开源项目中，大多数的作者都会使用 “airbnb” 编码规范而不是 官方的 “extends”: “eslint:recommended” 编码规范。<br>如果我们觉得 eslint-config-airbnb 规则配置中个别规则并不符合当前项目的要求，可以直接在 .eslintrc.js 配置 rules 属性，优先级高于共享规则 airbnb</p>
<p>ESLint 附带有大量的规则，修改规则应遵循如下要求：<br>“off” 或 0 - 关闭规则<br>“warn” 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)<br>“error” 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)<br>有的规则没有属性，只需控制是开启还是关闭，像这样：”eqeqeq”: “off”，有的规则有自己的属性，使用起来像这样：”quotes”: [“error”, “double”]，具体有没有自带属性，可查看 eslint规则表。</p>
<p>几个常用的规则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;quotes&quot;</span>: [<span class="number">1</span>, <span class="string">&quot;single&quot;</span>],            # 单引号</span><br><span class="line"><span class="string">&quot;quote-props&quot;</span>:[<span class="number">2</span>, <span class="string">&quot;as-needed&quot;</span>],     # 双引号自动变单引号</span><br><span class="line"><span class="string">&quot;semi&quot;</span>: [<span class="number">2</span>, <span class="string">&quot;never&quot;</span>],               # 一行结尾不要写分号</span><br><span class="line"><span class="string">&quot;comma-dangle&quot;</span>: [<span class="number">1</span>,<span class="string">&quot;always-multiline&quot;</span>]  # 对象或数组多行写法时，最后一个值加逗号</span><br></pre></td></tr></table></figure>

<p><strong>配置注释</strong><br>注释规则参考: <a href="http://eslint.cn/docs/user-guide/configuring#configuring-rules">http://eslint.cn/docs/user-guide/configuring#configuring-rules</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">&quot;$&#123;name&#125; is a coder&quot;</span> <span class="comment">// eslint-disable-line no-template-curly-in-string</span></span><br></pre></td></tr></table></figure>
<p><strong>结合自动化gulp</strong><br>集成之后，ESLint 一定会工作,  这样做会与项目统一，管理更加方便</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.pipe(plugins.eslint())</span><br><span class="line">.pipe(plugins.eslint.format())</span><br><span class="line">.pipe(plugins.eslint.failAfterErrorO)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>结合webpack</strong><br>前置工作<br>·安装对应模块<br>·安装eslint模块<br>·安装eslint-loader模块<br>·初始化.eslintrc.js配置文件</p>
<p>关于react引入却没使用的问题 npm install eslint-plugin-react</p>
<p><strong>stylelint的认识</strong><br>使用方法基本可以参考eslint, 二者几乎是一样的</p>
<blockquote>
<p>npm install stylelint -D //安装<br>npx stylelint ./index.css //运行</p>
</blockquote>
<p>配置文件为.stylelintsrc.js, 需在文件中继承 standard (安装 npm install stylelint-config-standard)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    <span class="attr">extends</span>: <span class="string">&quot;stylelint-config-standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查sass需要安装 npm install stylelint-config-sass-guidelines -D, 然后继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    <span class="attr">extends</span>: [</span><br><span class="line">        <span class="string">&quot;stylelint-config-standard&quot;</span></span><br><span class="line">        <span class="string">&quot;stylelint-config-sass-guidelines&quot;</span></span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>prettier的使用</strong></p>
<blockquote>
<p>npm install prettier -D //安装<br>npx prettier . –write</p>
</blockquote>
<p>不要完全依赖工具来格式化, 自己要写出良好的代码</p>
<p><strong>git hooks</strong><br>它的工作机制就是个钩子</p>
<p>eslint 结合git hooks, 使用hushy模块来实现</p>
<blockquote>
<p>npm intsall hushy -D //安装</p>
</blockquote>
<p>在package中添加一个husky对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;husky&quot;</span> : &#123;<span class="string">&quot; hooks&quot;</span> :&#123;</span><br><span class="line">    pre-commit<span class="string">&quot; : &quot;</span>npm run test<span class="string">&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>安装 npm intsall lint-staged -D</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span> :&#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span> : <span class="string">&quot;eslint ./index.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;precommit&quot;</span> :<span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&quot;lint-staged&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;*.js&quot;</span>:[</span><br><span class="line">        <span class="string">&quot;eslint&quot;</span>,</span><br><span class="line">        <span class="string">&quot;git add&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>其中部分内容参考简书: <a href="https://www.jianshu.com/p/ad1e46faaea2">https://www.jianshu.com/p/ad1e46faaea2</a></p>
<p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>规范化</tag>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title>实现防抖和节流的函数</title>
    <url>/2021/09/03/fdjl/</url>
    <content><![CDATA[<h5 id="我们为什么需要防抖和节流："><a href="#我们为什么需要防抖和节流：" class="headerlink" title="我们为什么需要防抖和节流："></a>我们为什么需要防抖和节流：</h5><p>浏览器默认情况下都会有自己的监听事件间隔（ 4~6ms)，如果检测到多次事件的监听执行，那么就会造成不必要的资源浪费<br>在一些高频率事件触发的场景下我们不希望对应的事件处理函数多次执行<br>比如以下场景:</p>
<ul>
<li>滚动事件</li>
<li>输入的模糊匹配</li>
<li>轮播图切换</li>
<li>点击操作</li>
<li>….</li>
</ul>
<p>前置的场景： 界面上有一个按钮，我们可以连续多次点击</p>
<p>防抖：对于这个高频的操作来说，我们只希望识别一次点击，可以人为是第一次或者是最后一次<br>节流：对于高频操作，我们可以自己来设置频率，让本来会执行很多次的事件触发，按着我们定义的频率减少触发的次数</p>
<h5 id="实现一个防抖函数"><a href="#实现一个防抖函数" class="headerlink" title="实现一个防抖函数"></a>实现一个防抖函数</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>防抖函数实现<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oBtn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// oBtn.onclick = function () &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   console.log(&#x27;点击了&#x27;)</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">/** </span></span></span><br><span class="line"><span class="comment"><span class="javascript">     * handle 最终需要执行的事件监听</span></span></span><br><span class="line"><span class="comment"><span class="javascript">     * wait 事件触发之后多久开始执行</span></span></span><br><span class="line"><span class="comment"><span class="javascript">     * immediate 控制执行第一次还是最后一次，false 执行最后一次</span></span></span><br><span class="line"><span class="comment"><span class="javascript">    */</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">myDebounce</span>(<span class="params">handle, wait, immediate</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 参数类型判断及默认值处理</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="keyword">typeof</span> handle !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;handle must be an function&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="keyword">typeof</span> wait === <span class="string">&#x27;undefined&#x27;</span>) wait = <span class="number">300</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="keyword">typeof</span> wait === <span class="string">&#x27;boolean&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">        immediate = wait</span></span><br><span class="line"><span class="javascript">        wait = <span class="number">300</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="keyword">typeof</span> immediate !== <span class="string">&#x27;boolean&#x27;</span>) immediate = <span class="literal">false</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 所谓的防抖效果我们想要实现的就是有一个 ”人“ 可以管理 handle 的执行次数</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果我们想要执行最后一次，那就意味着无论我们当前点击了多少次，前面的N-1次都无用</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> timer = <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">...args</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> self = <span class="built_in">this</span>,</span></span><br><span class="line"><span class="javascript">          init = immediate &amp;&amp; !timer</span></span><br><span class="line"><span class="javascript">        <span class="built_in">clearTimeout</span>(timer)</span></span><br><span class="line"><span class="javascript">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          timer = <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">          !immediate ? handle.call(self, ...args) : <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(self)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(...args)</span></span><br><span class="line"><span class="javascript">        &#125;, wait)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 如果当前传递进来的是 true 就表示我们需要立即执行</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 如果想要实现只在第一次执行，那么可以添加上 timer 为 null 做为判断</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 因为只要 timer 为 Null 就意味着没有第二次....点击</span></span></span><br><span class="line"><span class="javascript">        init ? handle.call(self, ...args) : <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义事件执行函数</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">btnClick</span>(<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;点击了1111&#x27;</span>, <span class="built_in">this</span>, ev)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 当我们执行了按钮点击之后就会执行...返回的 proxy</span></span></span><br><span class="line"><span class="javascript">    oBtn.onclick = myDebounce(btnClick, <span class="number">200</span>, <span class="literal">false</span>)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// oBtn.onclick = btnClick()  // this ev</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h5 id="实现一个节流函数"><a href="#实现一个节流函数" class="headerlink" title="实现一个节流函数"></a>实现一个节流函数</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>节流函数实现<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">5000px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 节流：我们这里的节流指的就是在自定义的一段时间内让事件进行触发</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">myThrottle</span>(<span class="params">handle, wait</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="keyword">typeof</span> handle !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;handle must be an function&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="keyword">typeof</span> wait === <span class="string">&#x27;undefined&#x27;</span>) wait = <span class="number">400</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> previous = <span class="number">0</span>  <span class="comment">// 定义变量记录上一次执行时的时间 </span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> timer = <span class="literal">null</span>  <span class="comment">// 用它来管理定时器</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">...args</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// 定义变量记录当前次执行的时刻时间点</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> self = <span class="built_in">this</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> interval = wait - (now - previous)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (interval &lt;= <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 此时就说明是一个非高频次操作，可以执行 handle </span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">clearTimeout</span>(timer)</span></span><br><span class="line"><span class="javascript">          timer = <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">          handle.call(self, ...args)</span></span><br><span class="line"><span class="javascript">          previous = <span class="keyword">new</span> <span class="built_in">Date</span>()</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timer) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 当我们发现当前系统中有一个定时器了，就意味着我们不需要再开启定时器</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 此时就说明这次的操作发生在了我们定义的频次时间范围内，那就不应该执行 handle</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 这个时候我们就可以自定义一个定时器，让 handle 在 interval 之后去执行 </span></span></span><br><span class="line"><span class="javascript">          timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">clearTimeout</span>(timer) <span class="comment">// 这个操作只是将系统中的定时器清除了，但是 timer 中的值还在</span></span></span><br><span class="line"><span class="javascript">            timer = <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">            handle.call(self, ...args)</span></span><br><span class="line"><span class="javascript">            previous = <span class="keyword">new</span> <span class="built_in">Date</span>()</span></span><br><span class="line"><span class="javascript">          &#125;, interval)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义滚动事件监听</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">scrollFn</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;滚动了&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// window.onscroll = scrollFn</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onscroll = myThrottle(scrollFn, <span class="number">600</span>)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2021/12/24/functionalProgramming/</url>
    <content><![CDATA[<h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><p><strong>函数式编程是—种编程范式</strong>，我们常见的编程范式有命令式编程(lmperative<br>programming)，函数式编程，逻辑式编程，<em>常见的面向对象编程是也是一种命令式编程</em>。</p>
<p>命令式编程是面向计算机硬件的抽象，有变量(对应着存储单元)，赋值语句(获取，存储指令)，表达式(内存引用和算术运算）和控制语句（跳转指令)。<br>而函数式编程是面向数学的抽象，将计算描述为一种表达式求值，一句话，函数式程序就是一个表达式。</p>
<p>函数式编程中的函数这个术语不是指计算机中的函数(实际上是Subroutine)，而是指<strong>数学中的函数</strong>，即自<strong>变量的映射</strong>。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。<br>在函数式语言中，<strong>函数作为一等公民</strong>，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，可以对函数进行组合。</p>
<p>函数式运算的核心，就是把运算过程抽象成函数，合成的过程就是抽象的过程。函数式运算可以最大程度的重用。<br>函数的名字要有实际性的意义，这对函数式编程来说非常重要。函数式编程经常会使用箭头函数，会使代码更简洁。</p>
<h5 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h5><p>高阶函数的英文名叫 Higher-Order Function，是函数式编程的基本技术。<strong>把函数作为参数传入，这样的函数称为高阶函数</strong>，编写高阶函数，就是让函数的参数能够接收别的函数。函数式编程就是指这种高度抽象的编程范式。</p>
<p>因为在JS中函数是一等公民，即函数可以被赋值给变量，被变量引用，这便使得函数可以作为参数，在其他函数间相互传递。这是JS作为一门“一切皆为对象”的语言，也能拥有函数式编程的能力</p>
<p>闭包（可以判定有基准值的问题）</p>
<h5 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h5><blockquote>
<p><strong>函数的副作用</strong><br>函数的副作用会让函数变得不纯（函数如果依赖外部变量，就会产生副作用，既是不纯函数）。副作用会使函数通用性下降，不适合扩展和重用，会给程序带来安全隐患。副作用不能完全禁止，只能尽量控制。<br>副作用来源：全局变量，配置文件，数据库，用户输入等所有的外部交互</p>
</blockquote>
<p>纯函数始终有输入和输出，相同的输入一定是相同的输出，没有可观察的副作用。纯函数不会调用外部作用域的变量。使得函数与外部解耦，函数的使用更加安全。</p>
<p>纯函数的好处有：</p>
<ul>
<li>可缓存 可以提高程序的性能</li>
<li>可测试</li>
<li>并行处理（对比多线程并行操作共享内存数据的意外）</li>
</ul>
<h5 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h5><blockquote>
<p>维基百科：Currying，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
</blockquote>
<p>当函数有多个参数时，可以分解函数，先传递一部分（不变）的参数，然后返回新的函数接收剩余的参数，然后返回结果。</p>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通的add函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingAdd</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)           <span class="comment">// 3</span></span><br><span class="line">curryingAdd(<span class="number">1</span>)(<span class="number">2</span>)   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>实际上就是把add函数的x，y两个参数变成了先用一个函数接收x然后返回一个函数去处理y参数。现在思路应该就比较清晰了，就是只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
<p>lodash中的柯里化 _.curry(func)，可以帮我们把多元函数转化为一元函数<br>如果传入所有参数就返回结果，如果传入部分参数就返回一个函数，使之可以继续传入参数<br>图12/10-12</p>
<p><strong>总结</strong></p>
<ul>
<li>柯里化可以先传递一些函数并返回一个已有某些固定参数的新函数</li>
<li>是对函数参数的一种‘缓存’，让参数可以复用</li>
<li>让函数变得灵活，颗粒更小 </li>
<li>把多远函数变为一元函数，可以组合使用，产生强大的功效</li>
</ul>
<p>可参考资料<br><a href="https://www.jianshu.com/p/2975c25e4d71">https://www.jianshu.com/p/2975c25e4d71</a></p>
<h5 id="函数的组合compose"><a href="#函数的组合compose" class="headerlink" title="函数的组合compose"></a>函数的组合compose</h5><p>其思想为将数据依次经过几个函数处理（函数的嵌套），最终输出结果数据。</p>
<p>函数组合默认是从右到左执行。大函数拆分成小函数，可以容易debug。函数的组合要满足结合律（数学意义上的结合律）</p>
<p>Lodash的_.flow 提供了 compose 的功能，且可读性更强。_.flow()从左往右执行 _.flowRight()从右往左执行</p>
<p>调试函数组合时可以定义一个内含打印和返回的辅助函数</p>
<h6 id="lodash中的fp模块"><a href="#lodash中的fp模块" class="headerlink" title="lodash中的fp模块"></a>lodash中的fp模块</h6><p>fp模块提供的方法都是经过柯里化的</p>
<ul>
<li>提供了实用的对函数式编程友好的方法</li>
<li>函数优先  数据之后</li>
</ul>
<p>_.map有个小问题，它会给第二个参数（函数a）传递三个参数(item, index, array)，这就有可能会影响到函数a的运作,而fp中的map函数可以解决这个问题</p>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;40&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(_.map(arr1, <span class="built_in">parseInt</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果[ 10, NaN, NaN, NaN ]</span></span><br><span class="line"><span class="comment">//parseInt 执行顺序</span></span><br><span class="line"><span class="comment">//parseInt(&#x27;10&#x27;,0,array) 10</span></span><br><span class="line"><span class="comment">//parseInt(&#x27;20&#x27;,1,array) NAN</span></span><br><span class="line"><span class="comment">//parseInt(&#x27;30&#x27;,2,array) NAN</span></span><br><span class="line"><span class="comment">//parseInt(&#x27;40&#x27;,3,array) NAN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决这个问题使用lodash/fp模块</span></span><br><span class="line"><span class="built_in">console</span>.log(fp.map(<span class="built_in">parseInt</span>, arr1));</span><br><span class="line"><span class="comment">//[ 10, 20, 30, 40 ]</span></span><br></pre></td></tr></table></figure>

<h5 id="pointfree模式"><a href="#pointfree模式" class="headerlink" title="pointfree模式"></a>pointfree模式</h5><p>pointFree：我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。</p>
<ul>
<li>不需要指明处理的数据</li>
<li>只需要合成运算过程</li>
<li>需要定义一些辅助的基本运算函数</li>
</ul>
<h4 id="函子Functor"><a href="#函子Functor" class="headerlink" title="函子Functor"></a>函子Functor</h4><p>我们学习函子是为了在函数式编程中把副作用控制在可控范围内、作异常处理、异步操作等。我们可以把函子想象成一个盒子，里面有map方法，传进一个值，对值进行处理。<br>函子是一个特殊的容器（包含值和值的变形关系（函数）），通过一个普通的对象来实现。函子是一个对象，对外提供map方法，永远不取值出来，只在map里对值进行操作。（以_开头的值是私有值，不对外公布。）</p>
<p>总结：</p>
<ul>
<li>函数式编程的运算不直接操作值，而是由函子完成。</li>
<li>函子就是一个实现了map契约的对象</li>
<li>我们可以把函子想象成一个盒子，这个盒子里封装了一个值</li>
<li>想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值的函数（纯函数)，由这个函数来对值进行处理</li>
<li>最终map方法返回一个包含新值的盒子(函子)</li>
</ul>
<p><strong>maybe函子</strong><br>maybe函子为了避免函子传入空值（null/undefined）情况的发生，它作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）</p>
<p><strong>either函子</strong><br> 异常会让函数变的不纯，通过either函子去处理异常，可以记录错误信息。类似于 if…else…的处理。</p>
<p><strong>IO函子</strong><br>IO函子中的_value是一个函数，这里把函数当做值来处理。IO函子把不纯的操作存储到_value中交给调用者去处理，延迟不纯的操作，包装当前的纯操作。缺点是嵌套函子很不方便。</p>
<p><strong>task函子</strong><br>task用于解决异步任务，和promise非常像，返回方法是resolver.resolve、resolver.reject，调用方法有.run()、.listen({onRejected/onResolved)}等。</p>
<blockquote>
<p>folktale是一个标准的函数式编程库，和lodash、ramda不同的是，他没有提供很多功能函数，只提供了一些函数式处理的操作，例如: compose、curry等，一些函子Task、Either、MayBe等<br>folktale的基本使用<a href="https://folktale.origamitower.com/">https://folktale.origamitower.com/</a></p>
</blockquote>
<p><strong>pointed函子</strong><br>pointed函子只是一个概念而已，是实现了 of 静态方法的函子</p>
<p><strong>monad函子</strong><br>monad函子是可以变扁的pointed函子，一个函子如果具有join和of两个方法并遵守一些定律就是一个monad。</p>
<ul>
<li>处理值用map</li>
<li>处理函数用flatMap</li>
</ul>
<h4 id="函数式编程总结"><a href="#函数式编程总结" class="headerlink" title="函数式编程总结"></a>函数式编程总结</h4><p>1，可读性强：声明式(Declarative)使得代码即使没有注释也有很高的可读性(这也是 React 的一大卖点)。<br>2，代码量少：项目越大，越节省代码量(大量的函数被复用)。<br>3，代码稳定可靠：纯函数的功劳。<br>4，容易维护性：符合「单一职能原则」，使得代码的维护与迭代更加容易。</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>函子</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个gulp模块并封装成cli</title>
    <url>/2021/06/07/gulp/</url>
    <content><![CDATA[<h4 id="一个简单的gulp案例"><a href="#一个简单的gulp案例" class="headerlink" title="一个简单的gulp案例"></a>一个简单的gulp案例</h4><p>接下来我们通过一个实际的案例, 来看如何使用gulp完成一个网页应用自动化构建工作流<br>首先拿到一个需要构建的项目, 打开项目<br>打开项目: code pages-boilerplate<br>安装gulp: yarn add gulp –dev<br>新建gulpfile.js文件<br>导入gulp的api</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>注意: public下是不需要构建加工的文件，src是开发阶段的代码 都需要构建，sass es6都需要构建 图片需要压缩</p>
<h5 id="样式的编译"><a href="#样式的编译" class="headerlink" title="样式的编译"></a>样式的编译</h5><p>定义一个style, 然后导出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> style = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/styles/*.scss&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span>&#125;) <span class="comment">//base校准保存路径</span></span><br><span class="line">    .pipe(dest(<span class="string">&#x27;temp&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    style,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yarn gulp style  经过测试可以打包成功</p>
<p>安装转换流: yarn add gulp-sass –dev（内部会安装node-sass）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">&#x27;gulp-sass&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>使用转换: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> style = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/styles/*.scss&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span>&#125;)</span><br><span class="line">    .pipe(sass(&#123; <span class="attr">outputstyle</span>: <span class="string">&#x27;expanded&#x27;</span>&#125;))<span class="comment">//完全展开的形式</span></span><br><span class="line">    .pipe(dest(<span class="string">&#x27;temp&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yarn gulp style  经过测试可以打包成功</p>
<blockquote>
<p>注意: sass会认为_开头的文件是被引用的文件 所以不会进行转换<br> sass({ outputstyle: ‘expanded’}) 是完全展开的格式, 否则 } 会在 ；后面 而不是另起一行, 如<br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.icon-aperture:before &#123;</span><br><span class="line"> <span class="attr">content</span>: <span class="string">&#x27;\e900&#x27;</span>; &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="脚本的编译"><a href="#脚本的编译" class="headerlink" title="脚本的编译"></a>脚本的编译</h5><p>定义一个script 然后导出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> script = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/scripts/*.js&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span>&#125;)</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;temp&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    script,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>安装babel环境: yarn add gulp-babel –dev<br>安装转换流: yarn add @babel/core @babel/preset-env –dev</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;gulp-babel&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> script = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/scripts/*.js&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span>&#125;)</span><br><span class="line">    .pipe(babel(&#123; <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>] &#125;))</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;temp&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>里面这句话不要丢, babel只是一个平台不做转换, presets才是插件, 是新特性的一个整体的打包, s使用它来做转换, 如果不写这句话输出的文件几乎不会变格式</p>
</blockquote>
<p>yarn gulp script</p>
<h5 id="模板文件的编译"><a href="#模板文件的编译" class="headerlink" title="模板文件的编译"></a>模板文件的编译</h5><p>定义一个page, 然后导出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> page = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/**/*.html&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span>&#125;) </span><br><span class="line">    .pipe(dest(<span class="string">&#x27;temp&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    page</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>安装转换流: yarn add gulp-swig –dev</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> swig = <span class="built_in">require</span>(<span class="string">&#x27;gulp-swig&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> page = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/**/*.html&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span>&#125;) <span class="comment">// 通配符可以这样写 &#x27;src/** / * .html&#x27;</span></span><br><span class="line">    .pipe(swig())</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;temp&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把数据部分的数组放在data中导入，或使用json文件式导入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  <span class="attr">menus</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">      <span class="attr">icon</span>: <span class="string">&#x27;aperture&#x27;</span>,</span><br><span class="line">      <span class="attr">link</span>: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Features&#x27;</span>,</span><br><span class="line">      <span class="attr">link</span>: <span class="string">&#x27;features.html&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">      <span class="attr">link</span>: <span class="string">&#x27;about.html&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Contact&#x27;</span>,</span><br><span class="line">      <span class="attr">link</span>: <span class="string">&#x27;#&#x27;</span>,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;Twitter&#x27;</span>,</span><br><span class="line">          <span class="attr">link</span>: <span class="string">&#x27;https://twitter.com/w_zce&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">          <span class="attr">link</span>: <span class="string">&#x27;https://weibo.com/zceme&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;divider&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">          <span class="attr">link</span>: <span class="string">&#x27;https://github.com/zce&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">pkg</span>: <span class="built_in">require</span>(<span class="string">&#x27;./package.json&#x27;</span>),</span><br><span class="line">  <span class="attr">date</span>: <span class="keyword">new</span> </span><br><span class="line">  <span class="built_in">Date</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> page = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/**/*.html&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span>&#125;)</span><br><span class="line">    .pipe(plugins.swig(&#123; data &#125;))</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;temp&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yarn gulp page</p>
<h5 id="组合任务"><a href="#组合任务" class="headerlink" title="组合任务"></a>组合任务</h5><p>因为三者没有任何牵连所以使用并行任务<br>引入parallel模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest, parallel, series, watch &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> compile = parallel(style, script, page)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    compile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yarn gulp compile 完成并行组合任务</p>
<h5 id="图片和字体文件的处理"><a href="#图片和字体文件的处理" class="headerlink" title="图片和字体文件的处理"></a>图片和字体文件的处理</h5><p>安装依赖: yarn add gulp-imagemin –dev(c++模块下载二进制集会比较慢）<br>这个插件可以处理图片和字体文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> imagemin = <span class="built_in">require</span>(<span class="string">&#x27;gulp-imagemin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> image = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/images/**&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span>&#125;)</span><br><span class="line">    .pipe(imagemin())</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;temp&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> font = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/fonts/**&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span>&#125;)</span><br><span class="line">    .pipe(imagemin())</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;temp&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    image,</span><br><span class="line">    font,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yarn gulp image<br>yarn gulp font</p>
<h5 id="其他文件以及文件清除"><a href="#其他文件以及文件清除" class="headerlink" title="其他文件以及文件清除"></a>其他文件以及文件清除</h5><p>其他文件就直接拷贝, 如不需要压缩的public文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pub = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;public/**&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;public&#x27;</span>&#125;)</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;temp&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清除原有的temp文件<br>安装依赖: yarn add del –dev(他不是gulp下的插件, 只不过是可以使用, 是个promise方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> del = <span class="built_in">require</span>(<span class="string">&#x27;del&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clean = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> del([<span class="string">&#x27;temp&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后和build串行, 确保先删除后添加temp文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> build = series(clean, parallel(compile, pub))</span><br></pre></td></tr></table></figure>


<h5 id="自动加载插件"><a href="#自动加载插件" class="headerlink" title="自动加载插件"></a>自动加载插件</h5><p>通过插件自动加载插件（禁止套娃喂）<br>安装依赖: yarn add gulp-load-plugins –dev</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// const sass = require(&#x27;gulp-sass&#x27;)</span></span><br><span class="line"><span class="comment">// const babel = require(&#x27;gulp-babel&#x27;)</span></span><br><span class="line"><span class="comment">// const swig = require(&#x27;gulp-swig&#x27;)</span></span><br><span class="line"><span class="comment">// const imagemin = require(&#x27;gulp-imagemin&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loadPlugins = <span class="built_in">require</span>(<span class="string">&#x27;gulp-load-plugins&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> plugins = loadPlugins()</span><br></pre></td></tr></table></figure>
<p>此时我们已经不需要引入一些插件了, 将下面的插件名都更换为plugins.xxx 如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.pipe(plugins.swig())</span><br></pre></td></tr></table></figure>


<h5 id="热更新开发服务器"><a href="#热更新开发服务器" class="headerlink" title="热更新开发服务器"></a>热更新开发服务器</h5><p>热更新开发服务器用于去在开发阶段调试应用, 我们可以通过gulp去启动和管理这个服务器, 实现在代码修改过后能自动编译, 刷新页面, 这样可以大大效率<br>这个模块给我提供了一个服务器, 功能比较强大, 支持我们修改代码过后自动更新到浏览器查看效果, 它不是gulp的插件, 只不过是通过gulp管理而已</p>
<p>安装依赖: yarn add browser-sync –dev</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> browserSync = <span class="built_in">require</span>(<span class="string">&#x27;browser-sync&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bs = browserSync.create()</span><br></pre></td></tr></table></figure>
<p>创建一个服务器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onst serve = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  bs.init(&#123;</span><br><span class="line">    <span class="attr">notify</span>: <span class="literal">false</span>, <span class="comment">//控制浏览器刚打开时 右上角的小提示</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">2080</span>, <span class="comment">//端口</span></span><br><span class="line">    <span class="comment">// open: false,  //false不自动打开浏览器</span></span><br><span class="line">    <span class="comment">// files: &#x27;dist/**&#x27;,  //字符串 被监听的文件路径</span></span><br><span class="line">    <span class="attr">server</span>: &#123;</span><br><span class="line">      <span class="attr">baseDir</span>: [<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;public&#x27;</span>],</span><br><span class="line">      <span class="attr">routes</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;/node_modules&#x27;</span>: <span class="string">&#x27;node_modules&#x27;</span> <span class="comment">//配置路由便于查找html中没有转换的地址</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>yarn gulp serve</p>
<h5 id="监听src变化以及构建过程优化"><a href="#监听src变化以及构建过程优化" class="headerlink" title="监听src变化以及构建过程优化"></a>监听src变化以及构建过程优化</h5><p>引入watch模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest, parallel, series, watch &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serve = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  watch(<span class="string">&#x27;src/assets/styles/*.scss&#x27;</span>, style) <span class="comment">//监听, 有变化就执行后面的任务</span></span><br><span class="line">  watch(<span class="string">&#x27;src/assets/scripts/*.js&#x27;</span>, script)</span><br><span class="line">  watch(<span class="string">&#x27;src/*.html&#x27;</span>, page)</span><br><span class="line">  watch(<span class="string">&#x27;src/assets/images/**&#x27;</span>, image)</span><br><span class="line">  watch(<span class="string">&#x27;src/assets/fonts/**&#x27;</span>, font)</span><br><span class="line">  watch(<span class="string">&#x27;public/**&#x27;</span>, extra)</span><br><span class="line"></span><br><span class="line">  bs.init(&#123;</span><br><span class="line">    <span class="attr">notify</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">2080</span>,</span><br><span class="line">    <span class="attr">server</span>: &#123;</span><br><span class="line">      <span class="attr">baseDir</span>: [<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;public&#x27;</span>],</span><br><span class="line">      <span class="attr">routes</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;/node_modules&#x27;</span>: <span class="string">&#x27;node_modules&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>yarn gulp serve</p>
<blockquote>
<p>这里可能会因为swig模板引擎缓存的机制导致页面不会变化<br>此时需要额外将swig 选项中的cache设置为false<br>具体参考源代码72行</p>
</blockquote>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>图片字体和不变的文件, 在开发阶段不需要一直重构, 会影响效率, 同事删除并行任务中的图片和字体</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   watch(&#x27;src/assets/images/**&#x27;, image)</span></span><br><span class="line"><span class="comment">//   watch(&#x27;src/assets/fonts/**&#x27;, font)</span></span><br><span class="line"><span class="comment">//   watch(&#x27;public/**&#x27;, extra)</span></span><br></pre></td></tr></table></figure>

<p>但是如果图片字体文件发生变化也要监视到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch([</span><br><span class="line">  <span class="string">&#x27;src/assets/images/**&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;src/assets/fonts/**&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;public/**&#x27;</span></span><br><span class="line">], bs.reload)</span><br></pre></td></tr></table></figure>
<p>如果给pipe加上reload, 就不需要bs中的files监视了, 如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> page = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/**/*.html&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span>&#125;)</span><br><span class="line">    .pipe(plugins.swig(&#123; data &#125;))</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;temp&#x27;</span>))</span><br><span class="line">    .pipe(bs.reload(&#123; <span class="attr">stream</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="useref文件引用处理"><a href="#useref文件引用处理" class="headerlink" title="useref文件引用处理"></a>useref文件引用处理</h5><p>会自动创建构建注释来处理, 会将路径中的文件打包到某文件中<br>安装依赖: yarn add gulp-useref –dev<br>这里的src接口针对的是temp路径下的文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useref = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">&#x27;temp/*.html&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;temp&#x27;</span> &#125;)</span><br><span class="line">    .pipe(plugins.useref(&#123; <span class="attr">searchPath</span>: [<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;.&#x27;</span>] &#125;))</span><br><span class="line">    <span class="comment">// html js css</span></span><br><span class="line">    .pipe(plugins.if(<span class="regexp">/\.js$/</span>, plugins.uglify()))</span><br><span class="line">    .pipe(plugins.if(<span class="regexp">/\.css$/</span>, plugins.cleanCss()))</span><br><span class="line">    .pipe(plugins.if(<span class="regexp">/\.html$/</span>, plugins.htmlmin(&#123;</span><br><span class="line">      <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">minifyCSS</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">minifyJS</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)))</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后对html css js进行压缩<br>安装依赖: yarn add gulp-htmlmin gulp-uglify gulp-clean-css –dev</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useref = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">&#x27;temp/*.html&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;temp&#x27;</span> &#125;)</span><br><span class="line">    .pipe(plugins.useref(&#123; <span class="attr">searchPath</span>: [<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;.&#x27;</span>] &#125;))</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断是什么文件, 来决定后续的操作<br>安装判断依赖: yarn add gulp-if –dev</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.pipe(plugins.if(<span class="regexp">/\.js$/</span>, plugins.uglify()))</span><br><span class="line">.pipe(plugins.if(<span class="regexp">/\.css$/</span>, plugins.cleanCss()))</span><br><span class="line">.pipe(plugins.if(<span class="regexp">/\.html$/</span>, plugins.htmlmin(&#123;</span><br><span class="line">  <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">minifyCSS</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">minifyJS</span>: <span class="literal">true</span></span><br><span class="line">&#125;))) <span class="comment">//这里是处理html的空白字符 还可以删除空属性 移除注释等 需要自己扩展</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果文件中没有注释, 就useref不成功, 因为useref过后会删除注释，所以第二次需要注意, 先compile再useref, 输入流和输出流不应在同一个目录下</p>
</blockquote>
<p>因为useref需要转换到别的文件夹  所以前面所有的转换（除字体图片等）先转换到temp 再useref到dist</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> build = series(clean, parallel(series(compile, useref), extra, image, font))</span><br></pre></td></tr></table></figure>

<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p>构建任务完成后, 需要好好写导出, 让人理解<br>需要放在package.json的scripts里<br>需要在.gitignore中忽略temp dist文件</p>
<h4 id="封装gulp"><a href="#封装gulp" class="headerlink" title="封装gulp"></a>封装gulp</h4><p>提取一个可复用的自动化构建工作流, 就是创建一个模块, 发布到仓库, 再使用就可以了</p>
<!-- yarn global add zce-cli
zce init nm zce-pages
cd zce-pages
创建一个git仓库
新建一个文件（可以使用脚手架）
git init
git remote add origin https://xxxx.git
git push -->

<p>这里就使用我们刚刚建立的简单的gulp</p>
<p>新建一个项目/仓库<br>提取gulp<br>code . -a(扩展一下）<br>将上面项目的gulpfile中的内容复制给index.js入口文件<br>将原项目中一大串依赖复制过来package.json中的dependencies中, 然后执行 yarn（这个是install）</p>
<p>回到原项目中把gulpfile清空, 删除node-modules 和 package中的devDepandencies, 这时他就是一个干净的项目了<br>执行 yarn link 和 yarn link “你的模块名字”, 在 gulpfile 中写入导入文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">&#x27;你的模块名字&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>执行 yarn (安装生产依赖）, 安装gulp-cli gulp, 并启动 yarn build, 开始排错</p>
<p><strong>提取index中的data</strong><br>模块中新建pages.config.js来抽象一些不该被集成的东西, 如原项目中的data, 把数据放在这里面这个文件中<br>模块中修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  <span class="comment">// default config</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> loadConfig = <span class="built_in">require</span>(<span class="string">`<span class="subst">$&#123;cwd&#125;</span>/pages.config.js`</span>)</span><br><span class="line">  config = <span class="built_in">Object</span>.assign(&#123;&#125;, config, loadConfig)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    <span class="comment">//使用data的地方也要修改</span></span><br><span class="line">    .pipe(plugins.swig(&#123; <span class="attr">data</span>: config.data, <span class="attr">defaults</span>: &#123; <span class="attr">cache</span>: <span class="literal">false</span> &#125; &#125;))</span><br><span class="line">    <span class="comment">//找不到依赖时也可以这样引入</span></span><br><span class="line">    .pipe(plugins.babel(&#123; <span class="attr">presets</span>: [<span class="built_in">require</span>(<span class="string">&#x27;@babel/preset-env&#x27;</span>)] &#125;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>yarn build可以成功, 基本完成</p>
<p><strong>抽象路径配置</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">  <span class="comment">// default config</span></span><br><span class="line">  <span class="comment">//这个build也要复制到配置文件pages.config.js一份</span></span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">src</span>: <span class="string">&#x27;src&#x27;</span>,</span><br><span class="line">    <span class="attr">dist</span>: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">    <span class="attr">temp</span>: <span class="string">&#x27;temp&#x27;</span>,</span><br><span class="line">    <span class="attr">public</span>: <span class="string">&#x27;public&#x27;</span>,</span><br><span class="line">    <span class="attr">paths</span>: &#123;</span><br><span class="line">      <span class="attr">styles</span>: <span class="string">&#x27;assets/styles/*.scss&#x27;</span>,</span><br><span class="line">      <span class="attr">scripts</span>: <span class="string">&#x27;assets/scripts/*.js&#x27;</span>,</span><br><span class="line">      <span class="attr">pages</span>: <span class="string">&#x27;*.html&#x27;</span>,</span><br><span class="line">      <span class="attr">images</span>: <span class="string">&#x27;assets/images/**&#x27;</span>,</span><br><span class="line">      <span class="attr">fonts</span>: <span class="string">&#x27;assets/fonts/**&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//下面的路径全都修改为这种</span></span><br><span class="line">    .pipe(dest(config.build.temp))</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>包装gulp cli, 就可以删除gulpfile了</p>
<p>在bin下的js中写入这些是为了提取命令行中的很长的重复部分, 这样提取之后就可以直接使用 ‘你的cli名’ build来启动了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line">process.argv.push(<span class="string">&#x27;--cwd&#x27;</span>)</span><br><span class="line">process.argv.push(process.cwd())</span><br><span class="line">process.argv.push(<span class="string">&#x27;--gulpfile&#x27;</span>)</span><br><span class="line">process.argv.push(<span class="built_in">require</span>.resolve(<span class="string">&#x27;..&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;gulp/bin/gulp&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>要在packsge.json中记得引入这个文件作为cli的入口文件: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;bin&quot;</span>: <span class="string">&quot;bin/你的文件名.js&quot;</span>,</span><br><span class="line"><span class="string">&quot;files&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;lib&quot;</span>,</span><br><span class="line">  <span class="string">&quot;bin&quot;</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p><strong>发布并使用模块</strong><br>发布<br>首先使用git提交代码,<br>执行yarn publish 时, 淘宝镜像源是只读的所以publish不上去, 可以使用原镜像</p>
<blockquote>
<p>yarn publish –registry<a href="https://registry.yarnpkg.com/">https://registry.yarnpkg.com</a></p>
</blockquote>
<p>使用<br>先新建一个空项目<br>yarn add zce-pages –dev</p>
<p>yarn zce-pages build, 可以看到package中已有这些cli</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;clean&quot;</span>: <span class="string">&quot;zce-pages clean&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;zce-pages build&quot;</span>,</span><br><span class="line">  <span class="string">&quot;develop&quot;</span>: <span class="string">&quot;zce-pages develop&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注: 官方镜像同步到淘宝镜像是有时间差的, 不要publish完马上就去下载, 可以先去官网查看版本</p>
</blockquote>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>gulp</tag>
        <tag>自动化构建案例</tag>
      </tags>
  </entry>
  <entry>
    <title>潮汐</title>
    <url>/2021/05/26/heis/</url>
    <content><![CDATA[<p>路很长,</p>
<p>走着走着,总能遇到一个和你相似的人.</p>
<p>你们兴趣相近,有着共同的爱好,</p>
<p>一个眼神,一个动作,就知道对方想要做什么.</p>
<p>一个人时,也不会枯燥,两个人呢,也不会觉得吵.</p>
<p>好像他就该在那里,若他不在,那就插一束花,等着他来.</p>
<p><img src="/2021/05/26/heis/WechatIMG13.jpeg" alt="恩"></p>
]]></content>
      <categories>
        <category>和潮汐一样可靠</category>
      </categories>
      <tags>
        <tag>潮汐</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化</title>
    <url>/2022/01/15/mkh/</url>
    <content><![CDATA[<h4 id="模块打包工具由来"><a href="#模块打包工具由来" class="headerlink" title="模块打包工具由来"></a>模块打包工具由来</h4><p>由于 ES Modules 存在环境兼容问题, 又模块文件较多, 网络请求比较频繁, 前端资源都需要模块化<br>新特性代码编译, 编译就是把es6编译成es5, 然后打包, 模块化JavaScript打包, 支持不同类型的资源模块</p>
<p>打包工具：解决的不只是js的模块化，而是前端整体的模块化</p>
<ul>
<li>webpack 模块加载器  代码拆分 资源模块</li>
<li>rollup</li>
<li>parcel</li>
</ul>
<h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><p><strong>webpack的基本使用</strong><br>webpack比较先进, 非常受欢迎</p>
<blockquote>
<p>yarn init --yes<br>yarn add webpack webpack-cli --dev<br>yarn webpack --version<br>yarn webpack (会从index.js开始打包</p>
</blockquote>
<p><strong>配置文件</strong><br>支持0配置<br>一般来说会将 src/index.js 作为打包入口, 将结果存入 dist/main.js 中, 但是也可以自己在 webpack.config.js 中设置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>, <span class="comment">//设置输入</span></span><br><span class="line">    <span class="attr">output</span>: &#123; <span class="comment">//设置输出</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;output&#x27;</span>) <span class="comment">//必须是绝对路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打包模式</strong><br>使用cli设置打包模式 </p>
<blockquote>
<p>yarn webpack --mode development //优化速度模式<br>yarn webpack --mode none //普通模式</p>
</blockquote>
<p><strong>资源模块加载</strong><br>webpack内部默认只会打包js文件, 如果打包css需要安装loader来操作, webpack可将任何资源模块导入js一起打包</p>
<blockquote>
<p>yarn add css-loader --dev //来打包<br>yarn add style-loader --dev //来调用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line"><span class="attr">rules</span>: [ <span class="comment">//加载规则</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            <span class="string">&#x27;style-loader&#x27;</span>, <span class="comment">//会从后往前执行</span></span><br><span class="line">            <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>文件资源加载器</strong></p>
<blockquote>
<p>yarn add file-loader --dev //文件操作</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">publicPath: <span class="string">&#x27;dist/&#x27;</span> <span class="comment">//output</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">//rules</span></span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/.png$/</span>,</span><br><span class="line">    use: <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>data url</strong></p>
<blockquote>
<p>yarn add url-loader --dev //路径操作</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="comment">//rules</span></span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/.png$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">limit</span>: <span class="number">10</span> * <span class="number">1024</span> <span class="comment">// 10 KB</span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小文件可以使用 Data URLs，可以减少请求次数, 大文件尽量单独提取存放, 可以提高加载速度</p>
<blockquote>
<p>常用加载器分类<br>编译转换类<br>文件操作类<br>代码检查类</p>
</blockquote>
<p><strong>处理es6</strong><br>因为模块打包需要，所以处理 import 和 export</p>
<blockquote>
<p>yarn add babel-loader @babel/core @babel/preset-env --dev</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="comment">//rules</span></span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/.js$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>Webpack只是打包工具, 加载器可以用来编译转换代码</p>
<p>兼容的模块加载方式有 import , require , define , 但是不要一个项目里写这么多种</p>
<p><strong>html-loader</strong><br>默认只会处理img中的src属性, 所以处理options</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/.html$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;html-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">attrs</span>: [<span class="string">&#x27;img:src&#x27;</span>, <span class="string">&#x27;a:href&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Webpack模块加载方式</strong><br>·遵循ES Modules标准的import声明<br>·遵循CommonJS标准的require函数<br>·遵循AMD标准的define函数和require函数<br>·样式代码中的@import指令和url函数。<br>·HTML代码中图片标签的src属性</p>
<p><strong>核心工作原理</strong><br>根据打包入口, 分析模块, 递归依赖树, 解析模块, 把结果放入bundle.js<br>Loader的机制是Webpack的核心</p>
<h5 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h5><p><strong>Loader工作原理</strong><br>例如我们可以自己编写一个markdown文件的Loader<br>创建markdown-loader.js<br>export 一个函数, 返回结果必须是js代码<br>rules引用<br>安装marked模块解析<br>yarn add marked --dev<br>可以自己处理成js返回<br>或html-loader来处理</p>
<p>Loader负责资源文件从输入到输出的转换, 它其实是一个管道的概念, 可以拼接使用</p>
<p><strong>插件机制</strong><br>plugin来解决除资源加载外, 其他自动化工作, 如清除, 拷贝, 压缩</p>
<blockquote>
<p>yarn add clean-webpack-plugin --dev //清理<br>yarn add html-webpack-plugin --dev //生成html<br>yarn add copy-webpack-plugin --dev //不编译直接复制过去</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意删除publicpath</span></span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>) <span class="comment">//解构</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;copy-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.ProgressPlugin(),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="comment">//用于生成index.html</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        title</span><br><span class="line">        meta</span><br><span class="line">        template</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//用于生成iabout.html</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;about.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">        <span class="comment">// &#x27;public/**&#x27; 路径 通配符</span></span><br><span class="line">        <span class="string">&#x27;public&#x27;</span></span><br><span class="line">    ])</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<h5 id="开发一个插件"><a href="#开发一个插件" class="headerlink" title="开发一个插件"></a>开发一个插件</h5><p>Plugin通过钩子机制实现<br>插件必须一个函数或者是一个包含apply方法的对象，所以一般是新建一个class，然后在class里构建一个apply方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> </span>&#123;</span><br><span class="line">    apply (compiler) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;MyPlugin 启动&#x27;</span>)</span><br><span class="line">        compiler.hooks.emit.tap(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// compilation =&gt; 可以理解为此次打包的上下文</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> compilation.assets) &#123;</span><br><span class="line">        <span class="comment">// console.log(name)</span></span><br><span class="line">        <span class="comment">// console.log(compilation.assets[name].source())</span></span><br><span class="line">        <span class="keyword">if</span> (name.endsWith(<span class="string">&#x27;.js&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> contents = compilation.assets[name].source()</span><br><span class="line">        <span class="keyword">const</span> withoutComments = contents.replace(<span class="regexp">/\/\*\*+\*\//g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        compilation.assets[name] = &#123;</span><br><span class="line">        <span class="attr">source</span>: <span class="function">() =&gt;</span> withoutComments,</span><br><span class="line">        <span class="attr">size</span>: <span class="function">() =&gt;</span> withoutComments.length</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>plugins中调用 new MyPlugin()<br>插件是通过在生命周期的钩子中挂载函数实现扩展</p>
<p><strong>如何增强webpack开发体验</strong></p>
<blockquote>
<p>yarn webpack --watch //实现自动编译 -- watch监听<br>自动刷新浏览器, 如果用browersync启动再监听, 会比较麻烦, 所以用 webpack-dev-server, 需注意该命令没有自动打包<br>yarn add webpack-dev-server --dev //是个cli<br>yarn webpack-dev-server --open //自动打开浏览器<br>注意: webpack-dev-server 访问静态资源需另外配置devServer</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: <span class="string">&#x27;./public&#x27;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>webpack-dev-server 支持代理配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">    <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">    <span class="comment">// http://localhost:8080/api/users -&gt; https://api.github.com/api/users</span></span><br><span class="line">    <span class="attr">target</span>: <span class="string">&#x27;https://api.github.com&#x27;</span>,</span><br><span class="line">    <span class="comment">// http://localhost:8080/api/users -&gt; https://api.github.com/users</span></span><br><span class="line">    <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 不能使用 localhost:8080 作为请求 GitHub 的主机名</span></span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Source Map (.map后缀名）</strong><br>靠在结尾添加注释来引入Source Map, Source Map解决了源代码与运行代码不一致所产生的问题, webpack也可以通过配置属性devtool生成.map文件 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devtool: <span class="string">&#x27;source-map&#x27;</span>,</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/15/mkh/1623729629215.jpg" alt="1623729629215.jpg"><br>选择合适的source-map<br>开发环境选择c-m-e-s-m<br>我的代码每行不会超过80个字符<br>我的代码经过 Loader转换过后的差异较大<br>首次打包速度慢无所谓，重写打包相对较快</p>
<p>生产模式选择none, 因为source map会暴露源代码, 毕竟调试是开发阶段的事, 如果没有信心就nosources-s-m</p>
<p><strong>开启hmr热更新</strong><br>自动刷新导致的页面状态丢失<br>HMR 热更新体验非常友好<br>HMR是Webpack中最强大的功能之一<br>极大程度的提高了开发者的工作效率</p>
<p>hmr已经集成在 webpack-dev-server中 不需要安装</p>
<blockquote>
<p>yarn webpack-dev-server --hot //使用命令行或通过配置开启</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// hotOnly: true // 只使用 HMR，不会 fallback 到 live reloading</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这样只能自动更新样式, 而样式是因为style-loader来操作的, hmr没有通用的js替换方案<br>hmr注意事项</p>
<p>生产环境优化 不同环境下的配置<br>1.配置文件根据环境不同导出不同配置 （适用于中小型项目）<br>2.一个环境对应一个配置文件 yarn add webpack-merge</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --config webpack.prod.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>内置插件 definePlugin 可以为代码注入一些可能会变化的值 如api</p>
<p><strong>tree-shaking</strong><br>摇掉未引用代码, 会在生产模式下自动开启, 使用如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    <span class="comment">// 模块只导出被使用的成员 导出 但不引用（标记枯树枝）</span></span><br><span class="line">    <span class="attr">usedExports</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 尽可能合并每一个模块到一个函数中 （作用域提升）</span></span><br><span class="line">    <span class="attr">concatenateModules</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 压缩输出结果 删除未引用成员 （摇掉枯树枝）</span></span><br><span class="line">    <span class="comment">// minimize: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tree-shaking 的前提是必须使用 ES Modules 的代码, 最新版本的babel不会导致树摇失效, 如果不确定就写入这些↓</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">    <span class="attr">presets</span>: [</span><br><span class="line">    <span class="comment">// 如果 Babel 加载模块时已经转换了 ESM，则会导致 Tree Shaking 失效</span></span><br><span class="line">    <span class="comment">// [&#x27;@babel/preset-env&#x27;, &#123; modules: &#x27;commonjs&#x27; &#125;]</span></span><br><span class="line">    <span class="comment">// [&#x27;@babel/preset-env&#x27;, &#123; modules: false &#125;]</span></span><br><span class="line">    <span class="comment">// 也可以使用默认配置，也就是 auto，这样 babel-loader 会自动关闭 ESM 转换</span></span><br><span class="line">    [<span class="string">&#x27;@babel/preset-env&#x27;</span>, &#123; <span class="attr">modules</span>: <span class="string">&#x27;false&#x27;</span> &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sideEffects</strong><br>标记副作用, 生产环境自动开启</p>
<p><strong>代码分割</strong><br>代码分割就是分包, 如果bundle体积过大会浪费流量和带宽, 但分割时资源不要太大也不要太碎</p>
<p><strong>多入口打包</strong><br>适用于多页面程序, 把entry改成对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">album</span>: <span class="string">&#x27;./src/album.js&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].bundle.js&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">        <span class="comment">// 自动提取所有公共模块到单独 bundle</span></span><br><span class="line">        <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Multi Entry&#x27;</span>,</span><br><span class="line">        <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">        <span class="attr">chunks</span>: [<span class="string">&#x27;index&#x27;</span>]</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Multi Entry&#x27;</span>,</span><br><span class="line">        <span class="attr">template</span>: <span class="string">&#x27;./src/album.html&#x27;</span>,</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;album.html&#x27;</span>,</span><br><span class="line">        <span class="attr">chunks</span>: [<span class="string">&#x27;album&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>动态导入</strong><br>动态导入的模块会被自动分包, 是按需加载的, 如果是vue或者react单页面开发的话, 就可以在路由映射组件实现这种按需加载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import posts from &#x27;./posts/posts&#x27; 不再用这种方式导入</span></span><br><span class="line"><span class="comment">// import album from &#x27;./album/album&#x27;</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> hash = <span class="built_in">window</span>.location.hash || <span class="string">&#x27;#posts&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> mainElement = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.main&#x27;</span>)</span><br><span class="line">    mainElement.innerHTML = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (hash === <span class="string">&#x27;#posts&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// mainElement.appendChild(posts()) </span></span><br><span class="line">        <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;components&#x27; */</span><span class="string">&#x27;./posts/posts&#x27;</span>).then(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: posts &#125;</span>) =&gt;</span> &#123; <span class="comment">//魔法注释</span></span><br><span class="line">        mainElement.appendChild(posts())</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hash === <span class="string">&#x27;#album&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// mainElement.appendChild(album())</span></span><br><span class="line">        <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;components&#x27; */</span><span class="string">&#x27;./album/album&#x27;</span>).then(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: album &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        mainElement.appendChild(album())</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提取css到单个文件</strong><br>超过150kb才会考虑单独提取</p>
<blockquote>
<p>yarn add mini-css-extract-plugin --dev<br>yarn add optimize-css-assets-webpack-plugin --dev</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> TerserWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">        <span class="keyword">new</span> TerserWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> OptimizeCssAssetsWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            <span class="comment">// &#x27;style-loader&#x27;, // 将样式通过 style 标签注入</span></span><br><span class="line">            MiniCssExtractPlugin.loader,</span><br><span class="line">            <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>输出文件名hash</strong><br>[hash] //整体hash<br>[chunkhash] //文件hash<br>[contenthash:8] //hash位数</p>
<h4 id="rollup"><a href="#rollup" class="headerlink" title="rollup"></a>rollup</h4><p>rollup 也是 ES Modules 的打包器, 但仅仅是ES Modules打包器. 与webpack非常类似, 但小巧的多, 它不支持hmr这种高级功能, 会默认开启树摇</p>
<blockquote>
<p>yarn add rollup --dev  //可以提供一个cli<br>yarn rollup ./src/index.js --format iife(自调用函数） --file dist/bundle.js</p>
</blockquote>
<p><strong>配置文件</strong><br>rollup.config.js , 导出的是一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">input</span>: <span class="string">&#x27;src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">file</span>: <span class="string">&#x27;dist/bundle.js&#x27;</span>,</span><br><span class="line">        <span class="attr">format</span>: <span class="string">&#x27;iife&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yarn rollup --config //启动打包</p>
<p><strong>扩展途径</strong><br>插件是 Rollup唯一扩展途径</p>
<blockquote>
<p>yarn add rollup-plugin-json --dev</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-json&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        json() <span class="comment">//放入的是调用结果</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加载npm模块</strong></p>
<blockquote>
<p>yarn add rollup-plugin-node-resolve --dev</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-node-resolve&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        resolve()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>加载common.js</strong></p>
<blockquote>
<p>yarn add rollup-plugin-commonjs --dev</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> commonjs <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-node-resolve&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [     </span><br><span class="line">        commonjs()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码拆分</strong><br>使用的方式是动态导入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./logger&#x27;</span>).then(<span class="function">(<span class="params">&#123; log &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    log(<span class="string">&#x27;code splitting~&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">input</span>: <span class="string">&#x27;src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">// file: &#x27;dist/bundle.js&#x27;,</span></span><br><span class="line">        <span class="comment">// format: &#x27;iife&#x27;</span></span><br><span class="line">        <span class="attr">dir</span>: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">        <span class="attr">format</span>: <span class="string">&#x27;amd&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多入口打包</strong><br>公共部分会自动提取, 将input修改为数组或对象就可以了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// input: [&#x27;src/index.js&#x27;, &#x27;src/album.js&#x27;],</span></span><br><span class="line">    <span class="attr">input</span>: &#123;</span><br><span class="line">        <span class="attr">foo</span>: <span class="string">&#x27;src/index.js&#x27;</span>,</span><br><span class="line">        <span class="attr">bar</span>: <span class="string">&#x27;src/album.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">dir</span>: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">        <span class="attr">format</span>: <span class="string">&#x27;amd&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页面不能直接引用amd格式的输出文件，要用require来引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AMD 标准格式的输出 bundle 不能直接引用 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;script src=&quot;foo.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 需要 Require.js 这样的库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/requirejs@2.3.6/require.js&quot;</span> <span class="attr">data-main</span>=<span class="string">&quot;foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>rollup与webpack</strong><br>优点<br>·输出结果更加扁平<br>·自动移除未引用代码<br>·打包结果依然完全可读</p>
<p>缺点<br>·加载非 ESM的第三方模块比较复杂<br>·模块最终都被打包到一个函数中，无法实现 HMR<br>·浏览器环境中,代码拆分功能依赖AMD库</p>
<p>Webpack 大而全，Rollup 小而美<br>应用开发使用建议 Webpack<br>库/框架开发使用建议 Rollup</p>
<h4 id="parcel"><a href="#parcel" class="headerlink" title="parcel"></a>parcel</h4><p>parcel 是零配置前端应用打包器, 官方建议使用html作为打包的入口文件</p>
<blockquote>
<p>yarn add parcel-bundler --dev<br>yarn parcel src/index.html<br>yarn parcel build src/index.html</p>
</blockquote>
<p>优点:<br>打包同时会启动服务器<br>支持热特换<br>支持自动安装依赖<br>支持动态导入<br>构建速度非常快（多进程）</p>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>webpack</tag>
        <tag>rollup</tag>
        <tag>parcel</tag>
      </tags>
  </entry>
  <entry>
    <title>modules</title>
    <url>/2021/06/08/modules/</url>
    <content><![CDATA[<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>内容概要<br>·模块化演变过程<br>·模块化规范<br>·常用的模块化打包工具<br>·基于模块化工具构建现代Web应用</p>
<h5 id="演变过程"><a href="#演变过程" class="headerlink" title="演变过程"></a>演变过程</h5><p>1: 文件划分方式<br>没有私人空间<br>污染全局作用域<br>命名冲突问题<br>无法管理模块依赖关系</p>
<p>2: 命名空间方式<br>包裹全局对象中<br>私有变量不安全</p>
<p>3: lIFE<br>闭包 私有变量安全</p>
<p>以上是在早期没有工具和规范的情况下, 对模块化的落地方式</p>
<p><strong>模块化规范的出现</strong><br>模块化标准＋模块加载器</p>
<p>commonjs规范: CommonJS是以同步模式加载模块<br>·一个文件就是一个模块<br>·每个模块都有单独的作用域<br>·通过module.exports导出成员<br>·通过require函数载入模块</p>
<p>AMD (Asynchronous Module Definition) 异步模块定义规范<br>.AMD使用起来相对复杂<br>·模块JS文件请求频繁</p>
<p>require.js: 使用define定义模块, 使用require加载模块, 我理解为它和早期的angularjs很像</p>
<p>Sea.is + CMD 后被require兼容了</p>
<h5 id="模块化标准规范"><a href="#模块化标准规范" class="headerlink" title="模块化标准规范"></a>模块化标准规范</h5><p>浏览器使用ES Modules标准规范, nodejs使用commonJs标准来规范<br>ES Modules是当下最主流的规范了</p>
<p>ES Modules基本特性<br>自动采用严格模式，忽略’use strict’, 每个ES Modules模块都是单独的私有作用域, ES Modules是通过CORS去请求外部JS模块的, ES Modules的 script标签会延迟执行脚本</p>
<p><strong>导入导出</strong><br>使用export导出, 使用import导入, 使用as输出重命名, 如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    hello <span class="keyword">as</span> fooHello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意<br>虽然长得一样, 但导出的不是字面量, 导入的不是解构<br>导出的是引用关系, 不是值<br>导入的成员是只读, 不能更改</p>
</blockquote>
<p><strong>import用法</strong><br>引入不能省略后面的扩展名<br>相对路径以./开头, 绝对路径以/开头, 或者使用完整的url<br>{}为空时就只加载那个模块, 不需要引用进来<br>* as mod引入所有成员<br>不能from变量, 只能写在最上面<br>动态加载模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./module.js&#x27;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">module</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>提取默认成员</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name, age, <span class="keyword">default</span> <span class="keyword">as</span> title &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> abc, &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br></pre></td></tr></table></figure>
<p>直接导出导入的成员</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>polyfill</strong><br>IE不能兼容ES Modules, 就只能引入unpkg的js地址<br>nomodule属性只在不支持ES Modules环境中运行, 所以可以拿nomodule来引入unpkg, 否则就会在能兼容ES Modules的环境里执行两次</p>
<p><strong>node中使用ES Modules的实验</strong><br>node版本&gt;8.5就可以使用ES Modules, 需要把文件后缀的.js换成.mjs<br>使用命令&gt;node –experimental-modules index.mjs 来执行</p>
<p><strong>ES Modules与CommonJS</strong><br>ES Modules中可以导入CommonJS模块, 但CommonJS中不能导入ES Modules模块, CommonJS 始终只会导出一个默认成员</p>
<p>ES Modules与CommonJS差异</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因ES Modules没有直接获取路径的方法, 所以用以下方法获取路径</span></span><br><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&#x27;url&#x27;</span><span class="keyword">import</span> &#123; dirname &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="keyword">const</span> _filename = fileURLToPath( <span class="keyword">import</span>.meta.url)<span class="built_in">console</span>.log(__filename)</span><br><span class="line"><span class="keyword">const</span> _dirname = dirname(__filename)<span class="built_in">console</span>.log(_dirname)</span><br></pre></td></tr></table></figure>

<p>如果我们在package.json中写入type: ‘modules’ 就可以不用mjs的扩展名了, 修改回.js扩展名<br>不过这样的话, ES Modules中的CommonJS需要后缀名修改为.cjs才能运行</p>
<p>早期的node可以使用babel支持ES Modules</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;yarn add ababel/node ababel/core ababel/preset-env --dev</span><br><span class="line">&gt;yarn babel-node</span><br><span class="line">&gt;yarn babel-node index.js --presets=ababel/preset-env</span><br></pre></td></tr></table></figure>
<p>或在.babelrc 中写入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot; presets&quot;</span> : [<span class="string">&quot;@babel/preset-env&quot;</span> ]&#125;</span><br></pre></td></tr></table></figure>
<p>就可以&gt;yarn babel-node index.js执行了</p>
<p>还可以单独安装插件, 然后在 .babelrc 中引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;plugins&quot;</span>:[</span><br><span class="line">    <span class="string">&quot;@babel/plugin-transform-modules-commonjs&quot;</span><span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后&gt;yarn babel-node index.js 就可以直接执行上面那一长串命令了</p>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>modules</tag>
      </tags>
  </entry>
  <entry>
    <title>手写一个Promise的内部基本实现</title>
    <url>/2021/12/06/myPromise/</url>
    <content><![CDATA[<p>参照异步编程那篇博文我们知道，Promise 是 JS 异步编程中的重要概念，异步抽象处理对象，是目前比较流行 Javascript 异步编程解决方案之一.</p>
<p>今天我们就来尽可能还原 Promise 中的几个基本 API，并通过注释简单描述思路和原理.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Promise有三个状态,且状态为成功和失败时不可再更改,我们且定义三个常量</span></span><br><span class="line"><span class="keyword">const</span> Pending = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> Resolve = <span class="string">&#x27;fulFilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> Rejected = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行器 </span></span><br><span class="line">    <span class="comment">//promise就是一个类,在执行这个类的时候需要传递一个执行器,执行器就是传入的那个回调函数,执行器会立即执行</span></span><br><span class="line">    <span class="title">constructor</span> (<span class="params">ex</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ex(<span class="built_in">this</span>.resolve，<span class="built_in">this</span>.reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">            <span class="built_in">this</span>.reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//声明变量</span></span><br><span class="line">    status = Pending</span><br><span class="line">    value = <span class="literal">undefined</span></span><br><span class="line">    reason = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">//定义成功回调和失败回调的数组</span></span><br><span class="line">    scb = []</span><br><span class="line">    fcb = []</span><br><span class="line"></span><br><span class="line">    resolve = <span class="function"><span class="params">value</span> =&gt;</span>  &#123;</span><br><span class="line">        <span class="comment">//如果是Pending状态再继续执行 改状态 赋值等操作</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status !== Pending) <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">this</span>.status = Resolve</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="comment">// this.scb &amp;&amp; this.scb(this.value)</span></span><br><span class="line">        <span class="comment">//循环执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.scb.length) <span class="built_in">this</span>.scb.shift()()</span><br><span class="line">    &#125;</span><br><span class="line">    reject = <span class="function"><span class="params">reason</span> =&gt;</span>  &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status !== Pending) <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">this</span>.status = Rejected</span><br><span class="line">        <span class="built_in">this</span>.reason = reason</span><br><span class="line">        <span class="comment">// this.fcb &amp;&amp; this.fcb(this.reason)</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.fcb.length) <span class="built_in">this</span>.fcb.shift()()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">scb，fcb</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//处理then链式调用情况</span></span><br><span class="line">        scb = scb ? scb : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">        fcb = fcb ? fcb : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason&#125;</span><br><span class="line">        <span class="keyword">let</span> p2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve，reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//分三种状态判断</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === Resolve) &#123;</span><br><span class="line">                <span class="comment">//setTimeout为了可以异步获取p2</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        resPro(scb(<span class="built_in">this</span>.value)，resolve，reject，p2)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;，<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status === Rejected) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        resPro(fcb(<span class="built_in">this</span>.reason)，resolve，reject，p2)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;，<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.scb.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            resPro(scb(<span class="built_in">this</span>.value)，resolve，reject，p2)</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;，<span class="number">0</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="built_in">this</span>.fcb.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            resPro(fcb(<span class="built_in">this</span>.reason)，resolve，reject，p2)</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                            reject(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;，<span class="number">0</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> p2</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//如果是primose类型就直接返回, 如果是普通值就包裹一层promise返回</span></span><br><span class="line">        <span class="keyword">if</span>(value <span class="keyword">instanceof</span> myPromise) <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">arr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = []</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve，reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">i，t</span>) </span>&#123;</span><br><span class="line">                result[i] = t</span><br><span class="line">                sum++</span><br><span class="line">                <span class="keyword">if</span> (sum === arr.length) &#123;</span><br><span class="line">                    resolve(result) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">                <span class="keyword">let</span> cur = arr[i]</span><br><span class="line">                <span class="keyword">if</span> (cur <span class="keyword">instanceof</span> myPromise ) &#123;</span><br><span class="line">                    <span class="comment">//如果是promise值</span></span><br><span class="line">                    cur.then(<span class="function"><span class="params">res</span> =&gt;</span> add(i，res)，rej =&gt; reject(rej))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果是普通值</span></span><br><span class="line">                    add(i，cur)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">arr</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve，reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">addresolve</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">                sum++</span><br><span class="line">                <span class="keyword">if</span> (sum === <span class="number">1</span>) &#123;</span><br><span class="line">                    resolve(t) </span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">addreject</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">                sum++</span><br><span class="line">                <span class="keyword">if</span> (sum === <span class="number">1</span>) &#123;</span><br><span class="line">                    reject(t) </span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">                <span class="keyword">let</span> cur = arr[i]</span><br><span class="line">                <span class="keyword">if</span> (cur <span class="keyword">instanceof</span> myPromise ) &#123;</span><br><span class="line">                    <span class="comment">//promise</span></span><br><span class="line">                    cur.then(<span class="function"><span class="params">res</span> =&gt;</span> addresolve(res)，rej =&gt; addreject(rej))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//普通值</span></span><br><span class="line">                    addresolve(cur)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(fcb) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>，fcb)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">finally</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//等待cb执行完成</span></span><br><span class="line">            <span class="keyword">return</span> myPromise.resolve(cb()).then(<span class="function">() =&gt;</span> res)</span><br><span class="line">        &#125;,<span class="function"><span class="params">rej</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> myPromise.resolve(cb()).then(<span class="function">() =&gt;</span> &#123;<span class="keyword">throw</span> rej&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resPro</span>(<span class="params">x，resolve，reject，p2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果和本身一样就抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> (p2 === x) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;循环&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是promise就执行  如果不是就包一层</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise ) &#123;</span><br><span class="line">        x.then(resolve，reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面我们开始测试</p>
<p>先定义一个函数，要想创建一个 promise 对象、可以使用 new 来调用 Promise 的构造器来进行实例化.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pro = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve，reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;resolve1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise 构造函数包含一个参数和一个带有 resolve（解析）和 reject（拒绝）两个参数的回调.在回调中执行一些操作（例如异步），如果一切都正常，则调用 resolve，否则调用 reject.<br>对于已经实例化过的 promise 对象可以调用 promise.then() 方法，传递 resolve 和 reject 方法作为回调.</p>
<h5 id="测试-then-链式调用情况"><a href="#测试-then-链式调用情况" class="headerlink" title="测试.then()链式调用情况"></a>测试.then()链式调用情况</h5><p>经测试，下面代码打印结果为: resolve1<br>说明.then()方法的参数是可选的，当参数为空时，promise会把结果返回给下一个then来接收</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pro.then().then().then(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">console</span>.log(resolve)，reject =&gt; <span class="built_in">console</span>.log(reject))</span><br></pre></td></tr></table></figure>

<h5 id="测试循环调用的情况"><a href="#测试循环调用的情况" class="headerlink" title="测试循环调用的情况"></a>测试循环调用的情况</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = pro.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    <span class="keyword">return</span> p1</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;，reason =&gt; <span class="built_in">console</span>.log(reason.message))</span><br></pre></td></tr></table></figure>
<p>这一段打印结果是: resolve1 循环<br>证明我们循环调用处理的是没什么问题的</p>
<hr>
<p>为了方便测试.all()和.race()方法，我们先定义三个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve，reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">      &#125;，<span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve，reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;p2&#x27;</span>);  </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p3</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve，reject</span>) </span>&#123;</span><br><span class="line">        reject(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="all"><a href="#all" class="headerlink" title=".all()"></a>.all()</h5><p>Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 对象的实例.（Promise.all 方法的参数不一定是数组，但是必须具有 iterator 接口，且返回的每个成员都是 Promise 实例.）</p>
<p>.all()的状态分成两种情况.</p>
<ul>
<li>只有p1、p2/p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时入参的返回值组成一个数组，传递给p的回调函数.</li>
<li>只要p1、p2/p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数.</li>
</ul>
<p>此时我们测试.all()函数，运行结果为: alla,b,p1,p2,c</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myPromise.all([<span class="string">&#x27;a&#x27;</span>，<span class="string">&#x27;b&#x27;</span>，p1()，p2()，<span class="string">&#x27;c&#x27;</span>]).then( <span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;all&#x27;</span> + res),<span class="function"><span class="params">rej</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;all&#x27;</span> + rej))</span><br></pre></td></tr></table></figure>
<p>如果我们给.all加入一个失败的参数，运行结果为: all失败</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myPromise.all([<span class="string">&#x27;a&#x27;</span>，<span class="string">&#x27;b&#x27;</span>，p1()，p3()，<span class="string">&#x27;c&#x27;</span>]).then( <span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;all&#x27;</span> + res),<span class="function"><span class="params">rej</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;all&#x27;</span> + rej))</span><br></pre></td></tr></table></figure>
<p>结合测试可以证明我们.all()方法实现的是没有问题的.</p>
<h5 id="race"><a href="#race" class="headerlink" title=".race()"></a>.race()</h5><p>.race()只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理.</p>
<p>此时我们测试.race()函数，传入两个不同速度的函数的情况，运行结果为: racep2</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myPromise.race([p1()，p2()]).then( <span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;race&#x27;</span> + res),<span class="function"><span class="params">rej</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;race&#x27;</span> + rej))</span><br></pre></td></tr></table></figure>
<p>此时我们测试传入函数和常量的情况，运行结果为: racea</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myPromise.race([<span class="string">&#x27;a&#x27;</span>，p2()]).then( <span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;race&#x27;</span> + res),<span class="function"><span class="params">rej</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;race&#x27;</span> + rej))</span><br></pre></td></tr></table></figure>
<p>如果我们给.race()加入一个失败的参数，运行结果为: race失败</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myPromise.race([p1()，p3()]).then( <span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;race&#x27;</span> + res),<span class="function"><span class="params">rej</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;race&#x27;</span> + rej))</span><br></pre></td></tr></table></figure>
<p>结合测试可以证明我们.race()方法实现也是基本可以的.</p>
<h5 id="resolve"><a href="#resolve" class="headerlink" title=".resolve"></a>.resolve</h5><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用.</p>
<p>此时我们测试.resolve()函数，如果传入一个promise则返回这个promise，运行结果为: p1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myPromise.resolve(p1()).then( <span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure>
<p>如果传入一个常量则返回一个promise包裹这个常量，运行结果为: 100</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myPromise.resolve(<span class="number">100</span>).then( <span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure>

<h5 id="finally"><a href="#finally" class="headerlink" title=".finally()"></a>.finally()</h5><p>.finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作.它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行.</p>
<p>promise状态为成功的情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p2().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,<span class="function"><span class="params">rej</span>=&gt;</span><span class="built_in">console</span>.log(rej))</span><br><span class="line">.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;res&#x27;</span>)</span><br><span class="line">&#125;).</span><br></pre></td></tr></table></figure>
<p>运行结果为: p2 res</p>
<p>promise状态为失败的情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p3().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,<span class="function"><span class="params">rej</span>=&gt;</span><span class="built_in">console</span>.log(rej))</span><br><span class="line">.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;finally&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>运行结果为: 失败 res</p>
<h5 id="catch"><a href="#catch" class="headerlink" title=".catch()"></a>.catch()</h5><p>.catch()方法用于指定发生错误时的回调函数.Promise 对象的错误具有”冒泡”性质，会一直向后传递，直到被捕获为止.也就是说，错误总是会被下一个 catch 语句捕获.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p3().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">rea</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;rea&#x27;</span>+rea)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>运行结果为: rea失败</p>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化构建</title>
    <url>/2021/10/07/qdgch/</url>
    <content><![CDATA[<h4 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h4><p>自动化就是指机器代替手工去完成工作，构建可以理解为转换，自动化构建呢就是把源代码转换成生产环境中可以运行的代码或程序。这样的转换过程就叫做自动化构建工作流<br>作用就是脱离运行环境兼容带来的问题，在开发阶段使用提高效率的语法、规范和标准</p>
<p>典型的应用场景: 一些不被浏览器直接支持的用法如esNext sass 模板引擎，这时自动化构建工具就派上用场了</p>
<p>常用的自动化构建工具<br>grunt: 最早的前端构建系统，插件生态非常完善，几乎可以完成任何事，速度慢，磁盘读写操作多<br>gulp: 基于内存实现，速度较快，可以同时执行多个任务，插件系统也很完善，最流行<br>FIS: 百度团队推出，捆绑套餐，大而全, 易上手</p>
<p><strong>自动化构建初体验</strong><br>使用sass控制样式<br>安装历来: yarn add sass –dev<br>它会装在.bin目录下<br>然后运行命令时代码从输入路径转到输出路径:<br>.\node_modules.bin\sass scss/main.scss css/style.css<br>如果每次输入命令就很麻烦, 后人不知你如何操作, 所以使用npm scripts来包装命令(是实现自动化构建工作流的最简单的方式）<br>在package.json中添加scripts</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;build&quot;</span> : <span class="string">&quot;sass scss/main.scss css/style.css&quot;</span></span><br><span class="line">&#125;，</span><br></pre></td></tr></table></figure>
<p>然后yarn build(npm run build)就可以了</p>
<p>看如何操作<br>yarn add browser-sync –dev 用来启动一个测试服务器去运行项目</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;build&quot;</span> : <span class="string">&quot;sass scss/main.scss css/style.css&quot;</span>，</span><br><span class="line">    <span class="string">&quot;serve&quot;</span> : <span class="string">&quot;browser-sync .&quot;</span> <span class="comment">//（.是运行当前的目录）</span></span><br><span class="line">&#125;，</span><br></pre></td></tr></table></figure>
<p>yarn serve  此时browser-sync会自动运行服务器并唤起浏览器<br>如果在browser-sync生成之前并没有生成样式, 此时browser工作的时候就没有样式文件<br>此时就可以使用scripts的钩子命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;build&quot;</span> : <span class="string">&quot;sass scss/main.scss css/style.css&quot;</span>，</span><br><span class="line">    <span class="string">&quot;preserve&quot;</span> : <span class="string">&quot;yarn build&quot;</span>, <span class="comment">//顾名思义 会在serve之前执行</span></span><br><span class="line">    <span class="string">&quot;serve&quot;</span> : <span class="string">&quot;browser-sync .&quot;</span> </span><br><span class="line">&#125;，</span><br></pre></td></tr></table></figure>
<p>添加–watch可以监听文件的改变，改写sass保存后，css就会改变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;build&quot;</span> : <span class="string">&quot;sass scss/main.scss css/style.css --watch&quot;</span>，<span class="comment">//添加watch</span></span><br><span class="line">    <span class="string">&quot;preserve&quot;</span> : <span class="string">&quot;yarn build&quot;</span>, </span><br><span class="line">    <span class="string">&quot;serve&quot;</span> : <span class="string">&quot;browser-sync .&quot;</span> </span><br><span class="line">&#125;，</span><br></pre></td></tr></table></figure>
<p>使用npm-run-all可以同步执行不阻塞<br>yarn add npm-run-all –dev</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;build&quot;</span> : <span class="string">&quot;sass scss/main.scss css/style.css --watch&quot;</span>，</span><br><span class="line">    <span class="string">&quot;serve&quot;</span> : <span class="string">&quot;browser-sync .&quot;</span> </span><br><span class="line">    <span class="string">&quot;start&quot;</span> : <span class="string">&quot;run-p build serve &quot;</span> <span class="comment">//这个模块使用start run-p来声明同时执行的步骤</span></span><br><span class="line">&#125;，</span><br></pre></td></tr></table></figure>
<p>yarn start时 build和serve就被同时执行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;build&quot;</span> : <span class="string">&quot;sass scss/main.scss css/style.css --watch&quot;</span>，</span><br><span class="line">    <span class="string">&quot;serve&quot;</span> : <span class="string">&quot;browser-sync . --files \css/*.css\&quot;&quot;</span> <span class="comment">//可以让browser-sync在启动过后监听文件的变化，网页就能自动刷新了</span></span><br><span class="line">    <span class="string">&quot;start&quot;</span> : <span class="string">&quot;run-p build serve &quot;</span> </span><br><span class="line">&#125;，</span><br></pre></td></tr></table></figure>


<h4 id="grunt基本使用"><a href="#grunt基本使用" class="headerlink" title="grunt基本使用"></a>grunt基本使用</h4><p><strong>创建</strong><br>yarn init –yes<br>yarn add grunt<br>code gruntfile.js<br>gruntfile.js是 Grunt 的入口文件, 用于定义一些需要 Grunt 自动执行的任务, 需要导出一个函数, 此函数接收一个 grunt 的对象类型的形参<br>grunt 对象中会提供一些创建任务时会用到的 API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// grunt.initConfig() 用于为任务添加一些配置选项</span></span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    <span class="comment">// 键一般对应任务的名称</span></span><br><span class="line">    <span class="comment">// 值可以是任意类型的数据</span></span><br><span class="line">    <span class="attr">foo</span>: &#123;</span><br><span class="line">      <span class="attr">bar</span>: <span class="string">&#x27;baz&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">&#x27;foo&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 任务中可以使用 grunt.config() 获取配置</span></span><br><span class="line">    <span class="built_in">console</span>.log(grunt.config(<span class="string">&#x27;foo&#x27;</span>))</span><br><span class="line">    <span class="comment">// 如果属性值是对象的话，config 中可以使用点的方式定位对象中属性的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(grunt.config(<span class="string">&#x27;foo.bar&#x27;</span>))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;a sample task&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello grunt&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">&#x27;bar&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;other task&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// // default 是默认任务名称</span></span><br><span class="line">  <span class="comment">// // 通过 grunt 执行时可以省略</span></span><br><span class="line">  <span class="comment">// grunt.registerTask(&#x27;default&#x27;, () =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(&#x27;default task&#x27;)</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二个参数可以指定此任务的映射任务，</span></span><br><span class="line">  <span class="comment">// 这样执行 default 就相当于执行对应的任务</span></span><br><span class="line">  <span class="comment">// 这里映射的任务会按顺序依次执行，不会同步执行</span></span><br><span class="line">  grunt.registerTask(<span class="string">&#x27;default&#x27;</span>, [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 也可以在任务函数中执行其他任务</span></span><br><span class="line">  grunt.registerTask(<span class="string">&#x27;run-other&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// foo 和 bar 会在当前任务执行完成过后自动依次执行</span></span><br><span class="line">    grunt.task.run(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;current task runing~&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认 grunt 采用同步模式编码</span></span><br><span class="line">  <span class="comment">// 如果需要异步可以使用 this.async() 方法创建回调函数</span></span><br><span class="line">  <span class="comment">// grunt.registerTask(&#x27;async-task&#x27;, () =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   setTimeout(() =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     console.log(&#x27;async task working~&#x27;)</span></span><br><span class="line">  <span class="comment">//   &#125;, 1000)</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于函数体中需要使用 this，所以这里不能使用箭头函数</span></span><br><span class="line">  grunt.registerTask(<span class="string">&#x27;async-task&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> done = <span class="built_in">this</span>.async()</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;async task working~&#x27;</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>yarn grunt foo/bar (不写就是默认, 默认中的数组顺序执行)</p>
<p><strong>标记任务失败</strong><br>使用return false标记失败, 后面的任务就不会被执行了, 如果执行 yarn grunt default –force 会继续执行失败后面的任务,<br>如果是异步的就使用done(false)来标记</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 任务函数执行过程中如果返回 false</span></span><br><span class="line">  <span class="comment">// 则意味着此任务执行失败</span></span><br><span class="line">  grunt.registerTask(<span class="string">&#x27;bad&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;bad working~&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">&#x27;foo&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo working~&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  grunt.registerTask(<span class="string">&#x27;bar&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;bar working~&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果一个任务列表中的某个任务执行失败</span></span><br><span class="line">  <span class="comment">// 则后续任务默认不会运行</span></span><br><span class="line">  <span class="comment">// 除非 grunt 运行时指定 --force 参数强制执行</span></span><br><span class="line">  grunt.registerTask(<span class="string">&#x27;default&#x27;</span>, [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bad&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步函数中标记当前任务执行失败的方式是为回调函数指定一个 false 的实参</span></span><br><span class="line">  grunt.registerTask(<span class="string">&#x27;bad-async&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> done = <span class="built_in">this</span>.async()</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;async task working~&#x27;</span>)</span><br><span class="line">      done(<span class="literal">false</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置选项方法</strong><br>initConfig: 可以用这种方法配置压缩文件路径, 键与文件名称保持一致</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    <span class="attr">build</span>: &#123;</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;task options&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">foo</span>: &#123;</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">msg</span>: <span class="string">&#x27;foo target options&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">bar</span>: <span class="string">&#x27;456&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  grunt.registerMultiTask(<span class="string">&#x27;build&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.options())</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>多目标任务</strong><br>.registerMultiTask<br>需要initconfig一个和任务名同名的属性, 属性值一定是个对象, 对象中每个属性的名字就是目标名称</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 多目标模式，可以让任务根据配置形成多个子任务</span></span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    <span class="attr">build</span>: &#123;</span><br><span class="line">      <span class="attr">foo</span>: <span class="number">100</span>,</span><br><span class="line">      <span class="attr">bar</span>: <span class="string">&#x27;456&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  grunt.registerMultiTask(<span class="string">&#x27;build&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`task: build, target: <span class="subst">$&#123;<span class="built_in">this</span>.target&#125;</span>, data: <span class="subst">$&#123;<span class="built_in">this</span>.data&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yarn grunt build<br>yarn grunt build:bar</p>
<p>options是一个方法, 可以拿配置选项, 如果写在属性里面会覆盖外层</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    <span class="attr">build</span>: &#123;</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;task options&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">foo</span>: &#123;</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">msg</span>: <span class="string">&#x27;foo target options&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">bar</span>: <span class="string">&#x27;456&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  grunt.registerMultiTask(<span class="string">&#x27;build&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.options())</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插件的使用</strong><br>插件是grunt的核心, 大体是用npm安装, 在gruntfile里面加载<br>如清理插件: yarn add grunt-contrib-clean</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  grunt.initConfig(&#123;</span><br><span class="line">    <span class="comment">//grunt的插件一般是以grunt-contrib-name命名的, 所以属性名是clean</span></span><br><span class="line">    <span class="attr">clean</span>: &#123;</span><br><span class="line">      <span class="attr">temp</span>: <span class="string">&#x27;temp/**&#x27;</span> <span class="comment">//temp可以指定具体，也可以通配符, 如temp/*.txt, temp/**</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  grunt.loadNpmTasks(<span class="string">&#x27;grunt-contrib-clean&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常用插件</strong><br>1.sass css的转换</p>
<blockquote>
<p>yarn add grunt-sass sass –dev</p>
</blockquote>
<p>2.babel ex新特性的转换</p>
<blockquote>
<p>yarn add grunt-babel @babel/core @babel/preset-env –dev</p>
</blockquote>
<p>3.watch 监视</p>
<blockquote>
<p>yarn add grunt-contrib-watch –dev</p>
</blockquote>
<h4 id="gulp的基本使用"><a href="#gulp的基本使用" class="headerlink" title="gulp的基本使用"></a>gulp的基本使用</h4><p>The streaming build system</p>
<p><strong>基本使用</strong><br>安装开发依赖 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn init --yes</span><br><span class="line">yarn add gulp --dev<span class="comment">//(同时会安装gulp-cli,也就是说会在.bin下有个命令）</span></span><br><span class="line">code gulpfile.js</span><br></pre></td></tr></table></figure>

<p>gulp通过导出函数成员的方式去定义, 导出的函数都会作为 gulp 任务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gulp 的任务函数都是异步的</span></span><br><span class="line"><span class="comment">// 可以通过调用回调函数标识任务完成</span></span><br><span class="line"><span class="built_in">exports</span>.foo = <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo task working~&#x27;</span>)</span><br><span class="line">  done() <span class="comment">// 标识任务执行完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yarn gulp foo</p>
<p>gulp4.0以前需要载入gulp模块, 然后使用gulp.task()方法注册任务, 不过这种方式已经不被推荐了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">&#x27;bar&#x27;</span>, <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;bar task working~&#x27;</span>)</span><br><span class="line">  done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>yarn gulp bar</p>
<p><strong>默认任务</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// default 是默认任务</span></span><br><span class="line"><span class="comment">// 在运行是可以省略任务名参数</span></span><br><span class="line"><span class="built_in">exports</span>.default = <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;default task working~&#x27;</span>)</span><br><span class="line">  done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yarn gulp</p>
<p><strong>组合任务</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//series会依次执行, parallel会并行执行</span></span><br><span class="line"><span class="keyword">const</span> &#123; series, parallel &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task1 = <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;task1 working~&#x27;</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task2 = <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;task2 working~&#x27;</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">1000</span>)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task3 = <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;task3 working~&#x27;</span>)</span><br><span class="line">    done()</span><br><span class="line">  &#125;, <span class="number">1000</span>)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让多个任务按照顺序依次执行</span></span><br><span class="line"><span class="built_in">exports</span>.foo = series(task1, task2, task3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让多个任务同时执行</span></span><br><span class="line"><span class="built_in">exports</span>.bar = parallel(task1, task2, task3)</span><br></pre></td></tr></table></figure>


<p><strong>异步任务的三种方式</strong><br>1.错误优先的回调函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.callback = <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;callback task&#x27;</span>)</span><br><span class="line">  done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.callback_error = <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;callback task&#x27;</span>)</span><br><span class="line">  done(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;task failed&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.promise = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise task&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.promise_error = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise task&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;task failed&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>async await (是语法糖，实际上还是promise）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.async = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async task&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.stream （是其他方式中最为常见的方式）<br>readStream  end的时候结束</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.stream = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> read = fs.createReadStream(<span class="string">&#x27;yarn.lock&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> write = fs.createWriteStream(<span class="string">&#x27;a.txt&#x27;</span>)</span><br><span class="line">  read.pipe(write)</span><br><span class="line">  <span class="keyword">return</span> read</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.stream = <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> read = fs.createReadStream(<span class="string">&#x27;yarn.lock&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> write = fs.createWriteStream(<span class="string">&#x27;a.txt&#x27;</span>)</span><br><span class="line">  read.pipe(write)</span><br><span class="line">  read.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    done()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>构建过程核心工作原理</strong><br>通过api模拟构建过程, 这是直接写入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; Transform &#125; = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.default = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">&#x27;normalize.css&#x27;</span>)  <span class="comment">// 文件读取流</span></span><br><span class="line">  <span class="keyword">const</span> writeStream = fs.createWriteStream(<span class="string">&#x27;normalize.min.css&#x27;</span>)  <span class="comment">// 文件写入流</span></span><br><span class="line">  <span class="keyword">const</span> transformStream = <span class="keyword">new</span> Transform(&#123;  <span class="comment">// 文件转换流</span></span><br><span class="line">    <span class="comment">// 核心转换过程</span></span><br><span class="line">    <span class="attr">transform</span>: <span class="function">(<span class="params">chunk, encoding, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> input = chunk.toString()</span><br><span class="line">      <span class="keyword">const</span> output = input.replace(<span class="regexp">/\s+/g</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="regexp">/\/\*.+?\*\//g</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">//input先把空白字符替换掉，再替换掉注释</span></span><br><span class="line">      callback(<span class="literal">null</span>, output) <span class="comment">//callback是错误优先的对象 没有错误时第一个参数传null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> readStream</span><br><span class="line">    .pipe(transformStream) <span class="comment">// 转换</span></span><br><span class="line">    .pipe(writeStream) <span class="comment">// 写入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yarn gulp</p>
<p><strong>文件操作</strong><br>读写: API+插件的使用, src（）创建读取流, dest（）创建写入流<br>对css的压缩转换: 安装依赖: yarn add gulp-clean-css –dev<br>重命名: 安装依赖: yarn add gulp-rename –dev</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.default = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">&#x27;src/*.css&#x27;</span>)</span><br><span class="line">    .pipe(cleanCSS())</span><br><span class="line">    .pipe(rename(&#123; <span class="attr">extname</span>: <span class="string">&#x27;.min.css&#x27;</span> &#125;))</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yarn gulp<br>以上使用pipe src读取流，再pipe dest写入流的操作就是我们使用gulp的常规操作</p>
<h4 id="FIS基本使用"><a href="#FIS基本使用" class="headerlink" title="FIS基本使用"></a>FIS基本使用</h4><p>fis不如前两个用的多, 也很久没更新版本了, 它高度集成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn <span class="built_in">global</span> fis3 </span><br><span class="line">fis3 release</span><br><span class="line">fis3 release -d output</span><br></pre></td></tr></table></figure>

<p>添加fis-config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fis.match(<span class="string">&#x27;*.&#123;js,scss,png&#125;&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">release</span>: <span class="string">&#x27;/assets/$0&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fis.match(<span class="string">&#x27;**/*.scss&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">rExt</span>: <span class="string">&#x27;.css&#x27;</span>,</span><br><span class="line">  <span class="attr">parser</span>: fis.plugin(<span class="string">&#x27;node-sass&#x27;</span>),</span><br><span class="line">  <span class="attr">optimizer</span>: fis.plugin(<span class="string">&#x27;clean-css&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fis.match(<span class="string">&#x27;**/*.js&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">parser</span>: fis.plugin(<span class="string">&#x27;babel-6.x&#x27;</span>),</span><br><span class="line">  <span class="attr">optimizer</span>: fis.plugin(<span class="string">&#x27;uglify-js&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>fis3 release -d output</p>
<p>编译与压缩<br>yarn global add fis-parser-node-sass</p>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
  </entry>
  <entry>
    <title>snabbdom</title>
    <url>/2021/07/15/snabbdom/</url>
    <content><![CDATA[<p>mkdir snabdom-demo</p>
<p>cd snabdom-demo</p>
<p>//创建package</p>
<p>npm init -y</p>
<p>//本地安装parcel</p>
<p>npm install parcel-bundler -D</p>
<p>配置scripts</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span> :&#123;</span><br><span class="line"><span class="string">&quot;dev&quot;</span> :<span class="string">&quot;parcel index.html -- open&quot;</span>,</span><br><span class="line"><span class="string">&quot;build&quot;</span>: <span class="string">&quot;parcel build index.html&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在根目录创建index.html文件  来引入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./src/01-basicusage.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>npm install <a href="mailto:&#115;&#x6e;&#97;&#x62;&#98;&#x64;&#x6f;&#x6d;&#x40;&#50;&#46;&#x31;&#x2e;&#48;">&#115;&#x6e;&#97;&#x62;&#98;&#x64;&#x6f;&#x6d;&#x40;&#50;&#46;&#x31;&#x2e;&#48;</a></p>
<p>h(‘!’) //这是 一个空的节点</p>
<h4 id="snabbdom模块的使用"><a href="#snabbdom模块的使用" class="headerlink" title="snabbdom模块的使用"></a>snabbdom模块的使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导入模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; styleModule &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/build/package/modules/style&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventListenersModule &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/build/package/modules/eventlisteners&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 注册模块</span></span><br><span class="line"><span class="keyword">const</span> patch = init([</span><br><span class="line">  styleModule,</span><br><span class="line">  eventListenersModule</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用h() 函数的第二个参数传入模块中使用的数据（对象）</span></span><br><span class="line"><span class="keyword">let</span> vnode = h(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">  h(<span class="string">&#x27;h1&#x27;</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">backgroundColor</span>: <span class="string">&#x27;red&#x27;</span> &#125; &#125;, <span class="string">&#x27;Hello World&#x27;</span>),</span><br><span class="line">  h(<span class="string">&#x27;p&#x27;</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: eventHandler &#125; &#125;, <span class="string">&#x27;Hello P&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;别点我，疼&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// 生成虚拟dom 根据diff算法更新dom</span></span><br><span class="line">patch(app, vnode)</span><br></pre></td></tr></table></figure>


<p>snabbdom源码学习</p>
<p>snabbdom源码地址</p>
<p><a href="https://github.com/snabbdom/snabbdom">https://github.com/snabbdom/snabbdom</a></p>
<p>Snabbdom的核心<br>init() 设置模块，创建patch()函数<br>使用h()函数创建JavaScript对象(VNode)描述真实DOM<br>patch()比较新旧两个Vnode<br>把变化的内容更新到真实DOM树</p>
<h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><p>总体代码在<a href="https://github.com/Levxn7/lagouhomework/tree/master/part3/fed-e-task-03-01/third">https://github.com/Levxn7/lagouhomework/tree/master/part3/fed-e-task-03-01/third</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; init &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/build/package/init&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/build/package/h&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; styleModule &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/build/package/modules/style&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; eventListenersModule &#125; <span class="keyword">from</span> <span class="string">&#x27;snabbdom/build/package/modules/eventlisteners&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> patch = init([styleModule, eventListenersModule]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vnode;</span><br><span class="line"><span class="keyword">let</span> sortBy = <span class="string">&quot;rank&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">rank</span>: i,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;title&#x27;</span> + i,</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&#x27;this is desc&#x27;</span> + i</span><br><span class="line">  &#125;</span><br><span class="line">  data.push(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">prop</span>) </span>&#123;</span><br><span class="line">  data.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[prop] &gt; b[prop]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[prop] &lt; b[prop]) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  vnode = patch(vnode, view(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">rank</span>: data.length,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;title&#x27;</span> + data.length,</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&#x27;this is desc&#x27;</span> + data.length</span><br><span class="line">  &#125;</span><br><span class="line">  data.unshift(a)</span><br><span class="line">  vnode = patch(vnode, view(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">  data.splice(index, <span class="number">1</span>)</span><br><span class="line">  vnode = patch(vnode, view(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">movieView</span>(<span class="params">movie,index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> h(</span><br><span class="line">    <span class="string">&quot;div.li&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">key</span>: movie.rank,</span><br><span class="line">      <span class="attr">style</span>: &#123;</span><br><span class="line">        <span class="attr">padding</span>: <span class="string">&#x27;0 16px&#x27;</span>,</span><br><span class="line">        <span class="attr">height</span>: <span class="string">&#x27;50px&#x27;</span>,</span><br><span class="line">        <span class="attr">display</span>: <span class="string">&#x27;flex&#x27;</span>,</span><br><span class="line">        <span class="attr">alignItems</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">        <span class="attr">borderBottom</span>: <span class="string">&#x27;1px solid #ccc&#x27;</span>,</span><br><span class="line">        <span class="attr">justifyContent</span>: <span class="string">&#x27;space-between&#x27;</span>,</span><br><span class="line">        <span class="attr">opacity</span>: <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">        <span class="attr">delayed</span>: &#123; <span class="attr">transition</span>: <span class="string">&#x27;opacity 2s&#x27;</span>, <span class="attr">opacity</span>: <span class="string">&#x27;1&#x27;</span> &#125;,</span><br><span class="line">        <span class="attr">remove</span>: &#123; <span class="attr">transition</span>: <span class="string">&#x27;opacity 0.3s&#x27;</span>, <span class="attr">opacity</span>: <span class="string">&#x27;0&#x27;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    [</span><br><span class="line">      h(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">fontWeight</span>: <span class="string">&quot;bold&quot;</span> &#125; &#125;, movie.rank),</span><br><span class="line">      h(<span class="string">&quot;div&quot;</span>, movie.title),</span><br><span class="line">      h(<span class="string">&quot;div&quot;</span>, movie.desc),</span><br><span class="line">      h(</span><br><span class="line">        <span class="string">&quot;button.btn.rm-btn&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">on</span>: &#123;</span><br><span class="line">            <span class="attr">click</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">              remove(index);</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;删除&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    ]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">view</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">&quot;div&quot;</span>, [</span><br><span class="line">    h(<span class="string">&quot;h1&quot;</span>, <span class="string">&quot;Top 10 movies&quot;</span>),</span><br><span class="line">    h(<span class="string">&quot;div&quot;</span>, [</span><br><span class="line">      h(<span class="string">&quot;button.add&quot;</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: add &#125; &#125;, <span class="string">&quot; 添加 &quot;</span>),</span><br><span class="line">      <span class="string">&quot;排序方式: &quot;</span>,</span><br><span class="line">      h(<span class="string">&quot;span.btn-group&quot;</span>, [</span><br><span class="line">        h(</span><br><span class="line">          <span class="string">&quot;button.rank&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">class</span>: &#123; <span class="attr">active</span>: sortBy === <span class="string">&quot;rank&quot;</span> &#125;,</span><br><span class="line">            <span class="attr">on</span>: &#123;</span><br><span class="line">              <span class="attr">click</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                change(<span class="string">&quot;rank&quot;</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot; Rank &quot;</span></span><br><span class="line">        ),</span><br><span class="line">        h(</span><br><span class="line">          <span class="string">&quot;button.title&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">class</span>: &#123; <span class="attr">active</span>: sortBy === <span class="string">&quot;title&quot;</span> &#125;,</span><br><span class="line">            <span class="attr">on</span>: &#123;</span><br><span class="line">              <span class="attr">click</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                change(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot; Title &quot;</span></span><br><span class="line">        ),</span><br><span class="line">        h(</span><br><span class="line">          <span class="string">&quot;button.desc&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">class</span>: &#123; <span class="attr">active</span>: sortBy === <span class="string">&quot;desc&quot;</span> &#125;,</span><br><span class="line">            <span class="attr">on</span>: &#123;</span><br><span class="line">              <span class="attr">click</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                change(<span class="string">&quot;desc&quot;</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot; Description &quot;</span></span><br><span class="line">        ),</span><br><span class="line">      ]),</span><br><span class="line">    ]),</span><br><span class="line">    h(</span><br><span class="line">      <span class="string">&quot;div.list&quot;</span>,</span><br><span class="line">      &#123; <span class="attr">style</span>: &#123; <span class="attr">height</span>: <span class="string">&quot;8px&quot;</span> &#125; &#125;,</span><br><span class="line">      data.map(movieView)</span><br><span class="line">    ),</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addEl = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>);</span><br><span class="line">vnode = patch(addEl, view(data));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>snabbdom</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码琐碎知识点</title>
    <url>/2021/07/12/vuecode/</url>
    <content><![CDATA[<h4 id="一些零碎的知识"><a href="#一些零碎的知识" class="headerlink" title="一些零碎的知识"></a>一些零碎的知识</h4><p>flow是js的静态类型检查器，但vue3以后是用ts检查的</p>
<p>vue的打包工具是rollup，rollup更适合库打包</p>
<p>调试需要开启sourcemap</p>
<p>js文件中的flow语法检查红线报错问题：setting。json中设置为false就能解决<br>泛型导致高亮显示失效问题，安装插件 babel-JavaScript可以解决</p>
<p>with函数的扩展</p>
<p>vue Template Explorer网页工具，把html代码转换为模板编译后的代码</p>
<p>静态成员 initGlobalAPI（core/index.js）<br>初始化vue.config util set selete nextTick等</p>
<p>初始化vue.options并给其扩展components directives filters</p>
<h5 id="初始化的过程"><a href="#初始化的过程" class="headerlink" title="初始化的过程"></a>初始化的过程</h5><p>实例成员<br>//注册 vm 的init() 方法，初始化Vm<br>initMixin(Vue)<br>// 注册 vm 的 $data/ $props/ $set/ $delete/ $watch<br>stateMixin(Vue)<br>//初始化事件相关方法<br>// $on/$once/$off/$emit<br>eventsMixin(Vue)<br>//初始化生命周期相关的混入方法<br>// _update/$forceUpdate/ $destroy<br>lifecycleMixin(Vue)<br>// 混入 render<br>// $nextTick/_render<br>renderMixin(Vue)</p>
<p>init函数 初始化<br>是分模块实现的</p>
<h5 id="Vue-首次渲染的过程。"><a href="#Vue-首次渲染的过程。" class="headerlink" title="Vue 首次渲染的过程。"></a>Vue 首次渲染的过程。</h5><p>在首次渲染之前，先进行vue的初始化，初始化实例成员，静态成员，当初始化结束后调用vue的构造函数，在构造函数中调用了init方法，这个方法相当于整个文件的入口<br>方法中调用了$mount<br>第一个$mount通过compileToFunction帮我们把模板编译成render函数，存入options.render中<br>第二个$mount中重新获取$el<br>调用mountComponent，先判断是否是render选项，如果没有，但是传入的是模板并且是运行版本时，版本会被警告不支持编译器<br>触发beforemount，定义updateComponent，调用render生成虚拟dom和update方法将虚拟dom转换成真实dom并挂载到页面上来<br>创建watcher对象，传入了updateComponent函数，在watcher中调用，调用的get方法<br>创建完watcher会调用一个get方法，在get中调用updateComponent，updateComponent中会调用render和update两个方法<br>render的作用是创建虚拟dom，最终调用的用户传入的或者模板编译的render<br>返回vnode，调用vm._update，在其中调用__patch__ 这个方法将虚拟dom转换成真实dom并挂载到页面上来，真实dom渲染到$el中<br>触发mounted 挂载结束 返回vue实例</p>
<h4 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h4><p>处理的入口<br>observe就是响应式处理的入口，调用了Observer对象<br>Observer是一个类 使用的flow的语法<br>defineReactive</p>
<p>Watcher 分为三种，Computed Watcher、用户 Watcher (侦听器)、渲染Watcher<br>instance/lifecycle.js</p>
<h5 id="Vue-响应式原理。"><a href="#Vue-响应式原理。" class="headerlink" title="Vue 响应式原理。"></a>Vue 响应式原理。</h5><p>响应式是从vue实例的init方法开始的，在init方法中先调用initState()方法初始化vue实例的状态<br>在其中调用了initData，这个方法是把data属性注入到vue实例上，并且调用observe把data对象转换成响应式的对象，observe就是响应式的入口<br>observe接受一个参数，这个参数就是响应式要处理的对象，observe在src/corelobserver/index.js中，先判断value是否是对象，如果不是对象就直接返回<br>然后判断value对象是否有__ob__属性，,如果有就说明这个对象已经做过响应式处理，直接返回，如果没有，就创建observer对象，返回observer 对象<br>Observe类会给value对象定义一个不可枚举的__ob__属性，并把这个属性记录到当前的observer中，然后给对象做响应式处理<br>数组的处理就是设置几个特殊的方法，方法会改变数组，会发送通知，找到dep方法调用，遍历成员，调用observe<br>对象的处理会调用walk方法，遍历对象，给每个属性调用defineReactive方法<br>defineReactive会给每个属性创建dep对象，让dep去收集依赖，如果当前属性是对象，就调用observe，要把这个对象变成响应式<br>定义getter收集依赖，包括对象的子对象<br>定义setter保存新值，如果新值是对象，就调用observe，发送通知，调用dep.notify<br>依赖收集：首先执行watcher对象中的get方法，调用pushTarget把watcher对象记录到dep.target属性中<br>在访问data中的成员的时候收集依赖，触发defineReactive中的getter收集依赖，把属性对应的watcher对象添加到dep的subs数组中，也就是为属性收集依赖，如果属性的值是个对象，就创建一个childOb收集依赖，目的是子对象添加和删除成员时发送通知<br>watcher：当数据发生变化的时候通过dep.notify发送通知，他会调用watcher对象的update方法，在update方法中会调用queueWatcher函数，来判断watcher是否被处理了，如果没有就添加到queue队列，并调用flushSchedulerQueue刷新队列<br>flushSchedulerQueue会触发beforeUpdata钩子函数，然后调用watcher.run函数，在其中调用run–&gt;get–&gt;getter–&gt;updateComponent<br>调用run方法之后，就可以在页面上看到数据了<br>清空上一次的依赖，重置watcher的状态，然后触发actived钩子函数，然后触发updated钩子函数</p>
<h5 id="动态添加响应式数据"><a href="#动态添加响应式数据" class="headerlink" title="动态添加响应式数据"></a>动态添加响应式数据</h5><p>例子:<br>vm.$set(vm.obj, ‘name’, ‘zs’)<br>用法:<br>向响应式对象中添加一个property，并确保这个新property同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新<br>property，因为Vue无法探测普通的新增property (比如<br>this.my0bject.newProperty = ‘hi’ )<br>!注意对象不能是Vue实例，或者Vue实例的根数据对象。</p>
<p>watcher和set类似</p>
<p>nexTick是在dom行程后获取内容,本身是一个微任务,运行环境不支持时降级为宏任务,</p>
<h5 id="为什么要使用虚拟DOM"><a href="#为什么要使用虚拟DOM" class="headerlink" title="为什么要使用虚拟DOM"></a>为什么要使用虚拟DOM</h5><ul>
<li>避免直接操作DOM,提高开发效率</li>
<li>作为一个中间层可以跨平台</li>
<li>虚拟DOM不一定可以提高性能</li>
<li>首次渲染的时候会增加开销</li>
<li>复杂视图情况下提升渲染性能</li>
</ul>
<h4 id="vnode的创建过程"><a href="#vnode的创建过程" class="headerlink" title="vnode的创建过程"></a>vnode的创建过程</h4><p>render函数返回vnode<br>update函数把虚拟dom渲染成真实dom<br>执行__patch__函数设置modules和nodeops，返回patch函数<br>patch函数</p>
<h5 id="虚拟dom创建的整体过程"><a href="#虚拟dom创建的整体过程" class="headerlink" title="虚拟dom创建的整体过程"></a>虚拟dom创建的整体过程</h5><p>vm._render()<br>vnode = render.call(vm._renderProxy, vm.$createElement)</p>
<p>vm.$createElement()<br>h函教,用户设置的render函数中调用<br>createElement(vm, a, b.c.d, true)</p>
<p>vm._c()<br>h函数。模板编译的render函数中调用<br>createElement(vm,a,b.c.d, true)</p>
<p>createElement()<br>vnode = new VNode( config.parsePlatformTagName(tag). data,children, undefined, undefined, context )<br>vm._render()结束，返回vnode</p>
<p>vm._update()<br>负责把虚拟 DOM，渲染成真实DOM<br>首次执行 vm. patch vm.$el, vnode,hydrating.false)<br>数据更新 vm.patch  (prevVnode, vnode)</p>
<p>vm.__patch__()<br>runtimefindexjs中挂载vue.prototype.__patch__<br>runtime/patch.js 的patch函数<br>设置modules和nodeOps<br>调用createPatchFunction0函数返回patch函数</p>
<p>patch()<br>vdom/patch.js 中的createPatchFunction返回patch函数<br>挂载cbs节点的属性/事件/样式操作的钩了函数<br>判断第一个参数是真实DOM还是虚拟 DOM.首次加载,第个参数就是真实DOM，转换成VNode，调用createElm<br>如里是数据更新的时候,新旧节点是samevnode执行 patchVnode,也就是 Diff<br>删除旧节点</p>
<p>createElm(vnode,insertedVnodeQueue)<br>把虚拟节点,转换为真实DOM，并插入到DOM树<br>把虚拟节点的children，转换为真实DOM，并插入到DOM树</p>
<p>patchVnode<br>对比新旧VNode，以及新旧VNode的了节点更新差异<br>如果新旧VNode都有了节点并且了节点不同的话，会调用updateChildren对比子节点的差异</p>
<p>updatechildren<br>从头和尾开始依次找到相同的了节点进行比较patchVnode，总共有四种比较方式<br>在老节点的了节点中查找newStartVnode，并进行处理<br>如果新节点比老节点多，把新增的了节点插入到DOM中<br>如果老节点比新节点多，把多余的老节点删除
　</p>
<h5 id="虚拟-DOM-中-Key-的作用和好处。"><a href="#虚拟-DOM-中-Key-的作用和好处。" class="headerlink" title="虚拟 DOM 中 Key 的作用和好处。"></a>虚拟 DOM 中 Key 的作用和好处。</h5><p>key主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改\复用相同类型元素的算法。而使用key时，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。有相同父元素的子元素必须有独有的key。重复的key会造成渲染错误。<br>设置key比不设置的dom操作要少很多，减少diff和渲染所需要的时间，提升了性能。</p>
<h4 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h4><p> 模板编译的主要作用是将模板转换为渲染函数<br> 模板编译的作用</p>
<ul>
<li>Vue 2.x使用VNode描述视图以及各种交互，用户自己编写VNode 比较复杂</li>
<li>通过模板编译用户只需要编写类似HTML的代码</li>
<li>Vue.js模板，通过编译器将模板转换为返回 VNode 的render 函数</li>
<li>vue文件会被webpack在构建的过程中转换成render 函数</li>
</ul>
<h5 id="Vue-中模板编译的过程。"><a href="#Vue-中模板编译的过程。" class="headerlink" title="Vue 中模板编译的过程。"></a>Vue 中模板编译的过程。</h5><p>　<br>入口函数是compileToFunctions，在这个函数中先从缓存中加载编译好的render函数，如果缓存中没有的话就调用compile函数<br>在compile函数中，首先去合并options选项，然后调用baseCompile编译模板，compile的核心是合并选项，真正的处理是在baseCompile中完成的<br>把模板和合并后的选项传递给baseCompile函数，baseCompile完成了编译核心的以下三件事情<br>parse函数把模板转换成AST对象 也就是抽象语法树<br>optimize函数标记AST中的静态根节点，静态根节点不需要被重绘，patch的过程中会跳过静态根节点<br>generate函数把优化过后的AST对象转换成字符串形式的js代码<br>当compile执行完毕后，回到入口文件compileToFunctions，此处会继续把字符串形式的代码转换为函数的形式，然后调用createFuntion，当render和staticFuntion执行完毕，挂在到vue实例的options对应的属性上<br>所以，不要在代码中写入无意义的空白和换行，这些空白和换行都会被存储到内存中，对浏览器的渲染是毫无意义的
　</p>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue基础</title>
    <url>/2021/06/25/vuejc/</url>
    <content><![CDATA[<h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。比如说created ,mounted ,updated等钩子函数。<br><img src="/2021/06/25/vuejc/1408390-20190502182244199-1878074396.png" alt="vue生命周期"></p>
<h5 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.v-bind:响应并更新DOM特性; 例如：v-bind:href v-bind:class v-bind:title 等等; 主要用法是绑定属性，动态更新HTML元素上的属性；</span></span><br><span class="line"><span class="comment">2.v-on:用于监听DOM事件; 例如:v-on:click v-on:keyup </span></span><br><span class="line"><span class="comment">3.v-model:数据双向绑定;用于表单输入等;例如:&lt; input v-model= &quot;message&quot;&gt;</span></span><br><span class="line"><span class="comment">4.v-show:条件渲染指令,为DOM设置css的style属性</span></span><br><span class="line"><span class="comment">5.v-if:条件渲染指令,动态在DOM内添加或删除DOM元素</span></span><br><span class="line"><span class="comment">6、v-else：条件渲染指令，必须跟v-if成对使用</span></span><br><span class="line"><span class="comment">7、v-else-if：判断多层条件，必须跟v-if成对使用；</span></span><br><span class="line"><span class="comment">8、v-text：更新元素的textContent；例如：&lt; span v-text=&quot;msg&quot;&gt;&lt;/ span&gt;等同于 &lt; span&gt;&#123;&#123;msg&#125;&#125; &lt;/ span&gt;；</span></span><br><span class="line"><span class="comment">9、v-html：更新元素的innerHTML；会把标签名也带上。</span></span><br><span class="line"><span class="comment">10、v-for：循环指令；</span></span><br><span class="line"><span class="comment">11、v-cloak：不需要表达式，这个指令保持在元素上直到关联实例结束编译； v-cloak 是一个解决初始化慢导致页面闪动的最佳实践 ；</span></span><br><span class="line"><span class="comment">12、v-once：也是一个不需要表达式的指令，作用是定义它的元素或组件只渲染一次，包括元素或组件的所有子节点。首次渲染后，不再随数据的变化重新渲染，将被视为静态内容； v-once 在业务中也很少使用，当你需要进一步优化性能时，可能会用到。 </span></span><br><span class="line"><span class="comment">13、v-pre：不需要表达式，跳过这个元素以及子元素的编译过程，以此来加快整个项目的编译速度；例如： &lt; span v-pre&gt;&#123;&#123; this will not be /compiled &#125;&#125; &lt;/ span&gt;；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>具体使用可参考: <a href="https://my.oschina.net/u/3970421/blog/2964249">https://my.oschina.net/u/3970421/blog/2964249</a></p>
<h5 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h5><p>计算属性就是当其依赖属性的值发生变化时，这个属性的值会自动更新，与之相关的DOM部分也会同步自动更新。对于任何复杂逻辑，你都应当使用计算属性。</p>
<p>计算属性和侦听器<br>Class和Style绑定<br>条件渲染/列表渲染表单输入绑定</p>
<p>以上内容的官网解释: <a href="https://cn.vuejs.org/v2/guide/computed.html">https://cn.vuejs.org/v2/guide/computed.html</a></p>
<p>还有组件 插槽 插件 混入等功能</p>
<h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。路由实际上就是可以理解为指向，就是我在页面上点击一个按钮需要跳转到对应的页面，这就是路由跳转；</p>
<p>首先我们来学习三个单词（route，routes，router）：<br>route：首先它是个单数，译为路由，即我们可以理解为单个路由或者某一个路由；<br>routes：它是个复数，表示多个的集合才能为复数；即我们可以理解为多个路由的集合，JS中表示多种不同状态的集合的形式只有数组和对象两种，事实上官方定义routes是一个数组；所以我们记住了，routes表示多个数组的集合；<br>router：译为路由器，上面都是路由，这个是路由器，我们可以理解为一个容器包含上述两个或者说它是一个管理者，负责管理上述两个；举个常见的场景的例子：当用户在页面上点击按钮的时候，这个时候router就会去routes中去查找route，就是说路由器会去路由集合中找对应的路由；</p>
<h5 id="路由的简单使用"><a href="#路由的简单使用" class="headerlink" title="路由的简单使用"></a>路由的简单使用</h5><p>通过vue.use来注册组件<br>如果是一个函数, 直接调用函数做组件, 如果是对象的话, 会调用对象的install方法来注册插件</p>
<p><strong>创建路由的步骤</strong><br>1 路由规则<br>2 创建路由对象 传入路由规则<br>3 mainjs引入<br>4 app.vue添加站位<br>5 创建连接</p>
<p><strong>动态路由</strong><br>懒加载<br>推荐使用props来传参（还有$route.params.id）</p>
<p><strong>嵌套路由</strong><br>很多时候我们的页面结构决定了我们可能需要嵌套路由，比如当我们进入主页之后有分类，然后当选择其中一个分类之后进入对应的详情，这个时候我们就可以用到嵌套路由；官方文档中给我们提供了一个children属性，这个属性是一个数组类型，里面实际放着一组路由；这个时候父子关系结构就出来了，所以children属性里面的是路由相对来说是children属性外部路由的子路由；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes=[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/page1&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>:page1,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&quot;phone&quot;</span>,<span class="comment">// /page1/phone</span></span><br><span class="line">                <span class="attr">component</span>: phone</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&quot;computer&quot;</span>, <span class="comment">// /page1/computer</span></span><br><span class="line">                <span class="attr">component</span>: computer</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>路由导航两种方式</strong></p>
<blockquote>
<p>标签导航</p>
</blockquote>
<p>标签导航<router-link><router-link>是通过转义为<a></a>标签进行跳转，其中router-link标签中的to属性会被转义为a标签中的href属性；</router-link></router-link></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//跳转到名为user路由，并传递参数userId</span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>编程式导航</p>
</blockquote>
<p>我们可以通过this.$router.push()这个方法来实现编程式导航，当然也可以实现参数传递，这种编程式导航一般是用于按钮点击之后跳转</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:userId&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125;&#125;)</span><br><span class="line"><span class="comment">//push replace go(-2) 等方法</span></span><br></pre></td></tr></table></figure>

<h5 id="hash模式和history模式"><a href="#hash模式和history模式" class="headerlink" title="hash模式和history模式"></a>hash模式和history模式</h5><p>· Hash模式式是基于锚点，以及onhashchange事件, 需要使用问号拼接<br>例: https:/music.163.com/#/playlist?id=3102961863</p>
<p>· History模式是基于 HTML5 中的 History API（需要服务端配置支持）<br>history.pushState() IE10以后才支持<br>history.replaceState()<br>例: <a href="https://music.163.com/playlist/3102961863">https://music.163.com/playlist/3102961863</a></p>
<p><strong>实现原理</strong><br>Hash模式<br>·URL中#后面的内容作为路径地址<br>·监听hashchange 事件<br>·根据当前路由地址找到对应组件重新渲染<br>History模式<br>·通过history.pushState()方法改变地址栏监听popstate事件<br>·根据当前路由地址找到对应组件重新渲染</p>
<p><strong>模拟实现</strong><br>手写router 参考视频3-1-2  10-19小节 (部分解释以注释的方式写在以下代码块中)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue = <span class="literal">null</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> install (vue) &#123;</span><br><span class="line">    <span class="comment">// 1 判断当前插件是否被安装</span></span><br><span class="line">    <span class="keyword">if</span> (VueRouter.install.installed) <span class="keyword">return</span></span><br><span class="line">    VueRouter.install.installed = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 2 把Vue的构造函数记录在全局</span></span><br><span class="line">    _Vue = vue</span><br><span class="line">    <span class="comment">// 3 把创建Vue的实例传入的router对象注入到Vue实例</span></span><br><span class="line">    <span class="comment">// _Vue.prototype.$router = this.$options.router</span></span><br><span class="line">    _Vue.mixin(&#123;</span><br><span class="line">      beforeCreate () &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$options.router) &#123;</span><br><span class="line">          _Vue.prototype.$router = <span class="built_in">this</span>.$options.router</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.mode = options.mode || <span class="string">&quot;hash&quot;</span></span><br><span class="line">    <span class="built_in">this</span>.routes = options.routes</span><br><span class="line">    <span class="built_in">this</span>.routeMap = &#123;&#125;</span><br><span class="line">    <span class="comment">// observable</span></span><br><span class="line">    <span class="built_in">this</span>.data = _Vue.observable(&#123;</span><br><span class="line">        <span class="comment">//存储当前的路由地址, 默认是/</span></span><br><span class="line">      <span class="attr">current</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>.init()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//包装方法</span></span><br><span class="line">  init () &#123;</span><br><span class="line">    <span class="built_in">this</span>.createRouteMap()</span><br><span class="line">    <span class="built_in">this</span>.initComponents(_Vue)</span><br><span class="line">    <span class="built_in">this</span>.initEvent()</span><br><span class="line">  &#125;</span><br><span class="line">  createRouteMap () &#123;</span><br><span class="line">    <span class="comment">//遍历所有路由信息，把组件和路由的映射记录到 routeMap 对象中</span></span><br><span class="line">    <span class="built_in">this</span>.routes.forEach( <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.routeMap[route.path] = route.component</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">initComponents</span>(<span class="params">Vue</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建 router-link 和 router-view 组件</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    Vue.component(<span class="string">&#x27;router-link&#x27;</span>,&#123;</span><br><span class="line">      <span class="attr">props</span>:&#123;</span><br><span class="line">        <span class="attr">to</span>:<span class="built_in">String</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//运行时版本的解决办法</span></span><br><span class="line">      <span class="function"><span class="title">render</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&quot;a&quot;</span>,&#123;</span><br><span class="line">          <span class="attr">attrs</span>:&#123;</span><br><span class="line">            <span class="attr">href</span>: self.mode === <span class="string">&quot;history&quot;</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;#&quot;</span> + <span class="built_in">this</span>.to</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">//给a标签注册事件</span></span><br><span class="line">          <span class="attr">on</span>:&#123;</span><br><span class="line">            <span class="attr">click</span>:self.mode === <span class="string">&quot;history&quot;</span> ? <span class="built_in">this</span>.clickhander : <span class="built_in">this</span>.hashClickhander</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,[<span class="built_in">this</span>.$slots.default])</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">clickhander</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//参数: 事件 网页标题, 地址</span></span><br><span class="line">          history.pushState(&#123;&#125;,<span class="string">&quot;&quot;</span>,<span class="built_in">this</span>.to)</span><br><span class="line">          <span class="built_in">this</span>.$router.data.current = <span class="built_in">this</span>.to</span><br><span class="line">          e.preventDefault()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">hashClickhander</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.$router.data.current=<span class="built_in">this</span>.to</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 运行时版本的vue不支持模版</span></span><br><span class="line">      <span class="comment">// template:&quot;&lt;a :href=&#x27;to&#x27;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/a&gt;&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    Vue.component(<span class="string">&#x27;router-view&#x27;</span>,&#123;</span><br><span class="line">      <span class="function"><span class="title">render</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">          <span class="comment">//获取路由组件 h帮我们转换成虚拟dom</span></span><br><span class="line">        <span class="keyword">let</span> cm = self.routeMap[self.data.current]</span><br><span class="line">        <span class="keyword">return</span> h(cm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">initEvent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//注册 popstate 事件，当路由地址发生变化，重新记录当前的路径</span></span><br><span class="line">    <span class="keyword">const</span> eventType = <span class="built_in">this</span>.mode === <span class="string">&#x27;history&#x27;</span> ? <span class="string">&#x27;popstate&#x27;</span> : <span class="string">&#x27;hashchange&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> handle = <span class="built_in">this</span>.mode === <span class="string">&#x27;history&#x27;</span> ? <span class="built_in">this</span>.getLocation : <span class="built_in">this</span>.getHash</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(eventType,handle.bind(<span class="built_in">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getLocation</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.data.current = <span class="built_in">window</span>.location.pathname</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getHash</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> href = <span class="built_in">window</span>.location.href</span><br><span class="line">    <span class="keyword">const</span> index = href.indexOf(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.data.current = href.slice(index + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式原理</title>
    <url>/2021/09/19/xysyl/</url>
    <content><![CDATA[<h4 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h4><p>·数据响应式<br>·数据模型仅仅是普通的JavaScript 对象，而当我们修改数据时，视图会进行更新，避免了繁琐的DOM操作，提高开发效率<br>·双向绑定<br>·数据改变，视图改变;视图改变，数据也随之改变·我们可以使用v-model在表单元素上创建双向数据绑定·数据驱动是Vue最独特的特性之一<br>·开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图</p>
<p><strong>深入响应式原理</strong><br>vue2.x中的响应式原理是基于defineProperty 来实现的, ie8以下不支持<br>数据劫持：当访问或者设置 vm 中的成员的时候，做一些干预操作<br>其中有三个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟 Vue 的实例</span></span><br><span class="line"><span class="keyword">let</span> vm = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据劫持：当访问或者设置 vm 中的成员的时候，做一些干预操作</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(vm, <span class="string">&#x27;msg&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 可枚举（可遍历）</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 可配置（可以使用 delete 删除，可以通过 defineProperty 重新定义）</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 当获取值的时候执行</span></span><br><span class="line">    get () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get: &#x27;</span>, data.msg)</span><br><span class="line">        <span class="keyword">return</span> data.msg</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 当设置值的时候执行</span></span><br><span class="line">    set (newValue) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;set: &#x27;</span>, newValue)</span><br><span class="line">        <span class="keyword">if</span> (newValue === data.msg) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        data.msg = newValue</span><br><span class="line">        <span class="comment">// 数据更改，更新 DOM 的值</span></span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>).textContent = data.msg</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>3.0是基于 proxy 实现, 直接监听对象而非属性, 是es6中新增的, ie不支持,性能由浏览器优化<br>proxy是一个构造函数 通过new来实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    <span class="attr">count</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟 Vue 的实例</span></span><br><span class="line"><span class="keyword">let</span> vm = &#123;&#125;</span><br><span class="line"></span><br><span class="line">proxyData(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历 data 对象的所有属性</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 把 data 中的属性，转换成 vm 的 setter/setter</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        get () &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;get: &#x27;</span>, key, data[key])</span><br><span class="line">            <span class="keyword">return</span> data[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        set (newValue) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;set: &#x27;</span>, key, newValue)</span><br><span class="line">            <span class="keyword">if</span> (newValue === data[key]) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            data[key] = newValue</span><br><span class="line">            <span class="comment">// 数据更改，更新 DOM 的值</span></span><br><span class="line">            <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>).textContent = data[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2比1简洁的多  性能也要好一点</p>
<p><strong>发布订阅模式</strong><br>vue的自定义事件  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 自定义事件</span></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue()</span><br><span class="line"><span class="comment">// &#123; &#x27;click&#x27;: [fn1, fn2], &#x27;change&#x27;: [fn] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件(订阅消息)</span></span><br><span class="line">vm.$on(<span class="string">&#x27;dataChange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;dataChange&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$on(<span class="string">&#x27;dataChange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;dataChange1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 触发事件(发布消息)</span></span><br><span class="line">vm.$emit(<span class="string">&#x27;dataChange&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p>发布订阅模式</p>
<p>订阅者$on  发布者$emint 信号中心 let vm = new Vue()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件触发器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// &#123; &#x27;click&#x27;: [fn1, fn2], &#x27;change&#x27;: [fn] &#125;</span></span><br><span class="line">    <span class="built_in">this</span>.subs = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册事件</span></span><br><span class="line">    $on (eventType, handler) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs[eventType] = <span class="built_in">this</span>.subs[eventType] || []</span><br><span class="line">    <span class="built_in">this</span>.subs[eventType].push(handler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件</span></span><br><span class="line">    $emit (eventType) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.subs[eventType]) &#123;</span><br><span class="line">        <span class="built_in">this</span>.subs[eventType].forEach(<span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">        handler()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> em = <span class="keyword">new</span> EventEmitter()</span><br><span class="line">em.$on(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">em.$on(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">em.$emit(<span class="string">&#x27;click&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>观察者模式 没有事件中心  发布者知道订阅者的存在</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布者-目标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 记录所有的订阅者</span></span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加订阅者</span></span><br><span class="line">    addSub (sub) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sub &amp;&amp; sub.update) &#123;</span><br><span class="line">        <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发布通知</span></span><br><span class="line">    notify () &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">        sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订阅者-观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    update () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;update&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"><span class="keyword">let</span> watcher = <span class="keyword">new</span> Watcher()</span><br><span class="line"></span><br><span class="line">dep.addSub(watcher)</span><br><span class="line"></span><br><span class="line">dep.notify()</span><br></pre></td></tr></table></figure>
<p>总结<br>.观察者模式是由具体目标调度，比如当事件触发，Dep 就会去调用观察者的方法，所以观察者模式的订阅者与发布者<br>之间是存在依赖的。<br>.发布/订阅模式由统-调度中心调用，因此发布者和订阅者不需要知道对方的存在。<br><img src="/2021/09/19/xysyl/QQ20210625-163604@2x.png" alt="观察者模式和发布订阅模式"></p>
<h4 id="响应式部分代码实现"><a href="#响应式部分代码实现" class="headerlink" title="响应式部分代码实现"></a>响应式部分代码实现</h4><p>部分解释写在注释中,代码下载地址<a href="https://github.com/Levxn7/lagouhomework/tree/master/part3/fed-e-task-03-01/second">https://github.com/Levxn7/lagouhomework/tree/master/part3/fed-e-task-03-01/second</a></p>
<blockquote>
<p>html</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;cn&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Mini Vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;clicked&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;button v-on=&quot;&#123;click:click&#125;&quot;&gt;点击&lt;/button&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ,mouseenter:onenter,mouseleave:leave --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>差值表达式<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>v-text<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>v-model<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;count&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/dep.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/watcher.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/compiler.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/observer.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">msg</span>: <span class="string">&#x27;Hello Vue&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">count</span>: <span class="number">100</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">person</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">html</span>: <span class="string">&quot;&lt;h1&gt;这是一个h1标签&lt;/h1&gt;&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>:&#123; </span></span><br><span class="line"><span class="javascript">        <span class="attr">clicked</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;被点击了&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(vm.msg)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// vm.msg = &#123; test: &#x27;Hello&#x27; &#125;</span></span></span><br><span class="line"><span class="javascript">    vm.test = <span class="string">&#x27;abc&#x27;</span></span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>dep.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 存储所有的观察者</span></span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加观察者</span></span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sub &amp;&amp; sub.update) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发送通知</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>watcher.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">vm, key, cb</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm</span><br><span class="line">    <span class="comment">// data中的属性名称</span></span><br><span class="line">    <span class="built_in">this</span>.key = key</span><br><span class="line">    <span class="comment">// 回调函数负责更新视图</span></span><br><span class="line">    <span class="built_in">this</span>.cb = cb</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把watcher对象记录到Dep类的静态属性target</span></span><br><span class="line">    Dep.target = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 触发get方法，在get方法中会调用addSub</span></span><br><span class="line">    <span class="built_in">this</span>.oldValue = vm[key]</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当数据发生变化的时候更新视图</span></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="keyword">let</span> newValue = <span class="built_in">this</span>.vm[<span class="built_in">this</span>.key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.oldValue === newValue) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb(newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>compiler.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">vm</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.el = vm.$el</span><br><span class="line">    <span class="built_in">this</span>.vm = vm</span><br><span class="line">    <span class="built_in">this</span>.methods = vm.$methods</span><br><span class="line">    <span class="built_in">this</span>.compile(<span class="built_in">this</span>.el)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译模板，处理文本节点和元素节点</span></span><br><span class="line">  compile (el) &#123;</span><br><span class="line">    <span class="keyword">let</span> childNodes = el.childNodes</span><br><span class="line">    <span class="built_in">Array</span>.from(childNodes).forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 处理文本节点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isTextNode(node)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.compileText(node)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.isElementNode(node)) &#123;</span><br><span class="line">        <span class="comment">// 处理元素节点</span></span><br><span class="line">        <span class="built_in">this</span>.compileElement(node)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断node节点，是否有子节点，如果有子节点，要递归调用compile</span></span><br><span class="line">      <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.compile(node)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译元素节点，处理指令</span></span><br><span class="line">  compileElement (node) &#123;</span><br><span class="line">    <span class="comment">// console.log(node.attributes)</span></span><br><span class="line">    <span class="comment">// 遍历所有的属性节点</span></span><br><span class="line">    <span class="built_in">Array</span>.from(node.attributes).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否是指令</span></span><br><span class="line">      <span class="keyword">let</span> attrName = attr.name</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isDirective(attrName)) &#123;</span><br><span class="line">        <span class="comment">// v-text --&gt; text</span></span><br><span class="line">        attrName = attrName.substr(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> key = attr.value</span><br><span class="line">        <span class="built_in">this</span>.update(node, key, attrName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update (node, key, attrName) &#123;</span><br><span class="line">    <span class="keyword">let</span> updateFn</span><br><span class="line">    <span class="keyword">if</span> (attrName.substr(<span class="number">0</span>,<span class="number">3</span>) === <span class="string">&#x27;on:&#x27;</span>) &#123;</span><br><span class="line">      updateFn = <span class="built_in">this</span>[attrName.substr(<span class="number">0</span>,<span class="number">2</span>) + <span class="string">&#x27;Updater&#x27;</span>]</span><br><span class="line">      updateFn &amp;&amp; updateFn.call(<span class="built_in">this</span>, node, <span class="built_in">this</span>.methods[key], attrName.substr(<span class="number">3</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      updateFn = <span class="built_in">this</span>[attrName + <span class="string">&#x27;Updater&#x27;</span>]</span><br><span class="line">      updateFn &amp;&amp; updateFn.call(<span class="built_in">this</span>, node, <span class="built_in">this</span>.vm[key], key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 v-text 指令</span></span><br><span class="line">  textUpdater (node, value, key) &#123;</span><br><span class="line">    node.textContent = value</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="built_in">this</span>.vm, key, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">      node.textContent = newValue</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// v-model</span></span><br><span class="line">  modelUpdater (node, value, key) &#123;</span><br><span class="line">    node.value = value</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="built_in">this</span>.vm, key, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">      node.value = newValue</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 双向绑定</span></span><br><span class="line">    node.addEventListener(<span class="string">&#x27;input&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.vm[key] = node.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// v-html</span></span><br><span class="line">  htmlUpdater (node, value, key) &#123;</span><br><span class="line">    node.innerHTML = value</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="built_in">this</span>.vm, key, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">      node.innerHTML = newValue</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// v-on</span></span><br><span class="line">  onUpdater (node, value, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&quot;click&quot;</span>) &#123;</span><br><span class="line">      node.onclick = value</span><br><span class="line">      <span class="keyword">new</span> Watcher(<span class="built_in">this</span>.methods, key, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">        node.onclick = newValue</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编译文本节点，处理差值表达式</span></span><br><span class="line">  compileText (node) &#123;</span><br><span class="line">    <span class="comment">// console.dir(node)</span></span><br><span class="line">    <span class="comment">// &#123;&#123;  msg &#125;&#125;</span></span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/</span></span><br><span class="line">    <span class="keyword">let</span> value = node.textContent</span><br><span class="line">    <span class="keyword">if</span> (reg.test(value)) &#123;</span><br><span class="line">      <span class="keyword">let</span> key = <span class="built_in">RegExp</span>.$1.trim()</span><br><span class="line">      node.textContent = value.replace(reg, <span class="built_in">this</span>.vm[key])</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建watcher对象，当数据改变更新视图</span></span><br><span class="line">      <span class="keyword">new</span> Watcher(<span class="built_in">this</span>.vm, key, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">        node.textContent = newValue</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断元素属性是否是指令</span></span><br><span class="line">  isDirective (attrName) &#123;</span><br><span class="line">    <span class="keyword">return</span> attrName.startsWith(<span class="string">&#x27;v-&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断节点是否是文本节点</span></span><br><span class="line">  isTextNode (node) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.nodeType === <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断节点是否是元素节点</span></span><br><span class="line">  isElementNode (node) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.nodeType === <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>observe.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.walk(data)</span><br><span class="line">  &#125;</span><br><span class="line">  walk (data) &#123;</span><br><span class="line">    <span class="comment">// 1. 判断data是否是对象</span></span><br><span class="line">    <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 遍历data对象的所有属性</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.defineReactive(data, key, data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  defineReactive (obj, key, val) &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 负责收集依赖，并发送通知</span></span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="comment">// 如果val是对象，把val内部的属性转换成响应式数据</span></span><br><span class="line">    <span class="built_in">this</span>.walk(val)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">      get () &#123;</span><br><span class="line">        <span class="comment">// 收集依赖</span></span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      set (newValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue === val) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        val = newValue</span><br><span class="line">        that.walk(newValue)</span><br><span class="line">        <span class="comment">// 发送通知</span></span><br><span class="line">        dep.notify()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>vue.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 通过属性保存选项的数据</span></span><br><span class="line">    <span class="built_in">this</span>.$options = options || &#123;&#125;</span><br><span class="line">    <span class="built_in">this</span>.$data = options.data || &#123;&#125;</span><br><span class="line">    <span class="built_in">this</span>.$methods = options.methods || &#123;&#125;</span><br><span class="line">    <span class="built_in">this</span>.$el = <span class="keyword">typeof</span> options.el === <span class="string">&#x27;string&#x27;</span> ? <span class="built_in">document</span>.querySelector(options.el) : options.el</span><br><span class="line">    <span class="comment">// 2. 把data中的成员转换成getter和setter，注入到vue实例中</span></span><br><span class="line">    <span class="built_in">this</span>._proxyData(<span class="built_in">this</span>.$data)</span><br><span class="line">    <span class="comment">// 3. 调用observer对象，监听数据的变化</span></span><br><span class="line">    <span class="keyword">new</span> Observer(<span class="built_in">this</span>.$data)</span><br><span class="line">    <span class="comment">// 4. 调用compiler对象，解析指令和差值表达式</span></span><br><span class="line">    <span class="keyword">new</span> Compiler(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  _proxyData (data) &#123;</span><br><span class="line">    <span class="comment">// 遍历data中的所有属性</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 把data的属性注入到vue实例中</span></span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, key, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        get () &#123;</span><br><span class="line">          <span class="keyword">return</span> data[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        set (newValue) &#123;</span><br><span class="line">          <span class="keyword">if</span> (newValue === data[key]) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          data[key] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的性能优化</title>
    <url>/2021/04/13/xnyh/</url>
    <content><![CDATA[<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>对于JavaScript来说, 会在创建变量（对象, 字符串等）时分配内存, 并且在不再使用它们时“自动”释放内存, 这个自动释放内存的过程称为垃圾回收。因为自动垃圾回收机制的存在, 让大多Javascript开发者感觉他们可以不关心内存管理, 所以会在一些情况下导致内存泄漏。</p>
<p>内容概要：</p>
<ul>
<li>内存管理</li>
<li>垃圾回收与常见GC算法</li>
<li>V8引擎的垃圾回收</li>
<li>Performance工具</li>
<li>代码优化实例</li>
</ul>
<p><strong>内存管理</strong><br>如果不好好做内存管理, 会导致内存泄漏<br>内存管理的声明周期: 申请, 使用, 释放</p>
<p><strong>垃圾回收</strong><br>JS 有自动垃圾回收机制, 那么这个自动垃圾回收机制的原理是什么呢？其实很简单, 对象不再被引用时就是垃圾, 就是找出那些不再继续使用的值, 然后释放其占用的内存。<br>大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到不再需要使用的变量。<br>已存在的对象, 让我们不能从根上访问时也是垃圾</p>
<p><strong>引用与可达对象</strong><br>垃圾回收算法主要依赖于引用的概念。<br>在内存管理的环境中, 一个对象如果有访问另一个对象的权限（隐式或者显式）, 叫做一个对象引用另一个对象。<br>从根上可以找到的对象是可达对象.</p>
<h4 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h4><p>gc就是垃圾回收机制的简写, gc可以找到内存中的垃圾, 并释放和回收空间</p>
<p><strong>gc里的垃圾是什么</strong><br>程序中不再需要的对象<br>程序组不能再访问到的对象</p>
<p><strong>常见的gc算法</strong></p>
<ul>
<li>引用计数</li>
<li>标记清除</li>
<li>标记整理</li>
<li>分代回收</li>
</ul>
<h5 id="引用计数算法实现原理"><a href="#引用计数算法实现原理" class="headerlink" title="引用计数算法实现原理"></a>引用计数算法实现原理</h5><p>核心思想: 设置引用数, 判断当前引用数是否为0</p>
<ul>
<li>给对象中添加一个引用计数器, 每当有一个地方引用它时, 计数器值就加1</li>
<li>当引用失效时, 计数器值就减1；</li>
<li>任何时刻计数器为0的对象就是不可能再被使用的。</li>
<li>引用数字为0时立即回收</li>
</ul>
<blockquote>
<p>优点</p>
</blockquote>
<p>会立即回收垃圾<br>最大限度减少程序暂停（卡顿））</p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>无法回收循环引用的对象（互相引用）<br>时间开销大（资源消耗打）</p>
<h5 id="标记清除算法实现原理"><a href="#标记清除算法实现原理" class="headerlink" title="标记清除算法实现原理"></a>标记清除算法实现原理</h5><p>标记清除算法是现代垃圾回收算法的思想基础。<br>标记清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。</p>
<ul>
<li>在标记阶段, 首先通过根节点, 标记所有从根节点开始的可达对象。未被标记的对象就是未被引用的垃圾对象；</li>
<li>在清除阶段, 清除所有未被标记的对象。</li>
<li>回收相应的空间, 放在空闲链表上方便以后申请使用</li>
</ul>
<blockquote>
<p>优点</p>
</blockquote>
<p>可以解决循环引用回收操作</p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>空间碎片化<br>释放的地址空间不连续<br>不会立即回收垃圾对象（回收时停止工作）</p>
<h5 id="标记整理实现原理"><a href="#标记整理实现原理" class="headerlink" title="标记整理实现原理"></a>标记整理实现原理</h5><p>标记整理可以看做是标记清除的增强版</p>
<ul>
<li>标记阶段的操作和标记清除一致</li>
<li>清除阶段会先执行整理,移动对象位置</li>
</ul>
<p>标记整理回收的空间基本是连续的, 不会立即回收垃圾对象</p>
<h5 id="常见gc算法总结"><a href="#常见gc算法总结" class="headerlink" title="常见gc算法总结"></a>常见gc算法总结</h5><p>参考资料:<br><a href="https://blog.csdn.net/qq_40028324/article/details/92970588">https://blog.csdn.net/qq_40028324/article/details/92970588</a><br><a href="https://www.cnblogs.com/qianguyihao/p/4744233.html">https://www.cnblogs.com/qianguyihao/p/4744233.html</a></p>
<h4 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h4><p>V8是一款主流的JavaScript执行引擎, 采用即时编译, 内存设限为64位操作系统1.5G,32位操作系统800M</p>
<p><strong>v8垃圾回收策略</strong><br>采用分代回收的思想, 内存分为新生代、老生代, 针对不同对象采用不同算法</p>
<p><strong>V8中常用GC算法</strong></p>
<ul>
<li>分代回收</li>
<li>空间复制</li>
<li>标记清除</li>
<li>标记整理</li>
<li>标记增量</li>
</ul>
<p><strong>v8内存分配</strong><br>V8内存空间一分为二, 小空间用于存储新生代对象（64位32M | 32位16M)</p>
<h5 id="分代回收算法原理"><a href="#分代回收算法原理" class="headerlink" title="分代回收算法原理"></a>分代回收算法原理</h5><p><strong>新生代对象</strong><br>内存分为新生代和老生代, 新生代指的是存活时间较短的对象</p>
<p>新生代对象回收实现</p>
<ul>
<li>回收过程采用复制算法＋标记整理</li>
<li>新生代内存区分为两个等大小空间, 使用空间为From, 空闲空间为To, 活动对象存储于From空间</li>
<li>标记整理后将活动对象拷贝至To空间</li>
<li>From与To交换空间完成释放</li>
</ul>
<p><strong>老年代对象</strong><br>老年代对象就是指存活时间较长的对象, 存放在右侧老生代区域(64位操作系统1.4G,32操作系统700M)</p>
<p>老年代对象回收实现</p>
<ul>
<li>主要采用标记清除、标记整理、增量标记算法·首先使用标记清除完成垃圾空间的回收</li>
<li>采用标记整理进行空间优化</li>
<li>采用增量标记进行效率优化</li>
</ul>
<p><strong>新老对比</strong><br>新生代区域垃圾回收使用空间换时间, 使用复制和整理算法<br>老生代区域垃圾回收不适合复制算法, 使用标记清除, 标记整理, 标记增量</p>
<h5 id="v8引擎工作流程"><a href="#v8引擎工作流程" class="headerlink" title="v8引擎工作流程"></a>v8引擎工作流程</h5><p>扫描器 解析器<br>预解析优点<br>·跳过未被使用的代码<br>·不生成AST, 创建无变量引用和声明的scopes·依据规范抛出特定错误<br>解析速度更快</p>
<p>全量解析<br>·解析被使用的代码·生成AST<br>·构建具体scopes信息,变量引用、声明等·抛出所有语法错误</p>
<p>lgnition是V8提供的一个解释器<br>TurboFan是V8提供的编译器模块</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>V8是一款主流的 JavaScript 执行引擎</li>
<li>V8内存设置上限（用户感知不到）</li>
<li>V8采用基于分代回收思想实现垃圾回收</li>
<li>V8内存分为新生代和老生代</li>
</ul>
<h4 id="performance介绍"><a href="#performance介绍" class="headerlink" title="performance介绍"></a>performance介绍</h4><p>我们为什么使用 Performance?<br>GC的目的是为了实现内存空间的良性循环, 良性循环的基石是合理使用, 时刻关注才能确定是否合理.<br>Performance为我们提供多种监控方式, 通过Performance可以时刻监控内存</p>
<p><strong>内存问题的体现</strong><br>1.页面出现延迟加载或经常性暂停<br>2.页面持续性出现糟糕的性能<br>3.页面的性能随时间延长越来越差</p>
<p><strong>界定内存问题的标准</strong><br>1.内存泄露: 内存使用持续升高<br>2.内存膨胀: 在多数设备上都存在性能问题<br>3.频繁垃圾回收: 通过内存变化图进行分析</p>
<p><strong>监控内存的几种方式</strong><br>浏览器任务管理器<br>Timeline时序图记录<br>堆快照查找分离DOM<br>判断是否存在频繁的垃圾回收</p>
<p><strong>任务管理器监控内存变化</strong>（Shift+esc）<br>timeline（在性能里）<br>堆快照查找分离dom</p>
<p><strong>判断是否频繁gc</strong><br>为什么确定频繁垃圾回收<br>GC工作时应用程序是停止的<br>频繁且过长的GC会导致应用假死<br>用户使用中感知应用卡顿</p>
<h4 id="堆栈内存操作"><a href="#堆栈内存操作" class="headerlink" title="堆栈内存操作"></a>堆栈内存操作</h4><p><strong>堆栈准备</strong></p>
<ul>
<li>JS执行环境</li>
<li>执行环境栈（ECStack, execution context stack): 执行上下文</li>
<li>Vo(G): 全局变量对象</li>
</ul>
<p><strong>引用类型堆栈</strong><br>1.变量提升：（声明）<br>2.代码执行：（赋值）<br>3.放对象的是堆内存<br>4.对象存的是地址</p>
<p><strong>函数堆栈</strong><br>函数创建</p>
<ul>
<li>可以将函数名称看做是变量，存放在 VO 当中 ，同时它的值就是当前函数对应的内存地址</li>
<li>函数本身也是一个对象，创建时会有一个内存地址，空间内存放的就是函数体代码（字符串形式的）</li>
</ul>
<p>函数执行</p>
<ul>
<li>函数执行时会形成一个全新私有上下文，它里面有一个AO 用于管理这个上下文当中的变量</li>
<li>步骤：<br>01 作用域链 &lt;当前执行上下文， 上级作用域所在的执行上下文&gt;<br>02 确定 this<br>03 初始化 arguments （对象）<br>04 形参赋值：它就相当于是变量声明，然后将声明的变量放置于 AO<br>05 变量提升<br>06 代码执行</li>
</ul>
<p>这里由函数内存处理可以引出闭包</p>
<p><strong>闭包堆栈处理</strong><br>函数调用形成了一个全新的私有上下文，在函数调用之后当前上下文不被释放就形成了闭包（临时不被释放）<br>闭包是一种机制<br> 保护：当前上下文当中的变量与其它的上下文中变量互不干扰<br> 保存：当前上下文中的数据（堆内存）被当前上下文以外的上下文中的变量所引用，这个数据就保存下来了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c + b++)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = foo()</span><br><span class="line">f(<span class="number">5</span>)</span><br><span class="line">f(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p><strong>jsbench.me</strong><br>jsbench是一个网站, 它可以比较两段代码运行的速度, 对性能优化很方便, 使用方法也很简单, 这里不多做描述<br>下面列举的例子都可以通过这个网站来观察运行速度</p>
<p><strong>变量局部化</strong><br>这样可以提高代码的执行效率（ 减少了数据访问时需要查找的路径 ）<br>函数嵌套时, 定义离使用处越近越好</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i, str = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">packageDom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    str += i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">packageDom()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">packageDom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    str += i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">packageDom()</span><br></pre></td></tr></table></figure>

<p><strong>缓存数据</strong><br>对于需要多次使用的数据进行保存 方便后续使用<br>把本该 去其他房间的东西存到自己房间(查找作用域链会变快)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oBox = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;skip&#x27;</span>)</span><br><span class="line"><span class="comment">// 假设在当前的函数体当中需要对 className 的值进行多次使用，那么我们就可以将它提前缓存起来</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasClassName</span>(<span class="params">ele, cls</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ele.className)</span><br><span class="line">    <span class="keyword">return</span> ele.className == cls</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hasClassName(oBox, <span class="string">&#x27;skip&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasClassName</span>(<span class="params">ele, cls</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clsName = ele.className</span><br><span class="line">    <span class="built_in">console</span>.log(clsName)</span><br><span class="line">    <span class="keyword">return</span> clsName == cls</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hasClassName(oBox, <span class="string">&#x27;skip&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>减少访问层级</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var obj = &#123;</span></span><br><span class="line"><span class="comment">//   age: 18, </span></span><br><span class="line"><span class="comment">//   methods: &#123;</span></span><br><span class="line"><span class="comment">//     m1: &#123;</span></span><br><span class="line"><span class="comment">//       name: &#x27;&#x27;, </span></span><br><span class="line"><span class="comment">//       time: 100</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     m2: &#123;</span></span><br><span class="line"><span class="comment">//       name: &#x27;&#x27;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//以上代码层级过多, 运行速度会慢</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;zce&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">40</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p1.age)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;zce&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">40</span></span><br><span class="line">  <span class="built_in">this</span>.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p1.getAge())</span><br></pre></td></tr></table></figure>

<p><strong>防抖与节流</strong><br>这部分知识我单独写了一篇文章, <a href="https://levxn7.github.io/2021/06/03/fdjl/">摸下这里可以跳过去查看</a></p>
<p><strong>减少判断层级</strong><br>应当提前return无用的条件<br>如果有很多else if建议使用swich case</p>
<p><strong>减少循环体活动</strong></p>
<p><strong>字面量与构造式</strong></p>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>参考资料:<br><a href="https://zhuanlan.zhihu.com/p/81767710">https://zhuanlan.zhihu.com/p/81767710</a></p>
<p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>内存管理</tag>
        <tag>垃圾回收</tag>
        <tag>V8</tag>
        <tag>GC算法</tag>
      </tags>
  </entry>
  <entry>
    <title>异步编程</title>
    <url>/2021/11/20/ybbc/</url>
    <content><![CDATA[<p>概要：</p>
<ul>
<li>同步模式与异步模式</li>
<li>事件循环与消息队列</li>
<li>异步编程的几种方式</li>
<li>Promise异步方案、宏任务/微任务队列</li>
<li>Generator异步方案、Async / Await语法糖</li>
</ul>
<h4 id="什么是同步模式和异步模式"><a href="#什么是同步模式和异步模式" class="headerlink" title="什么是同步模式和异步模式"></a>什么是同步模式和异步模式</h4><p>同步函数：当一个函数是同步执行时，那么当该函数被调用时不会立即返回，直到该函数所要做的事情全都做完了才返回.调用栈（工作表）,消息循环(eventloop)，把全部代码放入匿名函数去执行, 如果某一功能执行时间过长，后面就会阻塞（卡死），所以需要异步函数.</p>
<p>异步函数：如果一个异步函数被调用时，该函数会立即返回尽管该函数规定的操作任务还没有完成.含有异步函数的代码的执行顺序会混乱, 代码不会等待程序执行完, 同步函数执行完了才会去执行异步函数.</p>
<p>异步函数h调用时，调用方不等被调方返回结果就转身离去，因此必须有一种机制让被调方有了结果时能通知调用方.在同一进程中有很多手段可以利用，常用的手段是回调、event 对象和消息.</p>
<p>回调方式很简单：调用异步函数时在参数中放入一个函数地址，异步函数保存此地址，待有了结果后回调此函数便可以向调用方发出通知.如果把异步函数包装进一个对象中，可以用事件取代回调函数地址，通过事件处理例程向调用方发通知.</p>
<p>回调函数是所有异步编程方案的根基，但大量嵌套回调不可取(回调地狱).</p>
<blockquote>
<p>小tips: 使用setTimeout 0 可以把同步代码变为异步代码</p>
</blockquote>
<h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><p>promise的几个特点</p>
<ul>
<li>promise是一个对象，对象和函数的区别就是对象可以保存状态，函数不可以（闭包除外）.</li>
<li>并未剥夺函数return的能力，因此无需层层传递callback，进行回调获取数据.</li>
<li>代码风格，容易理解，便于维护.</li>
<li>多个异步等待合并便于解决.</li>
</ul>
<h5 id="一个最最简单的promise"><a href="#一个最最简单的promise" class="headerlink" title="一个最最简单的promise"></a>一个最最简单的promise</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>promise的使用案例(基本应用)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用promise实现ajax</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.open(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line">    xhr.responseType = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="built_in">this</span>.response)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(<span class="string">&#x27;/api/foo.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h5 id="promise有三个状态：pending-fulfilled-rejected"><a href="#promise有三个状态：pending-fulfilled-rejected" class="headerlink" title="promise有三个状态：pending, fulfilled, rejected."></a>promise有三个状态：pending, fulfilled, rejected.</h5><p>promise状态一经改变，就不会再改变了.且状态改变只有两种可能：</p>
<ul>
<li>从pending变为fulfilled</li>
<li>从pending变为rejected.</li>
</ul>
<p>这两种情况只要发生，状态就凝固了，不会再变了.</p>
<p>当promise状态发生改变，就会触发then()里的响应函数处理后续步骤；</p>
<p>promise.then()方法有两个参数, resolve和reject.</p>
<p>resolve作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<br>reject作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去.</p>
<h5 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h5><p>promise在使用中要避免回调嵌套，尽量保持扁平化.</p>
<ul>
<li>Promise对象的then方法会返回一个全新的 Promise对象</li>
<li>后面的then方法就是在为上一个then返回的 Promise注册回调</li>
<li>前面then方法中回调函数的返回值会作为后面then方法回调的参数</li>
<li>如果回调中返回的是 Promise，那后面then方法的回调会等待它的结束</li>
</ul>
<p><strong>.then()</strong><br>1、接收两个函数作为参数，分别代表fulfilled（成功）和rejected（失败）<br>2、.then()返回一个新的Promise实例，所以它可以链式调用<br>3、当前面的Promise状态改变时，.then()根据其最终状态，选择特定的状态响应函数执行<br>4、状态响应函数可以返回新的promise，或其他值，不返回值也可以我们可以认为它返回了一个null；<br>5、如果返回新的promise，那么下一级.then()会在新的promise状态改变之后执行<br>6、如果返回其他任何值，则会立即执行下一级.then()<br>7、.then()里面的实参应该是函数.如果不是函数,就无视它’</p>
<blockquote>
<p>.then()里面有.then()的情况</p>
<ul>
<li>因为.then()返回的还是Promise实例</li>
<li>会等里面的then()执行完，再执行外面的</li>
<li>对于我们来说，此时最好将其展开，也是一样的结果，而且会更好读</li>
</ul>
</blockquote>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>Promise会自动捕获内部异常，并交给rejected响应函数处理.</p>
<p>第一种：reject(‘错误信息’).then(() =&gt; {}, () =&gt; {错误处理逻辑})<br>第二种：throw new Error(‘错误信息’).catch( () =&gt; {错误处理逻辑})<br>推荐使用第二种方式，更加清晰好读，并且可以捕获前面所有的错误（可以捕获N个then回调错误）<br>.then onFulfilled<br>.catch onRejected<br>应该在代码中明确捕获每一个可能存在的异常 而不是丢给全局去处理</p>
<h5 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h5><blockquote>
<p>.all()</p>
</blockquote>
<p>Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 对象的实例.（Promise.all 方法的参数不一定是数组，但是必须具有 iterator 接口，且返回的每个成员都是 Promise 实例.）</p>
<p>.all()的状态分成两种情况.</p>
<ul>
<li>只有p1、p2/p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时入参的返回值组成一个数组，传递给p的回调函数.</li>
<li>只要p1、p2/p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;成功了&#x27;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;success&#x27;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = Promse.reject(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)     </span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;)          </span><br><span class="line">  <span class="comment">//[&#x27;成功了&#x27;, &#x27;success&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1,p3,p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)   </span><br><span class="line">  &#125;)   </span><br><span class="line">  <span class="comment">// 失败了，打出 &#x27;失败&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>.race()</p>
</blockquote>
<p>.race()只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">      &#125;，<span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;p2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = Promse.reject(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)     </span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;)          </span><br><span class="line">  <span class="comment">//p2跑的更快 打印p2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1,p3,p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)   </span><br><span class="line">  &#125;)   </span><br><span class="line">  <span class="comment">// 失败了，打出 &#x27;失败&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><blockquote>
<p>.resolve方法</p>
</blockquote>
<p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用.</p>
<p>此时我们测试.resolve()函数，如果传入一个promise则返回这个promise，运行结果为: p1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myPromise.resolve(p1()).then( <span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure>
<p>如果传入一个常量则返回一个promise包裹这个常量，运行结果为: 100</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myPromise.resolve(<span class="number">100</span>).then( <span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure>

<h5 id="执行时序-宏任务vs微任务"><a href="#执行时序-宏任务vs微任务" class="headerlink" title="执行时序/宏任务vs微任务"></a>执行时序/宏任务vs微任务</h5><p>宏任务是由宿主发起的，而微任务由JavaScript自身发起。<br>在ES3以及以前的版本中，JavaScript本身没有发起异步请求的能力，也就没有微任务的存在。在ES5之后，JavaScript引入了Promise，这样，不需要浏览器，JavaScript引擎自身也能够发起异步任务了。<br>回调任务中的任务称为宏任务，要重新排队.<br>promise中的任务是微任务，可直接执行.（process.nextTick/MutationObserver也是微任务）<br>所以，总结一下，两者区别为：</p>
<table>
    <tr>
        <th></th>
        <th>宏任务（macrotask）</th>
        <th>微任务（microtask）</th>  
    </tr>
    <tr>
        <td>谁发起的</td>
        <td>宿主（Node、浏览器）</td>
        <td>JS引擎</td>
    </tr>
    <tr>
        <td rowspan="5">具体事件</td>
        <td>1. script (可以理解为外层同步代码)</td>
        <td>1. Promise</td>
    </tr>
    <tr>
        <td>2. setTimeout/setInterval</td>
        <td>2. MutaionObserver</td>
    </tr>
    <tr>
        <td>3. UI rendering/UI事件</td>
        <td>3. Object.observe（已废弃；Proxy 对象替代）</td>
    </tr>
    <tr>
        <td>4. postMessage，MessageChannel</td>
        <td>4. process.nextTick（Node.js）</td>
    </tr>
    <tr><td>5. setImmediate，I/O（Node.js）</td>
        <td></td>
    </tr>
    <tr>
        <td>谁先运行</td>
        <td>后运行</td>
        <td>先运行</td>
    </tr>
    <tr>
        <td>会触发新一轮Tick吗</td>
        <td>会</td>
        <td>不会</td>
    </tr>
</table>

<h4 id="Generator异步方案（es2015）"><a href="#Generator异步方案（es2015）" class="headerlink" title="Generator异步方案（es2015）"></a>Generator异步方案（es2015）</h4><blockquote>
<p>这部分我会在其他博文中详细写到.届时贴链接过来.</p>
</blockquote>
<p>生成器函数, 就是函数名前多个*<br>调用不会马上执行, 但会得到一个生成器对象<br>调用.next()时执行<br>执行到函数里yield那一行, 把yield的值作为对象中的value返回<br>再次调用.next()如果有参数会从yield继续执行, 参数作为yield的值<br>.throw（）会抛出异常  执行.catch<br>.done 布尔  是否结束生成器<br>扩展: co库</p>
<h4 id="async-await是生成器的语法糖"><a href="#async-await是生成器的语法糖" class="headerlink" title="async/await是生成器的语法糖"></a>async/await是生成器的语法糖</h4><blockquote>
<p>这部分我会在其他博文中详细写到.届时贴链接过来.</p>
</blockquote>
<p>是语言层面的异步编程标准.</p>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>参考资料: <a href="https://www.jianshu.com/p/bfc3e319a96b">https://www.jianshu.com/p/bfc3e319a96b</a></p>
<p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器性能优化(概览)</title>
    <url>/2022/02/13/xnyh2/</url>
    <content><![CDATA[<h5 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h5><p>性能优化不是一下子就能做好的，他是一个迭代优化的过程<br>根据性能指标测量</p>
<ul>
<li>浏览器自有的调试工具 DevTools</li>
<li>灯塔：网站整体质量评估，并给出优化建议</li>
</ul>
<p>性能优化</p>
<ul>
<li>从发出请求到收到响应的优化，比如DNS查询、HTTP长连接、HTTP 2、HTTP压缩、HTTP缓存等。</li>
<li>关键渲染路径优化，比如是否存在不必要的重绘和回流。</li>
<li>加载过程的优化，比如延迟加载，是否有不需要在首屏展示的非关键信息，占用了页面加载的时间。</li>
<li>资源优化，比如图片、视频等不同的格式类型会有不同的使用场景，在使用的过程中是召恰当。</li>
<li>构建优化，比如压缩合并、基于webpack 构建优化方案等。</li>
<li>等。。</li>
</ul>
<h5 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h5><p><a href="https://web.dev/">https://web.dev</a><br>在讨论性能的时候，精确的、可量化的指标很重要<br><strong>google提出的Rail：</strong><br>Response：&lt;100ms，如果没有结果也要给loding<br>Animation： 一帧大概10ms左右<br>ldle：执行时间尽量小于50ms，超过50ms的成为长任务<br>Load：首次加载应&lt;5s，后续加载建议在2s内完成</p>
<p>6种优化指标</p>
<ul>
<li>First Contentful Paint (FCP)首次绘制，应小于2s</li>
<li>Largest Contentful Paint (LCP)最大内容绘制，要考虑img video元素的封面图 等各大图片元素  应在2.5s以内</li>
<li>First Input Delay (FID)首次输入延迟，常见原因是浏览器正忙于解析和执行应用程序加载的大量计算的JavaScript。很多html元素需要等待主线程结束才能开始，应在100ms内</li>
<li>Time to lnteractive (TTI)网页到达完全可交互状态的时间点（是在最后一个长任务完成的时间，并在随后的5s内网络和主线是空闲的。3.8s内较好</li>
<li>Total Block Time (TBT) FCP和TTI的总时间 阻塞时间 300ms内</li>
<li>Cumulative Layout Shift (CLS)累计布局偏移0.1ms之内表现较好</li>
</ul>
<h5 id="web-vitals"><a href="#web-vitals" class="headerlink" title="web vitals"></a>web vitals</h5><p>goole制定的性能标准 LCP FID CLS<br>测量 Web Vitals<br>性能测试工具，比如Lighthouse<br>·使用web-vitals 库<br>使用浏览器插件Web Vitals(应用商店）</p>
<p>性能测试概述<br>性能检测作为性能优化过程中的一环，它的目的通常是给后续优化工作提供指导方向、参考基线及前后对比的依据。性能检测并不是一次性执行结束后就完成的工作，它会在检测、记录和改进的迭代过程中不断重复，来协助网站的性能优化不断接近期望的效果。</p>
<p>Lighthouse：是一个由Google开发并开源的 Web性能测试工具，用于改进网络应用的质量。您可以将其作为一个Chrome扩展程序运行，或从命令行运行。您为Lighthouse提供一个您要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。<br>webPageTest：是个网站<br>DevTools：shift+esc任务管理器  network</p>
<h5 id="前端页面的生命周期"><a href="#前端页面的生命周期" class="headerlink" title="前端页面的生命周期"></a>前端页面的生命周期</h5><p>建立http请求：DNS通道和通信链路的建立<br>DNS：先找缓存 拿到ip<br>网络模型：应用 传输 网络 数据链路层<br>tcp链接：三次握手 四次挥手<br>反向代理服务器</p>
<h4 id="请求和响应优化介绍"><a href="#请求和响应优化介绍" class="headerlink" title="请求和响应优化介绍"></a>请求和响应优化介绍</h4><p>目的:更快的内容到达时间。<br>核心思路:<br>1.更好的连接传输效率<br>2.更少的请求数量<br>3.更小的资源大小<br>4.合适的缓存策略</p>
<p>最佳实践:<br>1.减少DNS查找:每次主机名的解析都需要一次网络往返，从而增加了请求的延迟时间，同时还会阻塞后续的请求。<br>2．重用TCР 连接:尽可能的使用持久连接，以消除因TCP握手和慢启动导致的延迟。<br>3.减少HTTP重定向:HTTP冲定向需要额外的DNS查询、TCP握手等非常耗时，最佳的重定向次数为0。4．压缩传输的资源:比如Gzip、图片压缩。<br>5．使用缓存:比如HTTP缓存、CDN缓存、Service Worker 缓存。<br>6.使用CDN(内容分发网络)︰把数据放在离用户地理位置更近的地方，可以明显减少每次TCP连接的网络延迟，增大吞吐星,7．删除没有必要请求的资源。<br>8．在客户端缓存资源:缓存必要的应用资源，避免每次都重复请求相同的内容，例如多图片下载可以考虑使用缓存。<br>9.内容在传输前先压缩:传输数据之前应该先压缩应用资源，把要传输的字节减少到最小，在压缩的时候确保对每种不同的资源采用最好的压缩手段。10．消除不必要的请求开销:减少请求的HTTP首部数据(比如HTTP COokie)<br>11.并行处理请求和响应:请求和响应的排队都会导致延迟，可以尝试并行的处理请求和响应(利用多个HTP11连接实现并行下载，在可能的情况下使用HTP管道计数)，12．针对协议版本采取优化措施。升级到HTTP2.0。<br>拉勾教<br>13．根据需要采用服务端渲染方式。这种方式可以解决SPA应用首屏渲染慢的问题。<br>14．采用预渲染的方式快速加载静态页面。页面渲染的极致性能，比较适合静态页面。</p>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>关于8月13日Github改版,hexo受到影响的总结</title>
    <url>/2021/08/20/813problem/</url>
    <content><![CDATA[<p>关于8月13日Github改版,hexo受到影响的总结</p>
<p>众所周知,2021年8月13日Github的改版影响了不少项目,Github以密码不安全为由建议用户改用秘钥.</p>
<p>当时的提交报错为:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">remote: Support <span class="keyword">for</span> password authentication was removed on August <span class="number">13</span>, <span class="number">2021.</span> Please use a personal access token instead.</span><br></pre></td></tr></table></figure>
<p>这个问题其实很好解决,网上有很多人分享了解决过程,解决完上述报错,一般还会引起一系列报错,国内网络上都有很多人分享解决办法,这里不多赘述.<br>参考<a href="https://www.codepeople.cn/2021/09/02/github-problem/">https://www.codepeople.cn/2021/09/02/github-problem/</a></p>
<p>但是修改之后hexo编译后也是犹豫8.13的问题同步不到github.io上面去,怎么办呢</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com<span class="comment">//验证key 如果验证失败执行下列命令</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxx@qq.com&quot;</span><span class="comment">//一路回车即可</span></span><br><span class="line">ssh -v git@github.com</span><br><span class="line"><span class="comment">//　　最后两句会出现：</span></span><br><span class="line"><span class="comment">//　　No more authentication methods to try.</span></span><br><span class="line"><span class="comment">//　　Permission denied (publickey).</span></span><br><span class="line"><span class="comment">//　　这时候再输入</span></span><br><span class="line">ssh-agent -s</span><br><span class="line"><span class="comment">/*然后会提示类似的信息：　　</span></span><br><span class="line"><span class="comment">SSH_AUTH_SOCK=/tmp/ssh-GTpABX1a05qH/agent.404; export SSH_AUTH_SOCK;  　　</span></span><br><span class="line"><span class="comment">SSH_AGENT_PID=13144; export SSH_AGENT_PID;  　　</span></span><br><span class="line"><span class="comment">echo Agent pid 13144;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ssh-add ~<span class="regexp">/.ssh/i</span>d_rsa</span><br><span class="line"><span class="comment">/*这时候应该会提示：　　Identity added: ...（这里是一些ssh key文件路径的信息）　　</span></span><br><span class="line"><span class="comment">（注意）如果出现错误提示：　　Could not open a connection to your authentication agent.　　</span></span><br><span class="line"><span class="comment">请执行命令：eval `ssh-agent -s`后继续执行命令 ssh-add ~/.ssh/id_rsa，这时候一般没问题啦。</span></span><br><span class="line"><span class="comment">将里面的内容复制，进入你的github账号，在settings下，SSH and GPG keys下new SSH key，</span></span><br><span class="line"><span class="comment">title随便取一个名字，然后将id_rsa.pub里的内容复制到Key中，完成后Add SSH Key。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="comment">/*提示：Hi xxx! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="comment">　　这时候你的问题就解决啦</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器性能优化(请求和响应优化)</title>
    <url>/2022/02/16/xnyh3/</url>
    <content><![CDATA[<h4 id="请求和响应优化介绍"><a href="#请求和响应优化介绍" class="headerlink" title="请求和响应优化介绍"></a>请求和响应优化介绍</h4><p>目的:更快的内容到达时间。<br>核心思路:<br>1.更好的连接传输效率<br>2.更少的请求数量<br>3.更小的资源大小<br>4.合适的缓存策略</p>
<p>最佳实践:<br>1.减少DNS查找:每次主机名的解析都需要一次网络往返，从而增加了请求的延迟时间，同时还会阻塞后续的请求。<br>2．重用TCР 连接:尽可能的使用持久连接，以消除因TCP握手和慢启动导致的延迟。<br>3.减少HTTP重定向:HTTP冲定向需要额外的DNS查询、TCP握手等非常耗时，最佳的重定向次数为0。<br>4．压缩传输的资源:比如Gzip、图片压缩。<br>5．使用缓存:比如HTTP缓存、CDN缓存、Service Worker 缓存。<br>6.使用CDN(内容分发网络)︰把数据放在离用户地理位置更近的地方，可以明显减少每次TCP连接的网络延迟，增大吞吐星,<br>7．删除没有必要请求的资源。<br>8．在客户端缓存资源:缓存必要的应用资源，避免每次都重复请求相同的内容，例如多图片下载可以考虑使用缓存。<br>9.内容在传输前先压缩:传输数据之前应该先压缩应用资源，把要传输的字节减少到最小，在压缩的时候确保对每种不同的资源采用最好的压缩手段。<br>10．消除不必要的请求开销:减少请求的HTTP首部数据(比如HTTP COokie)<br>11.并行处理请求和响应:请求和响应的排队都会导致延迟，可以尝试并行的处理请求和响应(利用多个HTP11连接实现并行下载，在可能的情况下使用HTP管道计数)，<br>12．针对协议版本采取优化措施。升级到HTTP2.0。<br>拉勾教<br>13．根据需要采用服务端渲染方式。这种方式可以解决SPA应用首屏渲染慢的问题。<br>14．采用预渲染的方式快速加载静态页面。页面渲染的极致性能，比较适合静态页面。</p>
<h5 id="DNS解析优化"><a href="#DNS解析优化" class="headerlink" title="DNS解析优化"></a>DNS解析优化</h5><p>减少DNS的查找和请求次数<br>进行DNS预获取:DNS Prefetch 《link ref=”dns-prefetch” href=””&gt;</p>
<ul>
<li>不要预解析当前域</li>
<li>不要多页面重复预解析</li>
<li>禁用预解析<meta http-equiv="x-dns-prefetch-control" content="off"><br>延长dns缓存时间<br>使用cdn加速域名<br>搭建自己的dns服务</li>
</ul>
<h5 id="http长连接"><a href="#http长连接" class="headerlink" title="http长连接"></a>http长连接</h5><p>tcp连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。<br>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早的结束，这样Web页面的显示速度也就相应提高了。<br>缺点是响应是串行的 很容易队头堵塞<br>为了避免有两种办法，一个是减少请求数，一个是同时多开持久连接</p>
<h5 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h5><p>http2的前身是谷歌自行研发的SPDY协议<br><strong>二进制协议</strong><br><strong>多工</strong><br>HTTP/2复用TCР连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一—对应，这样就避免了”队头堵塞”。<br>并发请求 并发响应，这样双向的、实时的通信，就叫做多工(Multiplexing) 。<br><strong>数据流</strong><br>HTTP/2将每个请求或回应的所有数据包，称为一个数据流(stream)。每个数据流都有-个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。<br>数据流发送到一半的时候，客户端和服务器都可以发送信号(RST_STREAM帧)，取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP 连接。这就是说，HTTP/2可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。<br>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。<br><strong>头信息压缩</strong><br>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。<br>HTTP/2对这一点做了优化，引入了头信息压缩机制(header compression)。一方面，头信息使用gzip或compress压缩后再发送;另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。<br><strong>服务器推送</strong><br>HTTP/2允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送(serverpush) 。<br>你跟服务器要饭，他知道你缺碗还一块给了你一个碗</p>
<h5 id="压缩传输的数据资源"><a href="#压缩传输的数据资源" class="headerlink" title="压缩传输的数据资源"></a>压缩传输的数据资源</h5><p><strong>响应数据的压缩</strong><br>Gzip压缩文本 compression</p>
<p><strong>请求数据的压缩</strong><br>请求头：h1是不能压缩的，HTTP/2对这一点做了优化，引入了头信息压缩机制（header compression)<br>请求体：开发人员通过代码压缩（3种常见的压缩算法），后台也要提供解压<br>实际使用还需要匹配具体的服务器，比如nginx、Apache 等。</p>
<h5 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h5><p>缓存的原理是在首次请求后保存一份请求资源的响应副本，当用户再次发起相同请求后，如果判断缓存命中则拦截请求，将之前存储的响应副本返回给用户，从而避免重新向服务器发起资源请求。</p>
<p>缓存的技术种类有很多，比如代理缓存、浏览器缓存、网关缓存、负载均衡器及内容分发网络等，它们大致可以分为两类:共享缓存和私有缓存。共享缓存指的是缓存内容可被多个用户使用，如公司内部架设的Web代理;私有缓存指的是只能单独被用户使用的缓存，如浏览器缓存</p>
<p>HTTP缓存应该算是前端开发中最常接触的缓存机制之一，它又可细分为强制缓存与协商缓存，二者最大的区别在于判断缓存命中时，浏览器是否需要向服务器端进行询问以协商缓存的相关信息，进而判断是否需要就响应内容进行重新请求。下面就来具体看HTTP缓存的具体机制及缓存的决策策略。</p>
<p><strong>强制缓存</strong><br>其中与强制缓存相关的两个字段是expires（过期时间）和cache-control,</p>
<p>从上述强制缓存是否过期（expires）的判断机制中不难看出，这个方式存在一个很大的漏洞，即对本地时间戳过分依赖，如果客户端本地的时间与服务器端的时间不同步，或者对客户端时间进行主动修改，那么对于缓存过期的判断可能就无法和预期相符。</p>
<p>为了解决expires判断的局限性，从HTT1.1协议开始新增了cache-control字段来对expires的功能进行扩展和完善。</p>
<p>cache-control的配置</p>
<ul>
<li>no-cache（强制协商缓存） 和no-store（不缓存）</li>
<li>private（只能被浏览器缓存）和public（代理服务器也能缓存（如图像 css js等静态文件））也是cache-control的一组互斥属性值，它们用以明确响应资源是否可被代理服务器进行缓存。</li>
<li>max-age（缓存时间）属性值会比s-maxage（代理缓存时间（public时才生效））更常用，它表示服务器端告知客户端浏览器响应资源的过期时长。</li>
</ul>
<p>由此可见cache-control能作为expires的完全替代方案，并且拥有其所不具备的一些缓存控制特性，在项目实践中使用它就足够了，目前expires还存在的唯一理由是考虑可用性方面的向下兼容。</p>
<p><strong>协商缓存</strong><br>顾名思义，协商缓存就是在使用本地缓存之前，需要向服务器端发起一次GET请求，与之协商当前浏览器保存的本地缓存是否已经过期。所以需要向服务器发送一次GET请求，进行缓存有效性的协商，此次GET请求的请求头中需要包含一个ifmodified-since字段，其值正是上次响应头中last-modified的字段值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setHeader( <span class="string">&#x27;last-modified &#x27;</span> , mtime.toUTCString())</span><br><span class="line">res.setHeader( <span class="string">&#x27;Cache-Control&#x27;</span> , <span class="string">&#x27;no-cache &quot; )</span></span><br></pre></td></tr></table></figure>
<p>首先它只是根据资源最后的修改时间戳进行判断的，虽然请求的文件资源进行了编辑，但内容并没有发生任何变化，时间戳也会更新，从而导致协商缓存时关于有效性的判断验证为失效，需要重新进行完整的资源请求。这无疑会造成网络带宽资源的浪费，以及延长用户获取到目标资源的时间。</p>
<p>其次标识文件资源修改的时间戳单位是秒，如果文件修改的速度非常快，假设在几百毫秒内完成，那么上述通过时间戳的方式来验证缓存的有效性，是无法识别出该次文件资源的更新的。</p>
<p>基于ETag(指纹）的协商缓存：<br>其内容主要是服务器为不同资源进行哈希运算所生成的一个字符串，该字符串类似于文件指纹，只要文件内容编码存在差异，对应的ETag标签值就会不同，因此可以使用ETag 对文件资源进行更精准的变化感知。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装etag包并加载</span></span><br><span class="line"><span class="keyword">const</span> data = fs.readFilesync( <span class="string">&#x27;./img/04.jpg )</span></span><br><span class="line"><span class="string">const etagcontent = etag(data)</span></span><br><span class="line"><span class="string">res.setHeader( &#x27;</span>etag <span class="string">&#x27;, etagContent)</span></span><br><span class="line"><span class="string">res.setHeader( &#x27;</span>Cache-Control<span class="string">&#x27; , &#x27;</span>no-cache <span class="string">&quot; )</span></span><br></pre></td></tr></table></figure>
<p>一方面服务器对于生成文件资源的ETag需要付出额外的计算开销，如果资源的尺寸较大，数量较多且修改比较频繁，那么生成ETag的过程就会影响服务器的性能。</p>
<p>另一方面ETag字段值的生成分为强验证和弱验证，强验证根据资源内容进行生成，能够保证每个字节都相向;弱验证则根据资源的部分属性值来生成，生成速度快但无法确保每个字节都相同，并且在服务器集群场景下，也会因为不够准确而降低协商缓存有效性验证的成功率，所以恰当的方式是根据具体的资源使用场景选择恰当的缓存校验方式。</p>
<p><strong>缓存的注意事项</strong><br>这里建议你能够根据该决策树的流程去设置缓存策略，这样不但会让指定的策略有很高的可行性，而且对于理解缓存过程中的各个知识点也非常有帮助。<br>我们可以将一个网站所需要的资源按照不同类型去拆解，为不同类型的资源制定相应的缓存策略，以下面的HTML文件资源为例:</p>
<p>首先HTML在这里属于包含其他文件的主文件，为保证当其内容发生修改时能及时更新，应当将其设置为协商缓存，即为cache-control 字段添加no-cache属性值;其次是图片文件，因为网站对图片的修改基本都是更换修改，同时考虑到图片文件的数量及大小可能对客户端缓存空间造成不小的开销，所以可采用强制缓存且过期时间不宜过长，故可设置cache-control字段值为max-age=86400。</p>
<p>接下来需要考虑的是样式表文件style.css，由于其属于文本文件，可能存在内容的不定期修改，又想使用强制缓存来提高重用效率，故可以考虑在样式表文件的命名中增加文件指纹或版本号（(比如添加文件指纹后的样式表文件名变为了style.51ad84f7.css)，这样当发生文件修改后，不同的文件便会有不同的文件指纹，即需要请求的文件 URL不同了，因此必然会发生对资源的重新请求。同时考虑到网络中浏览器与CDN等中间代理的缓存，其过期时间可适当延长到一年，即cache-control: max-age=31536000。</p>
<p>最后是JavaScript脚本文件，其可类似于样式表文件的设置;采取文件指纹和较长的过期时间，如果JavaScript中包含了用户的私人信息而不想让中间代理缓存，则可为cache-control添加private属性值。</p>
<p>从这个缓存策略的示例中我们可以看出，对不同资源进行组合使用强制缓存、协商缓存及文件指纹或版本号，可以做到一举多得:及时修改更新、较长缓存过期时间及控制所能进行缓存的位置。</p>
<p>拆分源码，分包加载<br>预估资源的缓存时效<br>控制中间代理的缓存<br>避免网址的冗余<br>规划缓存的层次结构</p>
<p><strong>cdn缓存</strong><br>CDN网络能够缓存网站资源来提升首次请求的响应速度，但并非能适用于网站所有资源类型，它往往仅被用来存放网站的静态资源文件。所谓静态资源，就是指不需要网站业务服务器参与计算即可得到的资源，包括第三方库的JavaScript脚本文件、样式表文件及图片等，这些文件的特点是访问频率高、承载流量大，但更新修改频次低，且不与业务有太多耦合。</p>
<p>如果是动态资源文件，比如依赖服务器端渲染得到的 HTML页面，它需要借助服务器端的数据进行计算才能得到，所以它就不适合放在CDN缓存服务器上。</p>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器性能优化(渲染优化)</title>
    <url>/2022/02/24/xnyh4/</url>
    <content><![CDATA[<h4 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h4><p>浏览器从获取HTML到最终在屏幕上显示内容需要完成以下步骤:<br>1.处理HTML标记并构建DOM树。<br>2.处理CSS标记并构建CSSOM树。<br>3.将DOM与CSSOM合并成一个render tree。<br>4.根据渲染树来布局，以计算每个节点的几何信息。<br>5.将各个节点绘制到屏幕上。</p>
<p>JavaScript处理:前端项目中经常会需要响应用户操作，通过JavaScript对数据集进行计算、操作DOM元素，并展示动画等视觉效果。当然对于动画的实现，除了JavaScript，也可以考虑使用如CSS Animations、Transitions 等技术。<br>计算样式:在解析CSS文件后，浏览器需要根据各种选择器去匹配所要应用CSS规则的元素节点，然后计算出每个元素的最终样式。<br>页面布局:指的是浏览器在计算完成样式后，会对每个元素尺寸大小和屏幕位置进行计算。由于每个元素都可能会受到其他元素的影响，并且位于DOM树形结构中的子节点元素，总会受到父级元素修改的影响，所以页面布局的计算会经常发生。<br>绘制:在页面布局确定后，接下来便可以绘制元素的可视内容，包括颜色、边框、阴影及文本和图像。<br>合成:通常由于页面中的不同部分可能被绘制在多个图层上，所以在绘制完成后需要将多个图层按照正确的顺序在屏幕上合成，以便最终正确地渲染出来。</p>
<h5 id="优化dom"><a href="#优化dom" class="headerlink" title="优化dom"></a>优化dom</h5><p>html文件的尺寸应该尽可能小：总结起来有三种方式可以优化HTML:缩小文件的尺寸(Minify) 、使用gzip压缩(Compress)、使用缓存(HTTPCache) 。</p>
<h5 id="优化cssom"><a href="#优化cssom" class="headerlink" title="优化cssom"></a>优化cssom</h5><p>css的加载会阻塞网络渲染，避免在css种使用@import</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//阻塞渲染</span></span><br><span class="line">&lt;link href=<span class="string">&quot;style.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line"><span class="comment">//非阻塞(打印的样式）</span></span><br><span class="line">&lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;</span><br><span class="line">//非阻塞（媒体查询）(可变阻塞）</span><br><span class="line">&lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 40em)&quot;&gt;</span><br><span class="line">&lt;link href=&quot; portrait.css&quot; rel=&quot;stylesheet&quot; media=&quot;orientation : portrait&quot;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="优化js"><a href="#优化js" class="headerlink" title="优化js"></a>优化js</h5><p>异步加载JavaScript<br>避免同步请求<br>延迟解析JavaScript<br>避免运行时间长的JavaScript</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*具有defer特性的脚本不会阻塞页面。</span></span><br><span class="line"><span class="comment">具有defer特性的脚本总是要等到DOM</span></span><br><span class="line"><span class="comment">解析完毕，但在DOMContentLoaded事</span></span><br><span class="line"><span class="comment">件之前执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//如果有多个，会异步并行加载，按顺序执行</span></span><br><span class="line">&lt;script defer src=<span class="string">&quot;index.js&quot;</span>&gt;&lt;/ script&gt;</span><br><span class="line"><span class="comment">//如果有多个，会异步并行加载，按时间长短执行</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span>&lt;/ script&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// script放在最底部  可以head里这样利用空闲时间预加载</span></span><br><span class="line">&lt;link rel=<span class="string">&quot;preload&quot;</span> href=<span class="string">&quot;index.js&quot;</span>&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;index2.js&quot;&gt;</span><br><span class="line">// script放在最底部  可以预加载可能用到的非当前页面的资源</span><br><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;index.js&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="js执行优化"><a href="#js执行优化" class="headerlink" title="js执行优化"></a>js执行优化</h5><p>实现动画效果：能用css就不用js。使用js时每秒60帧最好<br>实践经验告诉我们，使用定时器实现的动画会在世些低端机器上出现抖动或者卡顿的现象，这主要是因为浏览器无法确定定时器的回调函数的执行时机。以 setInterval为例，其创建后回调任务会被放入异步队列，只有当主线程上的任务执行完成后，浏览器才会去检查队列中是否有等待需要执行的任务，如果有就从任务队列中取出执行，这样会使任务的实际执行时机比所设定的延迟时间要晚一些。</p>
<p>其次屏幕分辨率和尺寸也会影响刷新频率，不同设备的屏幕绘制频率可能会有所不同，而setInterval只能设置某个固定的时间间隔，这个间隔时间不一定与所有屏幕的刷新时间同步，那么导致动画出现随机丢帧也在所难免。</p>
<p>为了避免这种动画实现方案中因丢帧而造成的卡顿现象，我们推荐使用<br>window. requestAnimationFrame（兼容到ie10）方法。与setInterval方法相比，其最大的优势是将回调函数的执行时机交由系统来决定，即如果屏幕刷新频率是60Hz，则它的回调函数大约会每16.7ms 执行一次，如果屏幕的刷新频率是75Hz，则它回调函数大约会每13.3ms执行一次，就是说requestAnimationFrame方法的执行时机会与系统的刷新频率同步。<br>这样就能保证回调函数在屏幕的每次刷新间隔中只被执行一次，从而避免因随机丢帧而造成的卡顿现象。</p>
<h5 id="恰当的使用web-worker"><a href="#恰当的使用web-worker" class="headerlink" title="恰当的使用web worker"></a>恰当的使用web worker</h5><p>众所周知JavaScript是单线程执行的，为此可将一些纯计算的工作迁移到 Web Worker上处理，它为JavaScript的执行提供了多线程环境，主线程通过创建出 Worker子线程，可以分担一部分自己的任务执行压力。在Worker子线程上执行的任务不会干扰主线程，待其上的任务执行完成后，会把结果返回给主线程，,这样的好处是让主线程可以更专注地处理UI交互，保证页面的使用体验流程。需要注意的是，Worker子线程一旦创建成功就会始终执行，不会被主线程上的事件所打断，这就意味着Worker 会比较耗费资源，所以不应当过度使用，一旦任务执行完毕就应及时关闭。除此之外，在使用中还有以下几点应当注意.</p>
<p>DOM限制:Worker无法读取主线程所处理网页的DOM对象，也就无法使用document、window和parent等对象，只能访问navigator和location对象。<br>文件读取限制: Worker子线程无法访问本地文件系统，这就要求所加载的脚本来自网络。<br>通信限制:主线程和Worker子线程不在同一个上下文内，所以它们无法直接进行通信，只能通过消息来完成。<br>脚本执行限制:虽然 Worker可以通过XMLHTTPRequest对象发起ajax请求，但不能使用alert()方法和confirm()方法在页面弹出提示。<br>同源限制: Worker子线程执行的代码文件需要与主线程的代码文件同源。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker( <span class="string">&#x27;worker.js &#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在子线程处理完相关任务后，需要及时关闭Worker子线程以节省系统资源，关闭的方式有两种:<br>·在主线程中通过调用worker.terminate()方法来关闭;<br>·在子线程中通过调用自身全局对象中的self.close()方法来关闭。</p>
<h5 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数1:函数//参数2:时间</span></span><br><span class="line"><span class="comment">//返回值:被防抖的函数</span></span><br><span class="line"><span class="built_in">document</span>.onscroll = _.debounce(<span class="function"><span class="keyword">function</span> (<span class="params"> &#123; <span class="built_in">console</span>.log( <span class="string">&#x27;hello&#x27;</span>)</span></span></span><br><span class="line"><span class="params"><span class="function"> &#125;,<span class="number">500</span></span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">//参数1:函数//参数2:时间</span></span><br><span class="line"><span class="function">//返回值:被节流的函数</span></span><br><span class="line"><span class="function"><span class="title">document</span>.<span class="title">onscroll</span> = <span class="title">_</span>.<span class="title">throttle</span>(<span class="params"><span class="keyword">function</span> ( &#123; <span class="built_in">console</span>.log( <span class="string">&#x27;hello&#x27;</span>)</span></span></span><br><span class="line"><span class="params"><span class="function"> &#125;,<span class="number">500</span>)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="计算样式优化"><a href="#计算样式优化" class="headerlink" title="计算样式优化"></a>计算样式优化</h5><p>减少要计算样式的元素数量<br>首先我们需要知道与计算样式相关的一条重要机制: csS引擎在查找样式表时，对每条规则的匹配顺序是从右向左的，这与我们通常从左向右的书写习惯相反。<br>(1)使用类选择器替代标签选择器，<br>(2）避免使用通配符做选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种操作在标签规模较小的demo 项目中，几乎看不出有任何性能差异。但对实际的工程项目来说，使用通配符就意味着在计算样式时，浏览器需要去遍历页面中的每一个元素，这样的性能开销很大，应当避免使用。<br>(3)降低选择器的复杂度<br>(4)使用BEM规范: BEM是一种CSS的书写规范，它的名称是由三个单词的首字母组成的，分别是块(Block) 、元素(Element)和修饰符(Modifier)。理论上它希望每行CSS代码只有一个选择器，这就是为了降低选择器的复杂性，对选择器的命名要求通过以下三个符号的组合来实现。<br>中画线(-)︰仅作为连字符使用，表示某个块或子元素的多个单词之间的连接符。<br>单下画线(_)︰作为描述一个块或其子元素的一种状态。<br>双下画线(__)︰作为连接块与块的子元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//常规写法</span><br><span class="line"><span class="selector-class">.mylist</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.mylist</span> <span class="selector-class">.item</span> &#123;&#125;</span><br><span class="line">//BEM写法</span><br><span class="line"><span class="selector-class">.mylist</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.mylist__item</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="页面布局与重绘"><a href="#页面布局与重绘" class="headerlink" title="页面布局与重绘"></a>页面布局与重绘</h5><p>页面布局也叫作重排和回流，指的是浏览器对页面元素的几何属性进行计算并将最终结果绘制出来的过程。凡是元素的宽高尺寸、在页面中的位置及隐藏或显示等信息发生改变时，都会触发页面的重新布局。<br>如果仅仅修改了DOM元素的样式，而未影响其几何属性时，则浏览器会跳过页面布局的计算环节，直接进入重绘阶段。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>尽量避免对样式的频繁改动<br>尽量使用更改类名对元素样式进行修改<br>缓存对敏感属性值的计算<br>使用requestAnimationFrame方法控制渲染帧（这里面的offsetHeight等是上一轮获取的 不用重新计算）</p>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>原创博文, 如有错误, 敬请指导!</p>
]]></content>
      <categories>
        <category>前端进阶笔记</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
</search>
